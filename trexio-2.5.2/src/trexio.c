/* This file was generated from the templator_front.org org-mode file.
   To generate it, open templator_front.org in Emacs and execute
   M-x org-babel-tangle
*/


#ifdef HAVE_CONFIG_H
  #include "config.h"
#endif

#include <math.h>
#include <pthread.h>
#include <assert.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <err.h>
#include <sys/types.h>
#include <sys/wait.h>


#include "trexio.h"
#include "trexio_private.h"
#include "trexio_s.h"
#include "trexio_text.h"
#ifdef HAVE_HDF5
  #include "trexio_hdf5.h"
#endif
/*
#include "trexio_json.h"
*/

const char*
trexio_string_of_error (const trexio_exit_code error)
{
  switch (error) {
  case TREXIO_FAILURE:
    return "Unknown failure";
    break;
  case TREXIO_SUCCESS:
    return "Success";
    break;
  case TREXIO_INVALID_ARG_1:
    return "Invalid argument 1";
    break;
  case TREXIO_INVALID_ARG_2:
    return "Invalid argument 2";
    break;
  case TREXIO_INVALID_ARG_3:
    return "Invalid argument 3";
    break;
  case TREXIO_INVALID_ARG_4:
    return "Invalid argument 4";
    break;
  case TREXIO_INVALID_ARG_5:
    return "Invalid argument 5";
    break;
  case TREXIO_END:
    return "End of file";
    break;
  case TREXIO_READONLY:
    return "Read-only file";
    break;
  case TREXIO_ERRNO:
    return strerror(errno);
    break;
  case TREXIO_INVALID_ID:
    return "Invalid ID";
    break;
  case TREXIO_ALLOCATION_FAILED:
    return "Allocation failed";
    break;
  case TREXIO_HAS_NOT:
    return "Element absent";
    break;
  case TREXIO_INVALID_NUM:
    return "Invalid (negative or 0) dimension";
    break;
  case TREXIO_ATTR_ALREADY_EXISTS:
    return "Attribute already exists";
    break;
  case TREXIO_DSET_ALREADY_EXISTS:
    return "Dataset already exists";
    break;
  case TREXIO_OPEN_ERROR:
    return "Error opening file";
    break;
  case TREXIO_LOCK_ERROR:
    return "Error locking file";
    break;
  case TREXIO_UNLOCK_ERROR:
    return "Error unlocking file";
    break;
  case TREXIO_FILE_ERROR:
    return "Invalid file";
    break;
  case TREXIO_GROUP_READ_ERROR:
    return "Error reading group";
    break;
  case TREXIO_GROUP_WRITE_ERROR:
    return "Error writing group";
    break;
  case TREXIO_ELEM_READ_ERROR:
    return "Error reading element";
    break;
  case TREXIO_ELEM_WRITE_ERROR:
    return "Error writing element";
    break;
  case TREXIO_UNSAFE_ARRAY_DIM:
    return "Access to memory beyond allocated";
    break;
  case TREXIO_ATTR_MISSING:
    return "Attribute does not exist in the file";
    break;
  case TREXIO_DSET_MISSING:
    return "Dataset does not exist in the file";
    break;
  case TREXIO_BACK_END_MISSING:
    return "Requested back end is disabled";
    break;
  case TREXIO_INVALID_ARG_6:
    return "Invalid argument 6";
    break;
  case TREXIO_INVALID_ARG_7:
    return "Invalid argument 7";
    break;
  case TREXIO_INVALID_ARG_8:
    return "Invalid argument 8";
    break;
  case TREXIO_INVALID_STR_LEN:
    return "Invalid max_str_len";
    break;
  case TREXIO_INT_SIZE_OVERFLOW:
    return "Possible integer overflow";
    break;
  case TREXIO_SAFE_MODE:
    return "Unsafe operation in safe mode";
    break;
  case TREXIO_INVALID_ELECTRON_NUM:
    return "Inconsistent number of electrons";
    break;
  case TREXIO_INVALID_DETERMINANT_NUM:
    return "Inconsistent number of determinants";
    break;
  case TREXIO_INVALID_STATE:
    return "Inconsistent state of the file";
    break;
  case TREXIO_VERSION_PARSING_ISSUE:
    return "Failed to parse package_version";
    break;
  case TREXIO_PHASE_CHANGE:
    return "The function succeeded with a change of sign";
    break;
  case TREXIO_INVALID_MO_INDEX:
    return "Invalid MO index";
    break;
  case TREXIO_INVALID_ARG_9:
    return "Invalid argument 9";
    break;
  case TREXIO_INVALID_ARG_10:
    return "Invalid argument 10";
    break;
  case TREXIO_INVALID_ARG_11:
    return "Invalid argument 11";
    break;
  case TREXIO_INVALID_ARG_12:
    return "Invalid argument 12";
    break;
  case TREXIO_INVALID_ARG_13:
    return "Invalid argument 13";
    break;
  case TREXIO_INVALID_ARG_14:
    return "Invalid argument 14";
    break;
  case TREXIO_CORRUPTION_ATTEMPT:
    return "File offset is wrong, corruption risk";
    break;
  }
  return "Unknown error";
}

void
trexio_string_of_error_f (const trexio_exit_code error, const int32_t str_size, char* const result)
{
  const char* pSrc = trexio_string_of_error(error);
  int32_t sizeCp = (int32_t) strlen(pSrc);
  if (sizeCp > str_size) {
     sizeCp = str_size;
  }
  memcpy(result, pSrc, sizeCp);
  for (int32_t i=sizeCp ; i<str_size ; ++i) {
    result[i] = ' ';
  }
}

bool trexio_has_back_end(back_end_t back_end) {
  switch (back_end) {
    case TREXIO_TEXT:
      return true;
    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      return true;
#else
      return false;
#endif
  }
  return false;
}

bool trexio_has_backend(back_end_t back_end) {
  return trexio_has_back_end(back_end);
}

trexio_t*
trexio_open(const char* file_name, const char mode,
            const back_end_t back_end, trexio_exit_code* const rc_open)
{

  if (file_name == NULL || file_name[0] == '\0') {
    if (rc_open != NULL) *rc_open = TREXIO_INVALID_ARG_1;
    return NULL;
  }
  /* Check overflow in file_name */

  /* Check that the mode is valid */
  if (mode != 'r' && mode != 'w' && mode != 'u') {
    if (rc_open != NULL) *rc_open = TREXIO_INVALID_ARG_2;
    return NULL;
  }

  /* Check that the back end is valid in non-read mode */
  if ((back_end <  0 || back_end >= TREXIO_INVALID_BACK_END) && mode != 'r') {
    if (rc_open != NULL) *rc_open = TREXIO_INVALID_ARG_3;
    return NULL;
  }

  /* Check that the back end is valid in read-only mode */
  if ((back_end <  0 || back_end > TREXIO_INVALID_BACK_END) && mode == 'r') {
    if (rc_open != NULL) *rc_open = TREXIO_INVALID_ARG_3;
    return NULL;
  }

  back_end_t back_end_local = back_end;
  /* Try to determine the applicable backend if the back_end argument is TREXIO_AUTO */
  if (back_end == TREXIO_AUTO && mode == 'r') {
#ifdef HAVE_HDF5
    /* Check if the TREXIO file exists and if it is a directory */
    trexio_exit_code rc_text = trexio_text_inquire(file_name);
    if (rc_text == TREXIO_SUCCESS) {
      back_end_local = TREXIO_TEXT;
    } else {
    /* If not, check if it is an HDF5 file */
      trexio_exit_code rc_hdf5 = trexio_hdf5_inquire(file_name);
      if (rc_hdf5 == TREXIO_SUCCESS) {
        back_end_local = TREXIO_HDF5;
      } else {
    /* File is neither a directory nor an HDF5 file -> return an error */
        if (rc_open != NULL) *rc_open = TREXIO_FILE_ERROR;
        return NULL;
      }
    }
#else
    /* In the current implementation if HDF5 back end is not available - then there is only back end left */
    back_end_local = TREXIO_TEXT;
#endif
  }

  trexio_t* result = NULL;
  void* result_tmp = NULL;

  /* Allocate data structures */
  switch (back_end_local) {

  case TREXIO_TEXT:
    result_tmp = malloc(sizeof(trexio_text_t));
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    result_tmp = malloc(sizeof(trexio_hdf5_t));
    break;
#else
    if (rc_open != NULL) *rc_open = TREXIO_BACK_END_MISSING;
    return NULL;
#endif

  default:
    if (rc_open != NULL) *rc_open = TREXIO_FILE_ERROR;
    return NULL;

/*
  case TREXIO_JSON:
    result = (trexio_t*) malloc (sizeof(trexio_json_t));
    break;
*/
  }
  result = (trexio_t*) result_tmp;

  assert (result != NULL);    /* TODO: Error handling */

  /* Data for the parent type */

  // See https://stackoverflow.com/a/50198398/4151327
  size_t lenSrc = strlen(file_name);
  if (lenSrc < TREXIO_MAX_FILENAME_LENGTH) {
    memcpy(result->file_name, file_name, lenSrc+1);
  } else {
    if (rc_open != NULL) *rc_open = TREXIO_INVALID_ARG_1;
    free(result);
    return NULL;
  }

  result->back_end    = back_end_local;
  result->mode        = mode;
  result->one_based   = false;  // Need to be flipped in Fortran interface
  result->state       = 0;      // By default the file corresponds to a ground state
  int irc = pthread_mutex_init ( &(result->thread_lock), NULL);
  if (irc != 0) {
    if (rc_open != NULL) *rc_open = TREXIO_FAILURE;
    free(result);
    return NULL;
  }
  // assert (irc == 0);

  /* Back end initialization */

  trexio_exit_code rc = TREXIO_OPEN_ERROR;

  switch (back_end_local) {

  case TREXIO_TEXT:
    rc = trexio_text_init(result);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_init(result);
    break;
#else
    if (rc_open != NULL) *rc_open = TREXIO_BACK_END_MISSING;
    free(result);
    return NULL;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_init(result);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) {
    if (rc_open != NULL) *rc_open = TREXIO_OPEN_ERROR;
    free(result);
    return NULL;
  }


  /* File locking */

  rc = TREXIO_LOCK_ERROR;

  switch (back_end_local) {

  case TREXIO_TEXT:
    rc = trexio_text_lock(result);
    break;
  /* HDF5 v.>=1.10 has file locking activated by default */
  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = TREXIO_SUCCESS;
    break;
#else
    if (rc_open != NULL) *rc_open = TREXIO_BACK_END_MISSING;
    free(result);
    return NULL;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_lock(result);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) {
    if (rc_open != NULL) *rc_open = TREXIO_LOCK_ERROR;
    free(result);
    return NULL;
  }

  /* Write metadata (i.e. package version) upon creation */
  rc = trexio_has_metadata_package_version(result);
  if (rc == TREXIO_FAILURE) {
    if (rc_open != NULL) *rc_open = TREXIO_OPEN_ERROR;
    free(result);
    return NULL;
  }

  if (rc == TREXIO_HAS_NOT) {
  /* Write TREXIO_PACKAGE_VERSION upon creation of the file */
    switch (back_end_local) {

    case TREXIO_TEXT:
      rc = trexio_text_write_metadata_package_version(result, TREXIO_PACKAGE_VERSION);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_metadata_package_version(result, TREXIO_PACKAGE_VERSION);
      break;
#else
      if (rc_open != NULL) *rc_open = TREXIO_BACK_END_MISSING;
      free(result);
      return NULL;
#endif

    }

    if (rc != TREXIO_SUCCESS) {
      if (rc_open != NULL) *rc_open = rc;
      free(result);
      return NULL;
    }

    result->version_major = TREXIO_VERSION_MAJOR;
    result->version_minor = TREXIO_VERSION_MINOR;
    result->version_patch = TREXIO_VERSION_PATCH;
    strncpy(result->version, TREXIO_PACKAGE_VERSION, 16);

  } else {
  /* Otherwise read the metadata_package_version to get the TREXIO version upon creation of the file */
    char version_origin[16];

    switch (back_end_local) {

    case TREXIO_TEXT:
      rc = trexio_text_read_metadata_package_version(result, version_origin, 16);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_read_metadata_package_version(result, version_origin, 16);
      break;
#else
      if (rc_open != NULL) *rc_open = TREXIO_BACK_END_MISSING;
      free(result);
      return NULL;
#endif

    }

    if (rc != TREXIO_SUCCESS) {
      if (rc_open != NULL) *rc_open = rc;
      free(result);
      return NULL;
    }

    int16_t version_major, version_minor, version_patch;
    int rc_scan = sscanf(version_origin,
                         "%3" SCNd16 ".%5" SCNd16 ".%5" SCNd16,
                         &version_major, &version_minor, &version_patch);
    if (rc_scan != 3) {
      if (rc_open != NULL) *rc_open = TREXIO_VERSION_PARSING_ISSUE;
      free(result);
      return NULL;
    }

    result->version_major = version_major;
    result->version_minor = version_minor;
    result->version_patch = version_patch;
    strncpy(result->version, version_origin, 16);

  }

  if (result->version[15] != '\0' || result->version_major == 0) {
    if (rc_open != NULL) *rc_open = TREXIO_FAILURE;
    free(result);
    return NULL;
  }

  /* Mark the file as unsafe upon opening in UNSAFE 'u' mode */
  if (mode == 'u') {

    rc = trexio_has_metadata_unsafe(result);
    if (rc == TREXIO_FAILURE) {
      if (rc_open != NULL) *rc_open = TREXIO_OPEN_ERROR;
      free(result);
      return NULL;
    }

    if (rc == TREXIO_HAS_NOT) {
      int64_t unsafe_val = 1;
      switch (back_end) {

      case TREXIO_TEXT:
        rc = trexio_text_write_metadata_unsafe(result, unsafe_val);
        break;

      case TREXIO_HDF5:
#ifdef HAVE_HDF5
        rc = trexio_hdf5_write_metadata_unsafe(result, unsafe_val);
        break;
#else
        if (rc_open != NULL) *rc_open = TREXIO_BACK_END_MISSING;
        free(result);
        return NULL;
#endif
      }
    }

    if (rc != TREXIO_SUCCESS) {
      if (rc_open != NULL) *rc_open = rc;
      free(result);
      return NULL;
    }

  }


  /* Exit upon success */
  if (rc_open != NULL) *rc_open = TREXIO_SUCCESS;

  return result;
}

trexio_exit_code trexio_set_one_based(trexio_t* file)
{
  if (file == NULL) return TREXIO_FILE_ERROR;

  file->one_based = true;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_close (trexio_t* file)
{

  if (file == NULL) return TREXIO_FILE_ERROR;

  trexio_exit_code rc = TREXIO_FAILURE;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  /* Things to be done before closing the file in the back-end */
  rc = trexio_pre_close(file);
  if (rc != TREXIO_SUCCESS) return rc;

  /* Terminate the back end */
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_deinit(file);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_deinit(file);
    break;
#else
    FREE(file);
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_deinit(file);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) {
    FREE(file);
    return rc;
  }

  /* File unlocking */

  rc = TREXIO_UNLOCK_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_unlock(file);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = TREXIO_SUCCESS;
    break;
#else
    FREE(file);
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_unlock(file);
    break;
*/
  }

  /* Terminate front end */

  int irc = pthread_mutex_destroy( &(file->thread_lock) );

  free(file);

  if (irc != 0) return TREXIO_ERRNO;
  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_flush (trexio_t* file)
{

  if (file == NULL) return TREXIO_FILE_ERROR;

  trexio_exit_code rc = TREXIO_FAILURE;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  /* Terminate the back end */
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_flush(file);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_flush(file);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_flush(file);
    break;
*/
  }

  return rc;
}

trexio_exit_code
trexio_inquire (const char* file_name)
{

  if (file_name == NULL || file_name[0] == '\0') return TREXIO_INVALID_ARG_1;

  /* First check if the TREXIO file exists and if it is a directory */
  trexio_exit_code rc_text = trexio_text_inquire(file_name);

#ifdef HAVE_HDF5
  /* FILE_ERROR here means that the file exists but it is not a directory -> check with HDF5 */
  if (rc_text == TREXIO_FILE_ERROR) {
    trexio_exit_code rc_hdf5 = trexio_hdf5_inquire(file_name);
    return rc_hdf5;
  /* If rc_text is TREXIO_SUCCESS -> file is a TREXIO directory; TREXIO_FAILURE -> file/directory does not exist */
  } else {
    return rc_text;
  }
#else
  return rc_text;
#endif
}

trexio_exit_code
trexio_cp(const char* source, const char* dest)
{

  if (source == NULL || source[0] == '\0') {
    return TREXIO_INVALID_ARG_1;
  }

  if (dest == NULL || dest[0] == '\0') {
    return TREXIO_INVALID_ARG_2;
  }


  back_end_t back_end_local = TREXIO_AUTO;
  /* Try to determine the applicable backend if the back_end argument is TREXIO_AUTO */
  /* Check if the TREXIO file exists and if it is a directory */
  trexio_exit_code rc_text = trexio_text_inquire(source);
  if (rc_text == TREXIO_SUCCESS) {
    back_end_local = TREXIO_TEXT;
  }
#ifdef HAVE_HDF5
  else {
    /* If not, check if it is an HDF5 file */
    trexio_exit_code rc_hdf5 = trexio_hdf5_inquire(source);
    if (rc_hdf5 == TREXIO_SUCCESS) {
      back_end_local = TREXIO_HDF5;
    } else {
      /* File is neither a directory nor an HDF5 file -> return an error */
      return TREXIO_FILE_ERROR;
    }
  }
#else
  else {
    return TREXIO_FILE_ERROR;
  }
#endif
  assert (back_end_local != TREXIO_AUTO);

  if (trexio_inquire(dest) == TREXIO_SUCCESS) {
    /* Destination file already exists */
    return TREXIO_FILE_ERROR;
  }

  /* Call cp */

#ifndef CP_COMMAND
#define CP_COMMAND "cp", "-r"
#endif


  pid_t pid = fork();
  if (pid == 0) {
    execlp("cp", CP_COMMAND, source, dest, (char *)0);
  } else if (pid < 0) {
    return TREXIO_FILE_ERROR;
  } else {
    int wstatus;
    pid_t ws = waitpid( pid, &wstatus, 0);
    if (ws != pid || !WIFEXITED(wstatus) )
      return TREXIO_FILE_ERROR;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_set_state (trexio_t* file, const int32_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;

  /* Write state_id in the file (as of v.2.3.0) */
  trexio_exit_code rc = trexio_has_state_id(file);
  if (rc == TREXIO_HAS_NOT || file->mode == 'u') {
    trexio_exit_code rc_w = trexio_write_state_id(file, num);
    if (rc_w != TREXIO_SUCCESS) return rc_w;
  }

  file->state = num;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_get_state (trexio_t* file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;

  /* Read state_id from the file (as of v.2.3.0) */
  int32_t state_id = 0;
  trexio_exit_code rc = trexio_has_state_id(file);
  if (rc == TREXIO_SUCCESS) {
    trexio_exit_code rc_r = trexio_read_state_id(file, &state_id);
    if (rc_r != TREXIO_SUCCESS) return rc_r;
  }

  /* If the state is not in a file then state_id=0, i.e. ground state */
  *num = state_id;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_pre_close (trexio_t* file)
{

  if (file == NULL) return TREXIO_FILE_ERROR;

  /* Check consistency between number of determinants and coefficients stored in the file */

  if (file->version_major >= 2 && file->version_minor >= 2) {

    bool has_det   = (trexio_has_determinant_list(file) == TREXIO_SUCCESS);
    bool has_coeff = (trexio_has_determinant_coefficient(file) == TREXIO_SUCCESS);
    int64_t ndet, ncoeff;

    if (has_det && has_coeff) {
      trexio_exit_code rc = TREXIO_FAILURE;

      rc = trexio_read_determinant_num_64(file, &ndet);
      if (rc != TREXIO_SUCCESS) return rc;

      rc = trexio_read_determinant_coefficient_size(file, &ncoeff);
      if (rc != TREXIO_SUCCESS) return rc;

      /* Maybe be even more direct and use assert here so that the user's code crashes in case of inconsistency */
      if (ndet != ncoeff) return TREXIO_INVALID_DETERMINANT_NUM;
    }

  }
  /* Up-spin and down-spin electrons */

  int32_t nup, ndn, nelec;
  bool has_up   = (trexio_has_electron_up_num(file) == TREXIO_SUCCESS);
  bool has_dn   = (trexio_has_electron_dn_num(file) == TREXIO_SUCCESS);
  bool has_updn = (trexio_has_electron_num(file) == TREXIO_SUCCESS);

  if (file->mode != 'r') {

    if (has_updn && has_up && has_dn) {

      trexio_exit_code rc = TREXIO_FAILURE;

      rc = trexio_read_electron_up_num(file, &nup);
      if (rc != TREXIO_SUCCESS) return rc;

      rc = trexio_read_electron_dn_num(file, &ndn);
      if (rc != TREXIO_SUCCESS) return rc;

      rc = trexio_read_electron_num(file, &nelec);
      if (rc != TREXIO_SUCCESS) return rc;

      if (nelec != nup + ndn) {
        if (file->mode == 'u') {
          nelec = nup + ndn;
          rc = trexio_write_electron_num(file, nelec);
          if (rc != TREXIO_SUCCESS) return rc;
        } else {
          return TREXIO_INVALID_ELECTRON_NUM;
        }
      }

    } else if (has_up && has_dn) {

      trexio_exit_code rc = TREXIO_FAILURE;

      rc = trexio_read_electron_up_num(file, &nup);
      if (rc != TREXIO_SUCCESS) return rc;

      rc = trexio_read_electron_dn_num(file, &ndn);
      if (rc != TREXIO_SUCCESS) return rc;

      nelec = nup + ndn;
      rc = trexio_write_electron_num(file, nelec);
      if (rc != TREXIO_SUCCESS) return rc;

    } else if (has_up) {

      trexio_exit_code rc = TREXIO_FAILURE;

      rc = trexio_read_electron_up_num(file, &nup);
      if (rc != TREXIO_SUCCESS) return rc;

      ndn = 0;
      rc = trexio_write_electron_dn_num(file, ndn);
      if (rc != TREXIO_SUCCESS) return rc;

      nelec = nup;
      rc = trexio_write_electron_num(file, nelec);
      if (rc != TREXIO_SUCCESS) return rc;

    } else if (has_dn) {

      trexio_exit_code rc = TREXIO_FAILURE;

      rc = trexio_read_electron_dn_num(file, &ndn);
      if (rc != TREXIO_SUCCESS) return rc;

      nup = 0;
      rc = trexio_write_electron_up_num(file, nup);
      if (rc != TREXIO_SUCCESS) return rc;

      nelec = ndn;
      rc = trexio_write_electron_num(file, nelec);
      if (rc != TREXIO_SUCCESS) return rc;

    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code trexio_to_bitfield_list (const int32_t* orb_list,
                                          const int32_t occupied_num,
                                          bitfield_t* const bit_list,
                                          const int32_t N_int)
{
  if (orb_list == NULL)  return TREXIO_INVALID_ARG_1;
  if (occupied_num <= 0) return TREXIO_INVALID_ARG_2;
  if (bit_list == NULL)  return TREXIO_INVALID_ARG_3;
  if (N_int <= 0)        return TREXIO_INVALID_ARG_4;

  for (int32_t j = 0 ; j < N_int ; j++) {
      bit_list[j] = (bitfield_t) 0;
  }

  uint32_t nswaps = 0;

  for (int32_t pos = 0 ; pos < occupied_num ; pos++) {
    const uint32_t iorb = ((uint32_t) (orb_list[pos] + 1)) - TREXIO_ORBITAL_SHIFT;

    // Set the bit of to one
    const uint32_t i = (uint32_t) (iorb >> TREXIO_NORB_PER_INT_SHIFT);
    const uint32_t k = (uint32_t) (iorb & (TREXIO_NORB_PER_INT - 1) );
    bitfield_t mask = ((bitfield_t) 1) << k;
    bit_list[i] |= mask;

    // Check for phase changes
    mask = ~(mask - (bitfield_t) 1);
    nswaps += popcnt(mask & bit_list[i]) - 1;
    for (int j=i+1 ; j < N_int ; ++j) {
      if (bit_list[j] != (bitfield_t) 0)
        nswaps += popcnt(bit_list[j]);
    }
  }

  if ( (nswaps & 1) == 0)
    return TREXIO_SUCCESS;
  else
    return TREXIO_PHASE_CHANGE;
}

trexio_exit_code trexio_to_orbital_list(const int32_t N_int,
                                        const bitfield_t* d1,
                                        int32_t* const list,
                                        int32_t* const occupied_num)
{
  if (N_int <= 0) return TREXIO_INVALID_ARG_1;
  if (d1 == NULL) return TREXIO_INVALID_ARG_2;
  if (list == NULL) return TREXIO_INVALID_ARG_3;
  if (occupied_num == NULL) return TREXIO_INVALID_ARG_4;

  int32_t k = 0;
  int32_t shift = TREXIO_ORBITAL_SHIFT;

  for (int32_t i=0 ; i<N_int ; i++)
  {
      bitfield_t tmp = d1[i];

      while (tmp != (bitfield_t) 0)
      {
          const int32_t pos = trailz(tmp);
          if (pos < 0) return TREXIO_FAILURE;

          list[k] = ( (int32_t) pos) + shift - 1;
          tmp ^= ( ((bitfield_t) 1) << pos);
          k++;
      }
      shift += TREXIO_NORB_PER_INT;
  }

  *occupied_num = (int32_t) k;
  return TREXIO_SUCCESS;
}

trexio_exit_code trexio_to_orbital_list_up_dn(const int32_t N_int,
                                              const bitfield_t* d1,
                                              int32_t* const list_up,
                                              int32_t* const list_dn,
                                              int32_t* const occ_num_up,
                                              int32_t* const occ_num_dn)
{
  if (N_int <= 0) return TREXIO_INVALID_ARG_1;
  if (d1 == NULL) return TREXIO_INVALID_ARG_2;
  if (list_up == NULL) return TREXIO_INVALID_ARG_3;
  if (list_dn == NULL) return TREXIO_INVALID_ARG_4;
  if (occ_num_up == NULL) return TREXIO_INVALID_ARG_5;
  if (occ_num_dn == NULL) return TREXIO_INVALID_ARG_6;

  /* First process up-spin electrons */
  trexio_exit_code rc = trexio_to_orbital_list(N_int, &d1[0], list_up, occ_num_up);
  if (rc != TREXIO_SUCCESS) return rc;

  /* Now process down-spin electrons */
  rc = trexio_to_orbital_list(N_int, &d1[N_int], list_dn, occ_num_dn);
  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_safe_to_orbital_list (const int32_t N_int,
			     const bitfield_t* dset_in,
                             const int64_t dim_in,
			     int32_t* const dset_out,
                             const int64_t dim_out,
			     int32_t* const num)
{
  if (dim_in < N_int) return TREXIO_INVALID_ARG_3;

  /* Count number of up electrons in first bitfield */
  int count = 0;
  for (int i=0 ; i<N_int; i++) {
    count += popcnt(dset_in[i]);
  }
  if (dim_out < count) return TREXIO_INVALID_ARG_5;
  return trexio_to_orbital_list(N_int, dset_in, dset_out, num);
}

trexio_exit_code
trexio_safe_to_orbital_list_up_dn (const int32_t N_int,
			           const bitfield_t* dset_in,
                                   const int64_t dim_in,
			           int32_t* const dset_up_out,
                                   const int64_t dim_up_out,
			           int32_t* const dset_dn_out,
                                   const int64_t dim_dn_out,
			           int32_t* const num_up,
			           int32_t* const num_dn)
{
  if (dim_in < 2*N_int) return TREXIO_INVALID_ARG_3;

  /* Count number of up electrons in first bitfield */
  int count = 0;
  for (int i=0 ; i<N_int; i++) {
    count += popcnt(dset_in[i]);
  }
  if (dim_up_out < count) return TREXIO_INVALID_ARG_5;

  /* Count number of up electrons in second bitfield */
  count = 0;
  for (int i=N_int ; i<2*N_int; i++) {
    count += popcnt(dset_in[i]);
  }
  if (dim_dn_out < count) return TREXIO_INVALID_ARG_7;
  return trexio_to_orbital_list_up_dn(N_int, dset_in, dset_up_out, dset_dn_out, num_up, num_dn);
}

trexio_exit_code
trexio_convert_nao_radius_32 (const float r, const float* const grid_r, float* const log_r_out)
{
  if (r <= 0.) return TREXIO_INVALID_ARG_1;
  if (grid_r == NULL) return TREXIO_INVALID_ARG_2;
  if (log_r_out == NULL) return TREXIO_INVALID_ARG_3;

  *log_r_out = (float) log((double) r / grid_r[0]) / log((double) grid_r[1] / grid_r[0]);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_convert_nao_radius_64 (const double r, const double* const grid_r, double* const log_r_out)
{
  if (r <= 0.) return TREXIO_INVALID_ARG_1;
  if (grid_r == NULL) return TREXIO_INVALID_ARG_2;
  if (log_r_out == NULL) return TREXIO_INVALID_ARG_3;

  *log_r_out = log(r / grid_r[0]) / log(grid_r[1] / grid_r[0]);

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_convert_nao_radius_py (const double r, double* grid_r, int32_t n_grid, double* const log_r_out)
{
  if (r <= 0.) return TREXIO_INVALID_ARG_1;
  if (grid_r == NULL) return TREXIO_INVALID_ARG_2;
  if (n_grid < 2) return TREXIO_INVALID_ARG_3;
  if (log_r_out == NULL) return TREXIO_INVALID_ARG_4;

  *log_r_out = log(r / grid_r[0]) / log(grid_r[1] / grid_r[0]);

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_evaluate_nao_radial (const int32_t shell_index, const double r, const int32_t* const grid_start,
                            const int32_t* const grid_size, const double* const grid_r, const double* const interpolator, const double* const normalization, double* const amplitude)
{
  if (shell_index < 0) return TREXIO_INVALID_ARG_1;
  if (r < 0) return TREXIO_INVALID_ARG_2;
  if (grid_start == 0) return TREXIO_INVALID_ARG_3;
  if (grid_size == 0) return TREXIO_INVALID_ARG_4;
  if (grid_r == NULL) return TREXIO_INVALID_ARG_5;
  if (interpolator == 0) return TREXIO_INVALID_ARG_6;
  if (normalization == 0) return TREXIO_INVALID_ARG_7;

  const int64_t i0 = 4*grid_start[shell_index];

  // Convert radius to logarithmic units
  double r_log = 0.0;
  trexio_convert_nao_radius_64 (r, grid_r + grid_start[shell_index], &r_log);
  int64_t i_log = (int64_t) r_log;
  if (i_log < 0)
    i_log = 0;
  else if (i_log >= grid_size[shell_index])
    return 0; // NAOs vanish at the boundary by definition

  double t = r_log - (double) i_log;
  double val_spline = interpolator[i0 + 4*i_log + 0];
  val_spline += t * interpolator[i0 + 4*i_log + 1];
  val_spline += t * t * interpolator[i0 + 4*i_log + 2];
  val_spline += t * t * t * interpolator[i0 + 4*i_log + 3];

  *amplitude = val_spline * normalization[shell_index] / r;
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_evaluate_nao_radial_all (const int32_t shell_num, const int32_t* const nucleus_index, const double* const nucleus_coords, const int32_t* const grid_start,
                            const int32_t* const grid_size, const double* const grid_r, const double* const interpolator,
                            const double* const normalization,  const double rx, const double ry, const double rz, double* const amplitude)
{
  if (shell_num < 0) return TREXIO_INVALID_ARG_1;
  if (nucleus_index == 0) return TREXIO_INVALID_ARG_2;
  if (nucleus_coords == 0) return TREXIO_INVALID_ARG_3;
  if (grid_start == 0) return TREXIO_INVALID_ARG_4;
  if (grid_size == 0) return TREXIO_INVALID_ARG_5;
  if (grid_r == NULL) return TREXIO_INVALID_ARG_6;
  if (interpolator == 0) return TREXIO_INVALID_ARG_7;
  if (normalization == 0) return TREXIO_INVALID_ARG_8;

  for (int shell_index = 0; shell_index < shell_num; shell_index++) {
    const int32_t nuc_index = nucleus_index[shell_index];
    const double dx = nucleus_coords[3*nuc_index + 0] - rx;
    const double dy = nucleus_coords[3*nuc_index + 1] - ry;
    const double dz = nucleus_coords[3*nuc_index + 2] - rz;
    const double r = sqrt(dx*dx + dy*dy + dz*dz);

    // All possibly reported errors have been caught above
    trexio_exit_code rc = trexio_evaluate_nao_radial(shell_index, r, grid_start,
      grid_size, grid_r, interpolator, normalization, &amplitude[shell_index]);

    if (rc != TREXIO_SUCCESS)
      return rc;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code trexio_evaluate_nao_radial_py (const int shell_index,
  const double r, int64_t* grid_start, int n_grid_st,
  int64_t* grid_size, int n_grid_si, double* grid_r, int n_grid_r,
  double* interpolator, int n_interp, double* normalization, int n_norm,
  double* const amplitude)
{
  // Code needs to be copied because of the use of int64_t mandated by Python
  // If a 64-bit version is implemented, this can be avoided
  if (shell_index < 0) return TREXIO_INVALID_ARG_1;
  if (r < 0) return TREXIO_INVALID_ARG_2;
  if (grid_start == 0) return TREXIO_INVALID_ARG_3;
  if (n_grid_st < shell_index) return TREXIO_INVALID_ARG_4;
  if (grid_size == 0) return TREXIO_INVALID_ARG_5;
  if (n_grid_si < shell_index) return TREXIO_INVALID_ARG_6;
  if (grid_r == NULL) return TREXIO_INVALID_ARG_7;
  if (n_grid_r < grid_start[shell_index]) return TREXIO_INVALID_ARG_8;
  if (interpolator == NULL) return TREXIO_INVALID_ARG_9;
  if (normalization == 0) return TREXIO_INVALID_ARG_11;
  if (n_norm < shell_index) return TREXIO_INVALID_ARG_12;

  const int64_t i0 = 4*grid_start[shell_index];
  if (n_interp < i0) return TREXIO_INVALID_ARG_10;

  // Convert radius to logarithmic units
  double r_log = 0.0;
  trexio_convert_nao_radius_64 (r, grid_r + grid_start[shell_index], &r_log);
  int64_t i_log = (int64_t) r_log;
  if (i_log < 0) {
    *amplitude = interpolator[i0] * normalization[shell_index] / r;
    return TREXIO_SUCCESS;
  } else if (i_log >= grid_size[shell_index]) {
    *amplitude = 0.0;
    return TREXIO_SUCCESS; // NAOs vanish at the boundary by definition
  }

  double t = r_log - (double) i_log;
  if (n_interp < i0+4*i_log+3) return TREXIO_INVALID_ARG_10;

  double val_spline = interpolator[i0 + 4*i_log + 0];
  val_spline += t * interpolator[i0 + 4*i_log + 1];
  val_spline += t * t * interpolator[i0 + 4*i_log + 2];
  val_spline += t * t * t * interpolator[i0 + 4*i_log + 3];

  *amplitude = val_spline * normalization[shell_index] / r;
  return TREXIO_SUCCESS;
}

trexio_exit_code trexio_evaluate_nao_radial_all_py (const int32_t shell_num,
  int64_t* nucleus_index, int n_nuc_id, double* nucleus_coords, int n_nuc_co,
  int64_t* grid_start, int n_grid_st, int64_t* grid_size, int n_grid_si,
  double* grid_r, int n_grid_r, double* interpolator, int n_interp,
  double* normalization, int n_norm,
  const double rx, const double ry, const double rz,
  double* const amplitudes, int amplitude_cnt)
{
  if (shell_num < 0) return TREXIO_INVALID_ARG_1;
  if (nucleus_index == NULL) return TREXIO_INVALID_ARG_2;
  if (nucleus_coords == NULL) return TREXIO_INVALID_ARG_4;
  if (grid_start == NULL) return TREXIO_INVALID_ARG_6;
  if (grid_size == NULL) return TREXIO_INVALID_ARG_8;
  if (grid_r == NULL) return TREXIO_INVALID_ARG_10;
  if (interpolator == NULL) return TREXIO_INVALID_ARG_12;
  if (normalization == NULL) return TREXIO_INVALID_ARG_14;

  assert (amplitudes != NULL); // 19 arguments!!! Don't want to make TREXIO_INVALID_ARG_19
  assert (amplitude_cnt > shell_num);

  if (n_nuc_id < shell_num) return TREXIO_INVALID_ARG_3;
  if (n_nuc_co <  3*nucleus_index[shell_num-1]+2) return TREXIO_INVALID_ARG_5;

  for (int shell_index = 0; shell_index < shell_num; shell_index++) {
    const int64_t nuc_index = nucleus_index[shell_index];

    const double dx = nucleus_coords[3*nuc_index + 0] - rx;
    const double dy = nucleus_coords[3*nuc_index + 1] - ry;
    const double dz = nucleus_coords[3*nuc_index + 2] - rz;
    const double r = sqrt(dx*dx + dy*dy + dz*dz);

    // All possibly reported errors have been caught above
    trexio_exit_code rc =
      trexio_evaluate_nao_radial_py(shell_index, r, grid_start, n_grid_st, grid_size,
                                    n_grid_si, grid_r, n_grid_r, interpolator, n_interp,
                                    normalization, n_norm, &amplitudes[shell_index]);

    if (rc != TREXIO_SUCCESS)
      return rc;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_info (void)
{
  printf("TREXIO_PACKAGE_VERSION : %s\n", TREXIO_PACKAGE_VERSION);

#ifdef TREXIO_GIT_HASH
  printf("TREXIO_GIT_HASH        : %s\n", TREXIO_GIT_HASH);
#else
  printf("GIT_HASH is stored in the config.h file, which is missing.");
#endif

#ifdef HAVE_HDF5
  printf("HAVE_HDF5              : true\n");
  printf("%s\n", H5_VERS_INFO);
#else
  printf("HAVE_HDF5              : false\n");
  printf("TREXIO configured without the HDF5 library\n");
#endif

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_mark_safety (trexio_t* const file, const int32_t safety_flag)
{

 if (file == NULL) return TREXIO_INVALID_ARG_1;
 /* 1 for true ; 0 for false */
 if (safety_flag != 0 && safety_flag != 1) return TREXIO_INVALID_ARG_2;
 /* Cannot mark the file in safe mode */
 if (file->mode != 'u') return TREXIO_FAILURE;

 return trexio_write_metadata_unsafe(file, safety_flag);
}
trexio_exit_code
trexio_delete_metadata (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_metadata(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_metadata(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_metadata(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_nucleus (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_nucleus(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_nucleus(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_nucleus(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_cell (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_cell(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_cell(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_cell(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_pbc (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_pbc(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_pbc(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_pbc(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_electron (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_electron(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_electron(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_electron(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_state (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_state(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_state(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_state(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_basis (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_basis(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_basis(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_basis(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_ecp (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_ecp(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_ecp(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_ecp(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_grid (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_grid(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_grid(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_grid(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_ao (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_ao(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_ao(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_ao(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_ao_1e_int (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_ao_1e_int(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_ao_1e_int(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_ao_1e_int(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_ao_2e_int (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_ao_2e_int(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_ao_2e_int(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_ao_2e_int(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_mo (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_mo(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_mo(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_mo(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_mo_1e_int (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_mo_1e_int(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_mo_1e_int(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_mo_1e_int(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_mo_2e_int (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_mo_2e_int(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_mo_2e_int(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_mo_2e_int(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_determinant (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_determinant(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_determinant(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_determinant(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_csf (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_csf(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_csf(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_csf(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_amplitude (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_amplitude(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_amplitude(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_amplitude(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_rdm (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_rdm(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_rdm(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_rdm(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_jastrow (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_jastrow(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_jastrow(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_jastrow(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_delete_qmc (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (file->mode != 'u') return TREXIO_SAFE_MODE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_delete_qmc(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_delete_qmc(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_delete_qmc(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_metadata_code_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_metadata_code_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_metadata_code_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_metadata_code_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_metadata_author_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_metadata_author_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_metadata_author_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_metadata_author_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_metadata_unsafe (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_metadata_unsafe(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_metadata_unsafe(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_metadata_unsafe(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_nucleus_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_nucleus_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_nucleus_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_nucleus_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_nucleus_repulsion (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_nucleus_repulsion(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_nucleus_repulsion(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_nucleus_repulsion(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_cell_two_pi (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_cell_two_pi(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_cell_two_pi(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_cell_two_pi(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_pbc_periodic (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_pbc_periodic(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_pbc_periodic(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_pbc_periodic(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_pbc_k_point_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_pbc_k_point_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_pbc_k_point_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_pbc_k_point_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_pbc_madelung (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_pbc_madelung(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_pbc_madelung(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_pbc_madelung(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_electron_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_electron_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_electron_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_electron_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_electron_up_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_electron_up_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_electron_up_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_electron_up_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_electron_dn_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_electron_dn_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_electron_dn_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_electron_dn_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_state_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_state_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_state_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_state_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_state_id (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_state_id(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_state_id(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_state_id(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_state_energy (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_state_energy(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_state_energy(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_state_energy(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_prim_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_prim_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_prim_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_prim_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_shell_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_shell_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_shell_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_shell_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_nao_grid_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_nao_grid_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_nao_grid_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_nao_grid_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_interp_coeff_cnt (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_interp_coeff_cnt(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_interp_coeff_cnt(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_interp_coeff_cnt(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_e_cut (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_e_cut(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_e_cut(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_e_cut(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ecp_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ecp_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ecp_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ecp_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_rad_precision (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_rad_precision(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_rad_precision(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_rad_precision(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_max_ang_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_max_ang_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_max_ang_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_max_ang_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_min_ang_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_min_ang_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_min_ang_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_min_ang_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_ang_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_ang_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_ang_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_ang_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_rad_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_rad_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_rad_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_rad_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_cartesian (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_cartesian(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_cartesian(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_cartesian(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_2e_int_eri_cholesky_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_2e_int_eri_cholesky_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_2e_int_eri_cholesky_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_2e_int_eri_cholesky_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_2e_int_eri_lr_cholesky_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_2e_int_eri_lr_cholesky_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_2e_int_eri_lr_cholesky_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_2e_int_eri_lr_cholesky_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_2e_int_eri_cholesky_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_2e_int_eri_cholesky_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_2e_int_eri_cholesky_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_2e_int_eri_cholesky_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_2e_int_eri_lr_cholesky_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_2e_int_eri_lr_cholesky_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_2e_int_eri_lr_cholesky_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_2e_int_eri_lr_cholesky_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_determinant_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_determinant_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_determinant_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_determinant_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_csf_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_csf_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_csf_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_csf_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_cholesky_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_cholesky_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_cholesky_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_cholesky_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_upup_cholesky_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_upup_cholesky_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_upup_cholesky_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_upup_cholesky_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_dndn_cholesky_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_dndn_cholesky_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_dndn_cholesky_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_dndn_cholesky_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_updn_cholesky_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_updn_cholesky_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_updn_cholesky_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_updn_cholesky_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_en_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_en_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_en_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_en_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_ee_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_ee_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_ee_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_ee_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_een_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_een_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_een_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_een_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_ee_scaling (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_ee_scaling(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_ee_scaling(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_ee_scaling(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_qmc_num (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_qmc_num(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_qmc_num(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_qmc_num(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_metadata_package_version (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_metadata_package_version(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_metadata_package_version(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_metadata_package_version(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_metadata_description (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_metadata_description(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_metadata_description(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_metadata_description(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_nucleus_point_group (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_nucleus_point_group(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_nucleus_point_group(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_nucleus_point_group(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_state_current_label (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_state_current_label(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_state_current_label(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_state_current_label(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_type (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_type(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_type(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_type(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_oscillation_kind (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_oscillation_kind(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_oscillation_kind(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_oscillation_kind(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_interpolator_kind (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_interpolator_kind(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_interpolator_kind(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_interpolator_kind(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_description (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_description(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_description(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_description(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_type (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_type(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_type(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_type(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_type (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_type(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_type(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_type(file);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_determinant_coefficient (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_determinant_coefficient(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_determinant_coefficient(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_csf_coefficient (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_csf_coefficient(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_csf_coefficient(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_nucleus_charge (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_nucleus_charge(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_nucleus_charge(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_nucleus_charge(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_nucleus_coord (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_nucleus_coord(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_nucleus_coord(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_nucleus_coord(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_cell_a (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_cell_a(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_cell_a(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_cell_a(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_cell_b (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_cell_b(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_cell_b(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_cell_b(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_cell_c (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_cell_c(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_cell_c(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_cell_c(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_cell_g_a (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_cell_g_a(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_cell_g_a(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_cell_g_a(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_cell_g_b (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_cell_g_b(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_cell_g_b(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_cell_g_b(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_cell_g_c (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_cell_g_c(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_cell_g_c(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_cell_g_c(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_pbc_k_point (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_pbc_k_point(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_pbc_k_point(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_pbc_k_point(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_pbc_k_point_weight (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_pbc_k_point_weight(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_pbc_k_point_weight(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_pbc_k_point_weight(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_nucleus_index (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_nucleus_index(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_nucleus_index(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_nucleus_index(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_shell_ang_mom (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_shell_ang_mom(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_shell_ang_mom(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_shell_ang_mom(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_shell_factor (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_shell_factor(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_shell_factor(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_shell_factor(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_r_power (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_r_power(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_r_power(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_r_power(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_nao_grid_start (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_nao_grid_start(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_nao_grid_start(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_nao_grid_start(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_nao_grid_size (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_nao_grid_size(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_nao_grid_size(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_nao_grid_size(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_shell_index (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_shell_index(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_shell_index(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_shell_index(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_exponent (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_exponent(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_exponent(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_exponent(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_exponent_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_exponent_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_exponent_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_exponent_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_coefficient (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_coefficient(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_coefficient(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_coefficient(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_coefficient_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_coefficient_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_coefficient_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_coefficient_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_oscillation_arg (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_oscillation_arg(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_oscillation_arg(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_oscillation_arg(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_prim_factor (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_prim_factor(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_prim_factor(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_prim_factor(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_nao_grid_radius (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_nao_grid_radius(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_nao_grid_radius(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_nao_grid_radius(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_nao_grid_phi (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_nao_grid_phi(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_nao_grid_phi(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_nao_grid_phi(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_nao_grid_grad (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_nao_grid_grad(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_nao_grid_grad(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_nao_grid_grad(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_nao_grid_lap (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_nao_grid_lap(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_nao_grid_lap(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_nao_grid_lap(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_interpolator_phi (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_interpolator_phi(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_interpolator_phi(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_interpolator_phi(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_interpolator_grad (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_interpolator_grad(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_interpolator_grad(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_interpolator_grad(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis_interpolator_lap (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis_interpolator_lap(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis_interpolator_lap(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis_interpolator_lap(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ecp_max_ang_mom_plus_1 (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ecp_max_ang_mom_plus_1(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ecp_max_ang_mom_plus_1(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ecp_max_ang_mom_plus_1(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ecp_z_core (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ecp_z_core(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ecp_z_core(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ecp_z_core(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ecp_ang_mom (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ecp_ang_mom(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ecp_ang_mom(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ecp_ang_mom(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ecp_nucleus_index (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ecp_nucleus_index(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ecp_nucleus_index(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ecp_nucleus_index(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ecp_exponent (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ecp_exponent(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ecp_exponent(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ecp_exponent(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ecp_coefficient (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ecp_coefficient(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ecp_coefficient(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ecp_coefficient(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ecp_power (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ecp_power(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ecp_power(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ecp_power(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_coord (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_coord(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_coord(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_coord(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_weight (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_weight(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_weight(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_weight(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_ang_coord (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_ang_coord(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_ang_coord(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_ang_coord(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_ang_weight (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_ang_weight(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_ang_weight(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_ang_weight(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_rad_coord (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_rad_coord(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_rad_coord(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_rad_coord(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid_rad_weight (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid_rad_weight(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid_rad_weight(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid_rad_weight(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_shell (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_shell(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_shell(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_shell(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_normalization (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_normalization(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_normalization(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_normalization(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_overlap (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_overlap(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_overlap(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_overlap(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_kinetic (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_kinetic(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_kinetic(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_kinetic(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_potential_n_e (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_potential_n_e(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_potential_n_e(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_potential_n_e(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_ecp (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_ecp(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_ecp(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_ecp(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_core_hamiltonian (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_core_hamiltonian(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_core_hamiltonian(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_core_hamiltonian(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_overlap_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_overlap_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_overlap_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_overlap_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_kinetic_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_kinetic_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_kinetic_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_kinetic_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_potential_n_e_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_potential_n_e_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_potential_n_e_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_potential_n_e_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_ecp_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_ecp_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_ecp_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_ecp_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int_core_hamiltonian_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int_core_hamiltonian_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int_core_hamiltonian_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int_core_hamiltonian_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_coefficient (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_coefficient(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_coefficient(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_coefficient(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_coefficient_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_coefficient_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_coefficient_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_coefficient_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_occupation (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_occupation(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_occupation(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_occupation(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_energy (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_energy(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_energy(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_energy(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_spin (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_spin(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_spin(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_spin(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_k_point (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_k_point(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_k_point(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_k_point(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_overlap (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_overlap(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_overlap(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_overlap(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_kinetic (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_kinetic(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_kinetic(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_kinetic(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_potential_n_e (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_potential_n_e(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_potential_n_e(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_potential_n_e(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_ecp (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_ecp(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_ecp(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_ecp(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_core_hamiltonian (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_core_hamiltonian(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_core_hamiltonian(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_core_hamiltonian(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_overlap_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_overlap_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_overlap_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_overlap_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_kinetic_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_kinetic_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_kinetic_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_kinetic_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_potential_n_e_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_potential_n_e_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_potential_n_e_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_potential_n_e_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_ecp_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_ecp_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_ecp_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_ecp_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int_core_hamiltonian_im (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int_core_hamiltonian_im(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int_core_hamiltonian_im(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int_core_hamiltonian_im(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_1e (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_1e(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_1e(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_1e(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_1e_up (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_1e_up(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_1e_up(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_1e_up(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_1e_dn (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_1e_dn(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_1e_dn(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_1e_dn(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_1e_transition (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_1e_transition(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_1e_transition(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_1e_transition(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_en (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_en(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_en(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_en(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_ee (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_ee(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_ee(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_ee(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_een (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_een(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_een(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_een(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_en_nucleus (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_en_nucleus(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_en_nucleus(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_en_nucleus(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_een_nucleus (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_een_nucleus(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_een_nucleus(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_een_nucleus(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow_en_scaling (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow_en_scaling(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow_en_scaling(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow_en_scaling(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_qmc_point (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_qmc_point(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_qmc_point(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_qmc_point(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_qmc_psi (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_qmc_psi(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_qmc_psi(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_qmc_psi(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_qmc_e_loc (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_qmc_e_loc(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_qmc_e_loc(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_qmc_e_loc(file);
*/
  }
  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_2e_int_eri (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_2e_int_eri(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_2e_int_eri(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_2e_int_eri(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_2e_int_eri_lr (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_2e_int_eri_lr(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_2e_int_eri_lr(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_2e_int_eri_lr(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_2e_int_eri_cholesky (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_2e_int_eri_cholesky(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_2e_int_eri_cholesky(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_2e_int_eri_cholesky(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_2e_int_eri_lr_cholesky (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_2e_int_eri_lr_cholesky(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_2e_int_eri_lr_cholesky(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_2e_int_eri_lr_cholesky(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_2e_int_eri (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_2e_int_eri(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_2e_int_eri(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_2e_int_eri(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_2e_int_eri_lr (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_2e_int_eri_lr(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_2e_int_eri_lr(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_2e_int_eri_lr(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_2e_int_eri_cholesky (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_2e_int_eri_cholesky(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_2e_int_eri_cholesky(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_2e_int_eri_cholesky(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_2e_int_eri_lr_cholesky (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_2e_int_eri_lr_cholesky(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_2e_int_eri_lr_cholesky(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_2e_int_eri_lr_cholesky(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_csf_det_coefficient (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_csf_det_coefficient(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_csf_det_coefficient(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_csf_det_coefficient(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_amplitude_single (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_amplitude_single(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_amplitude_single(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_amplitude_single(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_amplitude_single_exp (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_amplitude_single_exp(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_amplitude_single_exp(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_amplitude_single_exp(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_amplitude_double (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_amplitude_double(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_amplitude_double(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_amplitude_double(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_amplitude_double_exp (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_amplitude_double_exp(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_amplitude_double_exp(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_amplitude_double_exp(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_amplitude_triple (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_amplitude_triple(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_amplitude_triple(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_amplitude_triple(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_amplitude_triple_exp (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_amplitude_triple_exp(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_amplitude_triple_exp(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_amplitude_triple_exp(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_amplitude_quadruple (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_amplitude_quadruple(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_amplitude_quadruple(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_amplitude_quadruple(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_amplitude_quadruple_exp (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_amplitude_quadruple_exp(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_amplitude_quadruple_exp(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_amplitude_quadruple_exp(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_upup (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_upup(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_upup(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_upup(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_dndn (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_dndn(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_dndn(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_dndn(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_updn (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_updn(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_updn(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_updn(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_transition (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_transition(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_transition(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_transition(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_cholesky (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_cholesky(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_cholesky(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_cholesky(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_upup_cholesky (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_upup_cholesky(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_upup_cholesky(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_upup_cholesky(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_dndn_cholesky (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_dndn_cholesky(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_dndn_cholesky(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_dndn_cholesky(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm_2e_updn_cholesky (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm_2e_updn_cholesky(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm_2e_updn_cholesky(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm_2e_updn_cholesky(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_metadata_code (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_metadata_code(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_metadata_code(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_metadata_code(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_metadata_author (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_metadata_author(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_metadata_author(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_metadata_author(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_nucleus_label (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_nucleus_label(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_nucleus_label(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_nucleus_label(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_state_label (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_state_label(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_state_label(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_state_label(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_state_file_name (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_state_file_name(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_state_file_name(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_state_file_name(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_class (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_class(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_class(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_class(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_symmetry (trexio_t* const file)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_symmetry(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_symmetry(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_symmetry(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_metadata (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_metadata(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_metadata(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_metadata(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_nucleus (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_nucleus(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_nucleus(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_nucleus(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_cell (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_cell(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_cell(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_cell(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_pbc (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_pbc(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_pbc(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_pbc(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_electron (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_electron(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_electron(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_electron(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_state (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_state(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_state(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_state(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_basis (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_basis(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_basis(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_basis(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ecp (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ecp(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ecp(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ecp(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_grid (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_grid(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_grid(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_grid(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_1e_int (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_1e_int(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_1e_int(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_1e_int(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_ao_2e_int (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_ao_2e_int(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_ao_2e_int(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_ao_2e_int(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_1e_int (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_1e_int(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_1e_int(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_1e_int(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_mo_2e_int (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_mo_2e_int(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_mo_2e_int(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_mo_2e_int(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_determinant (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_determinant(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_determinant(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_determinant(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_csf (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_csf(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_csf(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_csf(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_amplitude (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_amplitude(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_amplitude(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_amplitude(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_rdm (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_rdm(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_rdm(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_rdm(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_jastrow (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_jastrow(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_jastrow(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_jastrow(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_has_qmc (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_qmc(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_qmc(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_qmc(file);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_metadata_code_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_metadata_code_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_metadata_code_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_metadata_code_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_metadata_code_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_metadata_author_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_metadata_author_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_metadata_author_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_metadata_author_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_metadata_author_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_metadata_unsafe_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_metadata_unsafe(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_metadata_unsafe(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_metadata_unsafe(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_metadata_unsafe(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_nucleus_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_nucleus_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_nucleus_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_nucleus_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_nucleus_repulsion_32 (trexio_t* const file, float* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_repulsion(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  double num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_nucleus_repulsion(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_nucleus_repulsion(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_nucleus_repulsion(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (float) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (float) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_two_pi_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_two_pi(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_two_pi(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_two_pi(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_cell_two_pi(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_pbc_periodic_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_periodic(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_periodic(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_periodic(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_pbc_periodic(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_pbc_k_point_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_k_point_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_k_point_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_pbc_k_point_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_pbc_madelung_32 (trexio_t* const file, float* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_madelung(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  double num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_madelung(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_madelung(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_pbc_madelung(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (float) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (float) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_electron_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_electron_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_electron_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_electron_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_electron_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_electron_up_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_electron_up_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_electron_up_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_electron_up_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_electron_up_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_electron_dn_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_electron_dn_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_electron_dn_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_electron_dn_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_electron_dn_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_state_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_state_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_state_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_state_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_state_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_state_id_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_state_id(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_state_id(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_state_id(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_state_id(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if (file->one_based) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_state_energy_32 (trexio_t* const file, float* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_state_energy(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  double num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_state_energy(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_state_energy(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_state_energy(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (float) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (float) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_prim_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_prim_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_prim_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_basis_prim_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_shell_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_shell_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_shell_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_basis_shell_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_basis_nao_grid_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_interp_coeff_cnt_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interp_coeff_cnt(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_interp_coeff_cnt(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_interp_coeff_cnt(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_basis_interp_coeff_cnt(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_e_cut_32 (trexio_t* const file, float* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_e_cut(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  double num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_e_cut(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_e_cut(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_basis_e_cut(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (float) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (float) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_ecp_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_rad_precision_32 (trexio_t* const file, float* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_precision(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  double num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_rad_precision(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_rad_precision(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_grid_rad_precision(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (float) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (float) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_grid_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_max_ang_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_max_ang_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_max_ang_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_max_ang_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_grid_max_ang_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_min_ang_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_min_ang_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_min_ang_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_min_ang_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_grid_min_ang_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_ang_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_ang_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_ang_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_grid_ang_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_rad_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_rad_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_rad_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_grid_rad_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_cartesian_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_cartesian(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_cartesian(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_cartesian(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_ao_cartesian(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_ao_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_2e_int_eri_cholesky_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_2e_int_eri_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_2e_int_eri_cholesky_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_2e_int_eri_cholesky_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_ao_2e_int_eri_cholesky_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_2e_int_eri_lr_cholesky_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_2e_int_eri_lr_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_2e_int_eri_lr_cholesky_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_2e_int_eri_lr_cholesky_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_ao_2e_int_eri_lr_cholesky_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_mo_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_2e_int_eri_cholesky_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_2e_int_eri_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_2e_int_eri_cholesky_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_2e_int_eri_cholesky_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_mo_2e_int_eri_cholesky_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_2e_int_eri_lr_cholesky_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_2e_int_eri_lr_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_2e_int_eri_lr_cholesky_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_2e_int_eri_lr_cholesky_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_mo_2e_int_eri_lr_cholesky_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_determinant_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_determinant_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_determinant_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_determinant_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_determinant_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_csf_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_csf_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_csf_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_csf_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_csf_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_2e_cholesky_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_cholesky_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_cholesky_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_rdm_2e_cholesky_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_2e_upup_cholesky_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_upup_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_upup_cholesky_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_upup_cholesky_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_rdm_2e_upup_cholesky_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_2e_dndn_cholesky_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_dndn_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_dndn_cholesky_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_dndn_cholesky_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_rdm_2e_dndn_cholesky_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_2e_updn_cholesky_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_updn_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_updn_cholesky_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_updn_cholesky_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_rdm_2e_updn_cholesky_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_en_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_en_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_en_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_jastrow_en_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_ee_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_ee_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_ee_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_jastrow_ee_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_een_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_een_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_een_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_jastrow_een_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_ee_scaling_32 (trexio_t* const file, float* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee_scaling(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  double num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_ee_scaling(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_ee_scaling(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_jastrow_ee_scaling(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (float) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (float) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_qmc_num_32 (trexio_t* const file, int32_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  int64_t num_64 = 0;
  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_qmc_num(file, &num_64);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_qmc_num(file, &num_64);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break ;
#endif
/*
  case TREXIO_JSON:
    rc =trexio_json_read_qmc_num(file, &num_64);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  *num = (int32_t) num_64;

  /* Handle index type */
  if ((false)) {
    *num += (int32_t) 1;
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_metadata_code_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_metadata_code_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_metadata_code_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_metadata_code_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_metadata_code_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_metadata_author_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_metadata_author_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_metadata_author_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_metadata_author_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_metadata_author_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_metadata_unsafe_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_metadata_unsafe(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_metadata_unsafe(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_metadata_unsafe(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_metadata_unsafe(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_nucleus_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_nucleus_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_nucleus_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_nucleus_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_nucleus_repulsion_64 (trexio_t* const file, double* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_repulsion(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_nucleus_repulsion(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_nucleus_repulsion(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_nucleus_repulsion(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (double) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_cell_two_pi_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_two_pi(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_two_pi(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_two_pi(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_two_pi(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_pbc_periodic_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_periodic(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_periodic(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_periodic(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_pbc_periodic(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_pbc_k_point_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_k_point_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_k_point_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_pbc_k_point_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_pbc_madelung_64 (trexio_t* const file, double* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_madelung(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_madelung(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_madelung(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_pbc_madelung(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (double) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_electron_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_electron_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_electron_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_electron_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_electron_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_electron_up_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_electron_up_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_electron_up_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_electron_up_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_electron_up_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_electron_dn_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_electron_dn_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_electron_dn_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_electron_dn_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_electron_dn_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_state_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_state_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_state_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_state_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_state_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_state_id_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_state_id(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_state_id(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_state_id(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_state_id(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if (file->one_based) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_state_energy_64 (trexio_t* const file, double* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_state_energy(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_state_energy(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_state_energy(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_state_energy(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (double) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_basis_prim_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_prim_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_prim_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_prim_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_basis_shell_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_shell_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_shell_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_shell_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_basis_nao_grid_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_basis_interp_coeff_cnt_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interp_coeff_cnt(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_interp_coeff_cnt(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_interp_coeff_cnt(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_interp_coeff_cnt(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_basis_e_cut_64 (trexio_t* const file, double* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_e_cut(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_e_cut(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_e_cut(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_e_cut(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (double) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_ecp_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_grid_rad_precision_64 (trexio_t* const file, double* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_precision(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_rad_precision(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_rad_precision(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_rad_precision(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (double) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_grid_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_grid_max_ang_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_max_ang_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_max_ang_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_max_ang_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_max_ang_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_grid_min_ang_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_min_ang_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_min_ang_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_min_ang_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_min_ang_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_grid_ang_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_ang_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_ang_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_ang_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_grid_rad_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_rad_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_rad_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_rad_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_ao_cartesian_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_cartesian(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_cartesian(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_cartesian(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_cartesian(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_ao_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_ao_2e_int_eri_cholesky_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_2e_int_eri_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_2e_int_eri_cholesky_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_2e_int_eri_cholesky_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_2e_int_eri_cholesky_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_ao_2e_int_eri_lr_cholesky_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_2e_int_eri_lr_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_2e_int_eri_lr_cholesky_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_2e_int_eri_lr_cholesky_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_2e_int_eri_lr_cholesky_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_mo_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_mo_2e_int_eri_cholesky_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_2e_int_eri_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_2e_int_eri_cholesky_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_2e_int_eri_cholesky_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_2e_int_eri_cholesky_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_mo_2e_int_eri_lr_cholesky_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_2e_int_eri_lr_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_2e_int_eri_lr_cholesky_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_2e_int_eri_lr_cholesky_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_2e_int_eri_lr_cholesky_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_determinant_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_determinant_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_determinant_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_determinant_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_determinant_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_csf_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_csf_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_csf_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_csf_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_csf_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_rdm_2e_cholesky_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_cholesky_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_cholesky_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_2e_cholesky_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_rdm_2e_upup_cholesky_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_upup_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_upup_cholesky_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_upup_cholesky_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_2e_upup_cholesky_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_rdm_2e_dndn_cholesky_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_dndn_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_dndn_cholesky_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_dndn_cholesky_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_2e_dndn_cholesky_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_rdm_2e_updn_cholesky_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_updn_cholesky_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_updn_cholesky_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_updn_cholesky_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_2e_updn_cholesky_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_jastrow_en_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_en_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_en_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_en_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_jastrow_ee_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_ee_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_ee_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_ee_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_jastrow_een_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_een_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_een_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_een_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_jastrow_ee_scaling_64 (trexio_t* const file, double* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee_scaling(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_ee_scaling(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_ee_scaling(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_ee_scaling(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (double) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_qmc_num_64 (trexio_t* const file, int64_t* const num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_num(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  trexio_exit_code rc = TREXIO_GROUP_READ_ERROR;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_qmc_num(file, num);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_qmc_num(file, num);
#else
    rc = TREXIO_BACK_END_MISSING;
#endif
    break;
/*
  case TREXIO_JSON:
    rc = trexio_json_read_qmc_num(file, num);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    *num += (int64_t) 1;
  }
  return rc;
}

trexio_exit_code
trexio_read_metadata_code_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_metadata_code_num_32(file, num);
}

trexio_exit_code
trexio_read_metadata_author_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_metadata_author_num_32(file, num);
}

trexio_exit_code
trexio_read_metadata_unsafe (trexio_t* const file, int32_t* const num)
{
  return trexio_read_metadata_unsafe_32(file, num);
}

trexio_exit_code
trexio_read_nucleus_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_nucleus_num_32(file, num);
}

trexio_exit_code
trexio_read_nucleus_repulsion (trexio_t* const file, double* const num)
{
  return trexio_read_nucleus_repulsion_64(file, num);
}

trexio_exit_code
trexio_read_cell_two_pi (trexio_t* const file, int32_t* const num)
{
  return trexio_read_cell_two_pi_32(file, num);
}

trexio_exit_code
trexio_read_pbc_periodic (trexio_t* const file, int32_t* const num)
{
  return trexio_read_pbc_periodic_32(file, num);
}

trexio_exit_code
trexio_read_pbc_k_point_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_pbc_k_point_num_32(file, num);
}

trexio_exit_code
trexio_read_pbc_madelung (trexio_t* const file, double* const num)
{
  return trexio_read_pbc_madelung_64(file, num);
}

trexio_exit_code
trexio_read_electron_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_electron_num_32(file, num);
}

trexio_exit_code
trexio_read_electron_up_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_electron_up_num_32(file, num);
}

trexio_exit_code
trexio_read_electron_dn_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_electron_dn_num_32(file, num);
}

trexio_exit_code
trexio_read_state_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_state_num_32(file, num);
}

trexio_exit_code
trexio_read_state_id (trexio_t* const file, int32_t* const num)
{
  return trexio_read_state_id_32(file, num);
}

trexio_exit_code
trexio_read_state_energy (trexio_t* const file, double* const num)
{
  return trexio_read_state_energy_64(file, num);
}

trexio_exit_code
trexio_read_basis_prim_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_basis_prim_num_32(file, num);
}

trexio_exit_code
trexio_read_basis_shell_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_basis_shell_num_32(file, num);
}

trexio_exit_code
trexio_read_basis_nao_grid_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_basis_nao_grid_num_32(file, num);
}

trexio_exit_code
trexio_read_basis_interp_coeff_cnt (trexio_t* const file, int32_t* const num)
{
  return trexio_read_basis_interp_coeff_cnt_32(file, num);
}

trexio_exit_code
trexio_read_basis_e_cut (trexio_t* const file, double* const num)
{
  return trexio_read_basis_e_cut_64(file, num);
}

trexio_exit_code
trexio_read_ecp_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_ecp_num_32(file, num);
}

trexio_exit_code
trexio_read_grid_rad_precision (trexio_t* const file, double* const num)
{
  return trexio_read_grid_rad_precision_64(file, num);
}

trexio_exit_code
trexio_read_grid_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_grid_num_32(file, num);
}

trexio_exit_code
trexio_read_grid_max_ang_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_grid_max_ang_num_32(file, num);
}

trexio_exit_code
trexio_read_grid_min_ang_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_grid_min_ang_num_32(file, num);
}

trexio_exit_code
trexio_read_grid_ang_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_grid_ang_num_32(file, num);
}

trexio_exit_code
trexio_read_grid_rad_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_grid_rad_num_32(file, num);
}

trexio_exit_code
trexio_read_ao_cartesian (trexio_t* const file, int32_t* const num)
{
  return trexio_read_ao_cartesian_32(file, num);
}

trexio_exit_code
trexio_read_ao_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_ao_num_32(file, num);
}

trexio_exit_code
trexio_read_ao_2e_int_eri_cholesky_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_ao_2e_int_eri_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_read_ao_2e_int_eri_lr_cholesky_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_ao_2e_int_eri_lr_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_read_mo_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_mo_num_32(file, num);
}

trexio_exit_code
trexio_read_mo_2e_int_eri_cholesky_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_mo_2e_int_eri_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_read_mo_2e_int_eri_lr_cholesky_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_mo_2e_int_eri_lr_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_read_determinant_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_determinant_num_32(file, num);
}

trexio_exit_code
trexio_read_csf_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_csf_num_32(file, num);
}

trexio_exit_code
trexio_read_rdm_2e_cholesky_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_rdm_2e_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_read_rdm_2e_upup_cholesky_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_rdm_2e_upup_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_read_rdm_2e_dndn_cholesky_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_rdm_2e_dndn_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_read_rdm_2e_updn_cholesky_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_rdm_2e_updn_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_read_jastrow_en_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_jastrow_en_num_32(file, num);
}

trexio_exit_code
trexio_read_jastrow_ee_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_jastrow_ee_num_32(file, num);
}

trexio_exit_code
trexio_read_jastrow_een_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_jastrow_een_num_32(file, num);
}

trexio_exit_code
trexio_read_jastrow_ee_scaling (trexio_t* const file, double* const num)
{
  return trexio_read_jastrow_ee_scaling_64(file, num);
}

trexio_exit_code
trexio_read_qmc_num (trexio_t* const file, int32_t* const num)
{
  return trexio_read_qmc_num_32(file, num);
}

trexio_exit_code
trexio_read_metadata_package_version (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_package_version(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_metadata_package_version(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_metadata_package_version(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_metadata_package_version(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_metadata_description (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_description(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_metadata_description(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_metadata_description(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_metadata_description(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_nucleus_point_group (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_nucleus_point_group(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_nucleus_point_group(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_nucleus_point_group(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_nucleus_point_group(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_state_current_label (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_current_label(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_state_current_label(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_state_current_label(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_state_current_label(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_basis_type (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_basis_type(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_basis_type(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_basis_type(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_basis_type(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_basis_oscillation_kind (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_basis_oscillation_kind(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_basis_oscillation_kind(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_basis_oscillation_kind(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_basis_oscillation_kind(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_basis_interpolator_kind (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_basis_interpolator_kind(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_basis_interpolator_kind(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_basis_interpolator_kind(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_basis_interpolator_kind(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_grid_description (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_grid_description(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_grid_description(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_grid_description(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_grid_description(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_mo_type (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_type(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_mo_type(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_mo_type(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_mo_type(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_jastrow_type (trexio_t* const file, char* const str_out, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str_out  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_jastrow_type(file) != TREXIO_SUCCESS) return TREXIO_ATTR_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_jastrow_type(file, str_out, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_jastrow_type(file, str_out, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_jastrow_type(file, str);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_determinant_coefficient (trexio_t* const file, const int64_t offset_file, int64_t* const buffer_size_read, double* const dset)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_determinant_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  trexio_exit_code rc = TREXIO_FAILURE;

  uint32_t rank = 1;
  uint64_t det_size = (uint64_t) (*buffer_size_read);
  uint64_t dims[1] = {det_size};

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_determinant_coefficient(file, offset_file, rank, dims, &eof_read_size, dset);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_determinant_coefficient(file, offset_file, rank, dims, &eof_read_size, dset);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_determinant_coefficient(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;
    break;  /* Impossible case */
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size_read = eof_read_size;

  return rc;
}

trexio_exit_code
trexio_read_determinant_coefficient_size(trexio_t* const file, int64_t* const size_max)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_determinant_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_determinant_coefficient_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_determinant_coefficient_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_safe_determinant_coefficient (trexio_t* const file, const int64_t offset_file, int64_t* const buffer_size_read, double* const dset_out, const int64_t dim_out)
{
  if (dim_out < (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  return trexio_read_determinant_coefficient(file, offset_file, buffer_size_read, dset_out);
}

trexio_exit_code
trexio_read_csf_coefficient (trexio_t* const file, const int64_t offset_file, int64_t* const buffer_size_read, double* const dset)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset  == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_csf_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  trexio_exit_code rc = TREXIO_FAILURE;

  uint32_t rank = 1;
  uint64_t det_size = (uint64_t) (*buffer_size_read);
  uint64_t dims[1] = {det_size};

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_csf_coefficient(file, offset_file, rank, dims, &eof_read_size, dset);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_csf_coefficient(file, offset_file, rank, dims, &eof_read_size, dset);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_csf_coefficient(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;
    break;  /* Impossible case */
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size_read = eof_read_size;

  return rc;
}

trexio_exit_code
trexio_read_csf_coefficient_size(trexio_t* const file, int64_t* const size_max)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_csf_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_csf_coefficient_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_csf_coefficient_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_safe_csf_coefficient (trexio_t* const file, const int64_t offset_file, int64_t* const buffer_size_read, double* const dset_out, const int64_t dim_out)
{
  if (dim_out < (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  return trexio_read_csf_coefficient(file, offset_file, buffer_size_read, dset_out);
}

trexio_exit_code
trexio_read_nucleus_charge_32 (trexio_t* const file, float* const nucleus_charge)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (nucleus_charge == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_charge(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* nucleus_charge_64 = CALLOC(dim_size, double);
  if (nucleus_charge_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_nucleus_charge(file, nucleus_charge_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_nucleus_charge(file, nucleus_charge_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_nucleus_charge(file, nucleus_charge_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(nucleus_charge_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      nucleus_charge[i] = (float) nucleus_charge_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      nucleus_charge[i] = (float) nucleus_charge_64[i];
    }
  }

  FREE(nucleus_charge_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_nucleus_coord_32 (trexio_t* const file, float* const nucleus_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (nucleus_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {nucleus_num, 3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* nucleus_coord_64 = CALLOC(dim_size, double);
  if (nucleus_coord_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_nucleus_coord(file, nucleus_coord_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_nucleus_coord(file, nucleus_coord_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_nucleus_coord(file, nucleus_coord_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(nucleus_coord_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      nucleus_coord[i] = (float) nucleus_coord_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      nucleus_coord[i] = (float) nucleus_coord_64[i];
    }
  }

  FREE(nucleus_coord_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_a_32 (trexio_t* const file, float* const cell_a)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_a == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_a(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_a_64 = CALLOC(dim_size, double);
  if (cell_a_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_a(file, cell_a_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_a(file, cell_a_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_a(file, cell_a_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(cell_a_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_a[i] = (float) cell_a_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_a[i] = (float) cell_a_64[i];
    }
  }

  FREE(cell_a_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_b_32 (trexio_t* const file, float* const cell_b)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_b == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_b(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_b_64 = CALLOC(dim_size, double);
  if (cell_b_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_b(file, cell_b_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_b(file, cell_b_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_b(file, cell_b_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(cell_b_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_b[i] = (float) cell_b_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_b[i] = (float) cell_b_64[i];
    }
  }

  FREE(cell_b_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_c_32 (trexio_t* const file, float* const cell_c)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_c == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_c(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_c_64 = CALLOC(dim_size, double);
  if (cell_c_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_c(file, cell_c_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_c(file, cell_c_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_c(file, cell_c_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(cell_c_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_c[i] = (float) cell_c_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_c[i] = (float) cell_c_64[i];
    }
  }

  FREE(cell_c_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_g_a_32 (trexio_t* const file, float* const cell_g_a)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_g_a == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_a(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_g_a_64 = CALLOC(dim_size, double);
  if (cell_g_a_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_g_a(file, cell_g_a_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_g_a(file, cell_g_a_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_g_a(file, cell_g_a_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(cell_g_a_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_a[i] = (float) cell_g_a_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_a[i] = (float) cell_g_a_64[i];
    }
  }

  FREE(cell_g_a_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_g_b_32 (trexio_t* const file, float* const cell_g_b)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_g_b == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_b(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_g_b_64 = CALLOC(dim_size, double);
  if (cell_g_b_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_g_b(file, cell_g_b_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_g_b(file, cell_g_b_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_g_b(file, cell_g_b_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(cell_g_b_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_b[i] = (float) cell_g_b_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_b[i] = (float) cell_g_b_64[i];
    }
  }

  FREE(cell_g_b_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_g_c_32 (trexio_t* const file, float* const cell_g_c)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_g_c == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_c(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_g_c_64 = CALLOC(dim_size, double);
  if (cell_g_c_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_g_c(file, cell_g_c_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_g_c(file, cell_g_c_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_g_c(file, cell_g_c_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(cell_g_c_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_c[i] = (float) cell_g_c_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_c[i] = (float) cell_g_c_64[i];
    }
  }

  FREE(cell_g_c_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_pbc_k_point_32 (trexio_t* const file, float* const pbc_k_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (pbc_k_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* pbc_k_point_64 = CALLOC(dim_size, double);
  if (pbc_k_point_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_k_point(file, pbc_k_point_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_k_point(file, pbc_k_point_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_pbc_k_point(file, pbc_k_point_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(pbc_k_point_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      pbc_k_point[i] = (float) pbc_k_point_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      pbc_k_point[i] = (float) pbc_k_point_64[i];
    }
  }

  FREE(pbc_k_point_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_pbc_k_point_weight_32 (trexio_t* const file, float* const pbc_k_point_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (pbc_k_point_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t pbc_k_point_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_pbc_k_point_num_64(file, &(pbc_k_point_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (pbc_k_point_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {pbc_k_point_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* pbc_k_point_weight_64 = CALLOC(dim_size, double);
  if (pbc_k_point_weight_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_k_point_weight(file, pbc_k_point_weight_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_k_point_weight(file, pbc_k_point_weight_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_pbc_k_point_weight(file, pbc_k_point_weight_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(pbc_k_point_weight_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      pbc_k_point_weight[i] = (float) pbc_k_point_weight_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      pbc_k_point_weight[i] = (float) pbc_k_point_weight_64[i];
    }
  }

  FREE(pbc_k_point_weight_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nucleus_index_32 (trexio_t* const file, int32_t* const basis_nucleus_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nucleus_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nucleus_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_nucleus_index_64 = CALLOC(dim_size, int64_t);
  if (basis_nucleus_index_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nucleus_index(file, basis_nucleus_index_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nucleus_index(file, basis_nucleus_index_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nucleus_index(file, basis_nucleus_index_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_nucleus_index_64);
    return rc;
  }

  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nucleus_index[i] = (int32_t) basis_nucleus_index_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nucleus_index[i] = (int32_t) basis_nucleus_index_64[i];
    }
  }

  FREE(basis_nucleus_index_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_shell_ang_mom_32 (trexio_t* const file, int32_t* const basis_shell_ang_mom)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_shell_ang_mom == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_ang_mom(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_shell_ang_mom_64 = CALLOC(dim_size, int64_t);
  if (basis_shell_ang_mom_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_shell_ang_mom(file, basis_shell_ang_mom_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_shell_ang_mom(file, basis_shell_ang_mom_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_shell_ang_mom(file, basis_shell_ang_mom_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_shell_ang_mom_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_ang_mom[i] = (int32_t) basis_shell_ang_mom_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_ang_mom[i] = (int32_t) basis_shell_ang_mom_64[i];
    }
  }

  FREE(basis_shell_ang_mom_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_shell_factor_32 (trexio_t* const file, float* const basis_shell_factor)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_shell_factor == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_factor(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_shell_factor_64 = CALLOC(dim_size, double);
  if (basis_shell_factor_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_shell_factor(file, basis_shell_factor_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_shell_factor(file, basis_shell_factor_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_shell_factor(file, basis_shell_factor_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_shell_factor_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_factor[i] = (float) basis_shell_factor_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_factor[i] = (float) basis_shell_factor_64[i];
    }
  }

  FREE(basis_shell_factor_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_r_power_32 (trexio_t* const file, int32_t* const basis_r_power)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_r_power == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_r_power(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_r_power_64 = CALLOC(dim_size, int64_t);
  if (basis_r_power_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_r_power(file, basis_r_power_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_r_power(file, basis_r_power_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_r_power(file, basis_r_power_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_r_power_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_r_power[i] = (int32_t) basis_r_power_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_r_power[i] = (int32_t) basis_r_power_64[i];
    }
  }

  FREE(basis_r_power_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_start_32 (trexio_t* const file, int32_t* const basis_nao_grid_start)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_start == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_start(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_nao_grid_start_64 = CALLOC(dim_size, int64_t);
  if (basis_nao_grid_start_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_start(file, basis_nao_grid_start_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_start(file, basis_nao_grid_start_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_start(file, basis_nao_grid_start_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_nao_grid_start_64);
    return rc;
  }

  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_start[i] = (int32_t) basis_nao_grid_start_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_start[i] = (int32_t) basis_nao_grid_start_64[i];
    }
  }

  FREE(basis_nao_grid_start_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_size_32 (trexio_t* const file, int32_t* const basis_nao_grid_size)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_size == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_size(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_nao_grid_size_64 = CALLOC(dim_size, int64_t);
  if (basis_nao_grid_size_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_size(file, basis_nao_grid_size_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_size(file, basis_nao_grid_size_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_size(file, basis_nao_grid_size_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_nao_grid_size_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_size[i] = (int32_t) basis_nao_grid_size_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_size[i] = (int32_t) basis_nao_grid_size_64[i];
    }
  }

  FREE(basis_nao_grid_size_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_shell_index_32 (trexio_t* const file, int32_t* const basis_shell_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_shell_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_shell_index_64 = CALLOC(dim_size, int64_t);
  if (basis_shell_index_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_shell_index(file, basis_shell_index_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_shell_index(file, basis_shell_index_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_shell_index(file, basis_shell_index_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_shell_index_64);
    return rc;
  }

  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_index[i] = (int32_t) basis_shell_index_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_index[i] = (int32_t) basis_shell_index_64[i];
    }
  }

  FREE(basis_shell_index_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_exponent_32 (trexio_t* const file, float* const basis_exponent)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_exponent == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_exponent_64 = CALLOC(dim_size, double);
  if (basis_exponent_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_exponent(file, basis_exponent_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_exponent(file, basis_exponent_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_exponent(file, basis_exponent_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_exponent_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_exponent[i] = (float) basis_exponent_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_exponent[i] = (float) basis_exponent_64[i];
    }
  }

  FREE(basis_exponent_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_exponent_im_32 (trexio_t* const file, float* const basis_exponent_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_exponent_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_exponent_im_64 = CALLOC(dim_size, double);
  if (basis_exponent_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_exponent_im(file, basis_exponent_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_exponent_im(file, basis_exponent_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_exponent_im(file, basis_exponent_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_exponent_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_exponent_im[i] = (float) basis_exponent_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_exponent_im[i] = (float) basis_exponent_im_64[i];
    }
  }

  FREE(basis_exponent_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_coefficient_32 (trexio_t* const file, float* const basis_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_coefficient_64 = CALLOC(dim_size, double);
  if (basis_coefficient_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_coefficient(file, basis_coefficient_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_coefficient(file, basis_coefficient_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_coefficient(file, basis_coefficient_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_coefficient_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_coefficient[i] = (float) basis_coefficient_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_coefficient[i] = (float) basis_coefficient_64[i];
    }
  }

  FREE(basis_coefficient_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_coefficient_im_32 (trexio_t* const file, float* const basis_coefficient_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_coefficient_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_coefficient_im_64 = CALLOC(dim_size, double);
  if (basis_coefficient_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_coefficient_im(file, basis_coefficient_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_coefficient_im(file, basis_coefficient_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_coefficient_im(file, basis_coefficient_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_coefficient_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_coefficient_im[i] = (float) basis_coefficient_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_coefficient_im[i] = (float) basis_coefficient_im_64[i];
    }
  }

  FREE(basis_coefficient_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_oscillation_arg_32 (trexio_t* const file, float* const basis_oscillation_arg)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_oscillation_arg == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_oscillation_arg(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_oscillation_arg_64 = CALLOC(dim_size, double);
  if (basis_oscillation_arg_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_oscillation_arg(file, basis_oscillation_arg_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_oscillation_arg(file, basis_oscillation_arg_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_oscillation_arg(file, basis_oscillation_arg_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_oscillation_arg_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_oscillation_arg[i] = (float) basis_oscillation_arg_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_oscillation_arg[i] = (float) basis_oscillation_arg_64[i];
    }
  }

  FREE(basis_oscillation_arg_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_prim_factor_32 (trexio_t* const file, float* const basis_prim_factor)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_prim_factor == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_factor(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_prim_factor_64 = CALLOC(dim_size, double);
  if (basis_prim_factor_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_prim_factor(file, basis_prim_factor_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_prim_factor(file, basis_prim_factor_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_prim_factor(file, basis_prim_factor_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_prim_factor_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_prim_factor[i] = (float) basis_prim_factor_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_prim_factor[i] = (float) basis_prim_factor_64[i];
    }
  }

  FREE(basis_prim_factor_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_radius_32 (trexio_t* const file, float* const basis_nao_grid_radius)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_radius == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_radius(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_nao_grid_radius_64 = CALLOC(dim_size, double);
  if (basis_nao_grid_radius_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_radius(file, basis_nao_grid_radius_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_radius(file, basis_nao_grid_radius_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_radius(file, basis_nao_grid_radius_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_nao_grid_radius_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_radius[i] = (float) basis_nao_grid_radius_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_radius[i] = (float) basis_nao_grid_radius_64[i];
    }
  }

  FREE(basis_nao_grid_radius_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_phi_32 (trexio_t* const file, float* const basis_nao_grid_phi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_phi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_phi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_nao_grid_phi_64 = CALLOC(dim_size, double);
  if (basis_nao_grid_phi_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_phi(file, basis_nao_grid_phi_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_phi(file, basis_nao_grid_phi_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_phi(file, basis_nao_grid_phi_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_nao_grid_phi_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_phi[i] = (float) basis_nao_grid_phi_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_phi[i] = (float) basis_nao_grid_phi_64[i];
    }
  }

  FREE(basis_nao_grid_phi_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_grad_32 (trexio_t* const file, float* const basis_nao_grid_grad)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_grad == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_grad(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_nao_grid_grad_64 = CALLOC(dim_size, double);
  if (basis_nao_grid_grad_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_grad(file, basis_nao_grid_grad_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_grad(file, basis_nao_grid_grad_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_grad(file, basis_nao_grid_grad_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_nao_grid_grad_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_grad[i] = (float) basis_nao_grid_grad_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_grad[i] = (float) basis_nao_grid_grad_64[i];
    }
  }

  FREE(basis_nao_grid_grad_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_lap_32 (trexio_t* const file, float* const basis_nao_grid_lap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_lap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_lap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_nao_grid_lap_64 = CALLOC(dim_size, double);
  if (basis_nao_grid_lap_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_lap(file, basis_nao_grid_lap_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_lap(file, basis_nao_grid_lap_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_lap(file, basis_nao_grid_lap_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_nao_grid_lap_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_lap[i] = (float) basis_nao_grid_lap_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_lap[i] = (float) basis_nao_grid_lap_64[i];
    }
  }

  FREE(basis_nao_grid_lap_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_interpolator_phi_32 (trexio_t* const file, float* const basis_interpolator_phi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_interpolator_phi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_phi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_interpolator_phi_64 = CALLOC(dim_size, double);
  if (basis_interpolator_phi_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_interpolator_phi(file, basis_interpolator_phi_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_interpolator_phi(file, basis_interpolator_phi_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_interpolator_phi(file, basis_interpolator_phi_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_interpolator_phi_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_phi[i] = (float) basis_interpolator_phi_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_phi[i] = (float) basis_interpolator_phi_64[i];
    }
  }

  FREE(basis_interpolator_phi_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_interpolator_grad_32 (trexio_t* const file, float* const basis_interpolator_grad)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_interpolator_grad == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_grad(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_interpolator_grad_64 = CALLOC(dim_size, double);
  if (basis_interpolator_grad_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_interpolator_grad(file, basis_interpolator_grad_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_interpolator_grad(file, basis_interpolator_grad_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_interpolator_grad(file, basis_interpolator_grad_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_interpolator_grad_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_grad[i] = (float) basis_interpolator_grad_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_grad[i] = (float) basis_interpolator_grad_64[i];
    }
  }

  FREE(basis_interpolator_grad_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_interpolator_lap_32 (trexio_t* const file, float* const basis_interpolator_lap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_interpolator_lap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_lap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_interpolator_lap_64 = CALLOC(dim_size, double);
  if (basis_interpolator_lap_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_interpolator_lap(file, basis_interpolator_lap_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_interpolator_lap(file, basis_interpolator_lap_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_interpolator_lap(file, basis_interpolator_lap_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(basis_interpolator_lap_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_lap[i] = (float) basis_interpolator_lap_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_lap[i] = (float) basis_interpolator_lap_64[i];
    }
  }

  FREE(basis_interpolator_lap_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_max_ang_mom_plus_1_32 (trexio_t* const file, int32_t* const ecp_max_ang_mom_plus_1)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_max_ang_mom_plus_1 == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_max_ang_mom_plus_1(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_max_ang_mom_plus_1_64 = CALLOC(dim_size, int64_t);
  if (ecp_max_ang_mom_plus_1_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ecp_max_ang_mom_plus_1_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_max_ang_mom_plus_1[i] = (int32_t) ecp_max_ang_mom_plus_1_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_max_ang_mom_plus_1[i] = (int32_t) ecp_max_ang_mom_plus_1_64[i];
    }
  }

  FREE(ecp_max_ang_mom_plus_1_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_z_core_32 (trexio_t* const file, int32_t* const ecp_z_core)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_z_core == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_z_core(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_z_core_64 = CALLOC(dim_size, int64_t);
  if (ecp_z_core_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_z_core(file, ecp_z_core_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_z_core(file, ecp_z_core_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_z_core(file, ecp_z_core_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ecp_z_core_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_z_core[i] = (int32_t) ecp_z_core_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_z_core[i] = (int32_t) ecp_z_core_64[i];
    }
  }

  FREE(ecp_z_core_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_ang_mom_32 (trexio_t* const file, int32_t* const ecp_ang_mom)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_ang_mom == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_ang_mom(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_ang_mom_64 = CALLOC(dim_size, int64_t);
  if (ecp_ang_mom_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_ang_mom(file, ecp_ang_mom_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_ang_mom(file, ecp_ang_mom_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_ang_mom(file, ecp_ang_mom_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ecp_ang_mom_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_ang_mom[i] = (int32_t) ecp_ang_mom_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_ang_mom[i] = (int32_t) ecp_ang_mom_64[i];
    }
  }

  FREE(ecp_ang_mom_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_nucleus_index_32 (trexio_t* const file, int32_t* const ecp_nucleus_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_nucleus_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_nucleus_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_nucleus_index_64 = CALLOC(dim_size, int64_t);
  if (ecp_nucleus_index_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_nucleus_index(file, ecp_nucleus_index_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_nucleus_index(file, ecp_nucleus_index_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_nucleus_index(file, ecp_nucleus_index_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ecp_nucleus_index_64);
    return rc;
  }

  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_nucleus_index[i] = (int32_t) ecp_nucleus_index_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_nucleus_index[i] = (int32_t) ecp_nucleus_index_64[i];
    }
  }

  FREE(ecp_nucleus_index_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_exponent_32 (trexio_t* const file, float* const ecp_exponent)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_exponent == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_exponent(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ecp_exponent_64 = CALLOC(dim_size, double);
  if (ecp_exponent_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_exponent(file, ecp_exponent_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_exponent(file, ecp_exponent_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_exponent(file, ecp_exponent_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ecp_exponent_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_exponent[i] = (float) ecp_exponent_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_exponent[i] = (float) ecp_exponent_64[i];
    }
  }

  FREE(ecp_exponent_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_coefficient_32 (trexio_t* const file, float* const ecp_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ecp_coefficient_64 = CALLOC(dim_size, double);
  if (ecp_coefficient_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_coefficient(file, ecp_coefficient_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_coefficient(file, ecp_coefficient_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_coefficient(file, ecp_coefficient_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ecp_coefficient_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_coefficient[i] = (float) ecp_coefficient_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_coefficient[i] = (float) ecp_coefficient_64[i];
    }
  }

  FREE(ecp_coefficient_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_power_32 (trexio_t* const file, int32_t* const ecp_power)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_power == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_power(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_power_64 = CALLOC(dim_size, int64_t);
  if (ecp_power_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_power(file, ecp_power_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_power(file, ecp_power_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_power(file, ecp_power_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ecp_power_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_power[i] = (int32_t) ecp_power_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_power[i] = (int32_t) ecp_power_64[i];
    }
  }

  FREE(ecp_power_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_coord_32 (trexio_t* const file, float* const grid_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_num_64(file, &(grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_coord_64 = CALLOC(dim_size, double);
  if (grid_coord_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_coord(file, grid_coord_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_coord(file, grid_coord_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_coord(file, grid_coord_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(grid_coord_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_coord[i] = (float) grid_coord_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_coord[i] = (float) grid_coord_64[i];
    }
  }

  FREE(grid_coord_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_weight_32 (trexio_t* const file, float* const grid_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_num_64(file, &(grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_weight_64 = CALLOC(dim_size, double);
  if (grid_weight_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_weight(file, grid_weight_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_weight(file, grid_weight_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_weight(file, grid_weight_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(grid_weight_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_weight[i] = (float) grid_weight_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_weight[i] = (float) grid_weight_64[i];
    }
  }

  FREE(grid_weight_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_ang_coord_32 (trexio_t* const file, float* const grid_ang_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_ang_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_ang_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_ang_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_ang_coord_64 = CALLOC(dim_size, double);
  if (grid_ang_coord_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_ang_coord(file, grid_ang_coord_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_ang_coord(file, grid_ang_coord_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_ang_coord(file, grid_ang_coord_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(grid_ang_coord_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_ang_coord[i] = (float) grid_ang_coord_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_ang_coord[i] = (float) grid_ang_coord_64[i];
    }
  }

  FREE(grid_ang_coord_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_ang_weight_32 (trexio_t* const file, float* const grid_ang_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_ang_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_ang_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_ang_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_ang_weight_64 = CALLOC(dim_size, double);
  if (grid_ang_weight_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_ang_weight(file, grid_ang_weight_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_ang_weight(file, grid_ang_weight_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_ang_weight(file, grid_ang_weight_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(grid_ang_weight_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_ang_weight[i] = (float) grid_ang_weight_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_ang_weight[i] = (float) grid_ang_weight_64[i];
    }
  }

  FREE(grid_ang_weight_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_rad_coord_32 (trexio_t* const file, float* const grid_rad_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_rad_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_rad_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_rad_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_rad_coord_64 = CALLOC(dim_size, double);
  if (grid_rad_coord_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_rad_coord(file, grid_rad_coord_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_rad_coord(file, grid_rad_coord_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_rad_coord(file, grid_rad_coord_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(grid_rad_coord_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_rad_coord[i] = (float) grid_rad_coord_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_rad_coord[i] = (float) grid_rad_coord_64[i];
    }
  }

  FREE(grid_rad_coord_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_rad_weight_32 (trexio_t* const file, float* const grid_rad_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_rad_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_rad_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_rad_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_rad_weight_64 = CALLOC(dim_size, double);
  if (grid_rad_weight_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_rad_weight(file, grid_rad_weight_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_rad_weight(file, grid_rad_weight_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_rad_weight(file, grid_rad_weight_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(grid_rad_weight_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_rad_weight[i] = (float) grid_rad_weight_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_rad_weight[i] = (float) grid_rad_weight_64[i];
    }
  }

  FREE(grid_rad_weight_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_shell_32 (trexio_t* const file, int32_t* const ao_shell)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_shell == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_shell(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ao_shell_64 = CALLOC(dim_size, int64_t);
  if (ao_shell_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_shell(file, ao_shell_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_shell(file, ao_shell_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_shell(file, ao_shell_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_shell_64);
    return rc;
  }

  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_shell[i] = (int32_t) ao_shell_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_shell[i] = (int32_t) ao_shell_64[i];
    }
  }

  FREE(ao_shell_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_normalization_32 (trexio_t* const file, float* const ao_normalization)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_normalization == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_normalization(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_normalization_64 = CALLOC(dim_size, double);
  if (ao_normalization_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_normalization(file, ao_normalization_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_normalization(file, ao_normalization_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_normalization(file, ao_normalization_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_normalization_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_normalization[i] = (float) ao_normalization_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_normalization[i] = (float) ao_normalization_64[i];
    }
  }

  FREE(ao_normalization_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_overlap_32 (trexio_t* const file, float* const ao_1e_int_overlap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_overlap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_overlap_64 = CALLOC(dim_size, double);
  if (ao_1e_int_overlap_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_overlap(file, ao_1e_int_overlap_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_overlap(file, ao_1e_int_overlap_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_overlap(file, ao_1e_int_overlap_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_overlap_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_overlap[i] = (float) ao_1e_int_overlap_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_overlap[i] = (float) ao_1e_int_overlap_64[i];
    }
  }

  FREE(ao_1e_int_overlap_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_kinetic_32 (trexio_t* const file, float* const ao_1e_int_kinetic)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_kinetic == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_kinetic_64 = CALLOC(dim_size, double);
  if (ao_1e_int_kinetic_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_kinetic(file, ao_1e_int_kinetic_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_kinetic(file, ao_1e_int_kinetic_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_kinetic(file, ao_1e_int_kinetic_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_kinetic_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_kinetic[i] = (float) ao_1e_int_kinetic_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_kinetic[i] = (float) ao_1e_int_kinetic_64[i];
    }
  }

  FREE(ao_1e_int_kinetic_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_potential_n_e_32 (trexio_t* const file, float* const ao_1e_int_potential_n_e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_potential_n_e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_potential_n_e_64 = CALLOC(dim_size, double);
  if (ao_1e_int_potential_n_e_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_potential_n_e_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_potential_n_e[i] = (float) ao_1e_int_potential_n_e_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_potential_n_e[i] = (float) ao_1e_int_potential_n_e_64[i];
    }
  }

  FREE(ao_1e_int_potential_n_e_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_ecp_32 (trexio_t* const file, float* const ao_1e_int_ecp)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_ecp == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_ecp_64 = CALLOC(dim_size, double);
  if (ao_1e_int_ecp_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_ecp(file, ao_1e_int_ecp_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_ecp(file, ao_1e_int_ecp_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_ecp(file, ao_1e_int_ecp_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_ecp_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_ecp[i] = (float) ao_1e_int_ecp_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_ecp[i] = (float) ao_1e_int_ecp_64[i];
    }
  }

  FREE(ao_1e_int_ecp_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_core_hamiltonian_32 (trexio_t* const file, float* const ao_1e_int_core_hamiltonian)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_core_hamiltonian == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_core_hamiltonian_64 = CALLOC(dim_size, double);
  if (ao_1e_int_core_hamiltonian_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_core_hamiltonian_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_core_hamiltonian[i] = (float) ao_1e_int_core_hamiltonian_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_core_hamiltonian[i] = (float) ao_1e_int_core_hamiltonian_64[i];
    }
  }

  FREE(ao_1e_int_core_hamiltonian_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_overlap_im_32 (trexio_t* const file, float* const ao_1e_int_overlap_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_overlap_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_overlap_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_overlap_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_overlap_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_overlap_im[i] = (float) ao_1e_int_overlap_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_overlap_im[i] = (float) ao_1e_int_overlap_im_64[i];
    }
  }

  FREE(ao_1e_int_overlap_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_kinetic_im_32 (trexio_t* const file, float* const ao_1e_int_kinetic_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_kinetic_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_kinetic_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_kinetic_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_kinetic_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_kinetic_im[i] = (float) ao_1e_int_kinetic_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_kinetic_im[i] = (float) ao_1e_int_kinetic_im_64[i];
    }
  }

  FREE(ao_1e_int_kinetic_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_potential_n_e_im_32 (trexio_t* const file, float* const ao_1e_int_potential_n_e_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_potential_n_e_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_potential_n_e_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_potential_n_e_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_potential_n_e_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_potential_n_e_im[i] = (float) ao_1e_int_potential_n_e_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_potential_n_e_im[i] = (float) ao_1e_int_potential_n_e_im_64[i];
    }
  }

  FREE(ao_1e_int_potential_n_e_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_ecp_im_32 (trexio_t* const file, float* const ao_1e_int_ecp_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_ecp_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_ecp_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_ecp_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_ecp_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_ecp_im[i] = (float) ao_1e_int_ecp_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_ecp_im[i] = (float) ao_1e_int_ecp_im_64[i];
    }
  }

  FREE(ao_1e_int_ecp_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_core_hamiltonian_im_32 (trexio_t* const file, float* const ao_1e_int_core_hamiltonian_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_core_hamiltonian_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_core_hamiltonian_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_core_hamiltonian_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(ao_1e_int_core_hamiltonian_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_core_hamiltonian_im[i] = (float) ao_1e_int_core_hamiltonian_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_core_hamiltonian_im[i] = (float) ao_1e_int_core_hamiltonian_im_64[i];
    }
  }

  FREE(ao_1e_int_core_hamiltonian_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_coefficient_32 (trexio_t* const file, float* const mo_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;
  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;
  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_coefficient_64 = CALLOC(dim_size, double);
  if (mo_coefficient_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_coefficient(file, mo_coefficient_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_coefficient(file, mo_coefficient_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_coefficient(file, mo_coefficient_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_coefficient_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_coefficient[i] = (float) mo_coefficient_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_coefficient[i] = (float) mo_coefficient_64[i];
    }
  }

  FREE(mo_coefficient_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_coefficient_im_32 (trexio_t* const file, float* const mo_coefficient_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_coefficient_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;
  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;
  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_coefficient_im_64 = CALLOC(dim_size, double);
  if (mo_coefficient_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_coefficient_im(file, mo_coefficient_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_coefficient_im(file, mo_coefficient_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_coefficient_im(file, mo_coefficient_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_coefficient_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_coefficient_im[i] = (float) mo_coefficient_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_coefficient_im[i] = (float) mo_coefficient_im_64[i];
    }
  }

  FREE(mo_coefficient_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_occupation_32 (trexio_t* const file, float* const mo_occupation)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_occupation == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_occupation(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_occupation_64 = CALLOC(dim_size, double);
  if (mo_occupation_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_occupation(file, mo_occupation_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_occupation(file, mo_occupation_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_occupation(file, mo_occupation_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_occupation_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_occupation[i] = (float) mo_occupation_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_occupation[i] = (float) mo_occupation_64[i];
    }
  }

  FREE(mo_occupation_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_energy_32 (trexio_t* const file, float* const mo_energy)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_energy == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_energy(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_energy_64 = CALLOC(dim_size, double);
  if (mo_energy_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_energy(file, mo_energy_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_energy(file, mo_energy_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_energy(file, mo_energy_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_energy_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_energy[i] = (float) mo_energy_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_energy[i] = (float) mo_energy_64[i];
    }
  }

  FREE(mo_energy_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_spin_32 (trexio_t* const file, int32_t* const mo_spin)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_spin == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_spin(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* mo_spin_64 = CALLOC(dim_size, int64_t);
  if (mo_spin_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_spin(file, mo_spin_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_spin(file, mo_spin_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_spin(file, mo_spin_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_spin_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_spin[i] = (int32_t) mo_spin_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_spin[i] = (int32_t) mo_spin_64[i];
    }
  }

  FREE(mo_spin_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_k_point_32 (trexio_t* const file, int32_t* const mo_k_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_k_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_k_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* mo_k_point_64 = CALLOC(dim_size, int64_t);
  if (mo_k_point_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_k_point(file, mo_k_point_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_k_point(file, mo_k_point_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_k_point(file, mo_k_point_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_k_point_64);
    return rc;
  }

  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_k_point[i] = (int32_t) mo_k_point_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_k_point[i] = (int32_t) mo_k_point_64[i];
    }
  }

  FREE(mo_k_point_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_overlap_32 (trexio_t* const file, float* const mo_1e_int_overlap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_overlap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_overlap_64 = CALLOC(dim_size, double);
  if (mo_1e_int_overlap_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_overlap(file, mo_1e_int_overlap_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_overlap(file, mo_1e_int_overlap_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_overlap(file, mo_1e_int_overlap_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_overlap_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_overlap[i] = (float) mo_1e_int_overlap_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_overlap[i] = (float) mo_1e_int_overlap_64[i];
    }
  }

  FREE(mo_1e_int_overlap_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_kinetic_32 (trexio_t* const file, float* const mo_1e_int_kinetic)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_kinetic == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_kinetic_64 = CALLOC(dim_size, double);
  if (mo_1e_int_kinetic_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_kinetic(file, mo_1e_int_kinetic_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_kinetic(file, mo_1e_int_kinetic_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_kinetic(file, mo_1e_int_kinetic_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_kinetic_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_kinetic[i] = (float) mo_1e_int_kinetic_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_kinetic[i] = (float) mo_1e_int_kinetic_64[i];
    }
  }

  FREE(mo_1e_int_kinetic_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_potential_n_e_32 (trexio_t* const file, float* const mo_1e_int_potential_n_e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_potential_n_e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_potential_n_e_64 = CALLOC(dim_size, double);
  if (mo_1e_int_potential_n_e_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_potential_n_e_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_potential_n_e[i] = (float) mo_1e_int_potential_n_e_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_potential_n_e[i] = (float) mo_1e_int_potential_n_e_64[i];
    }
  }

  FREE(mo_1e_int_potential_n_e_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_ecp_32 (trexio_t* const file, float* const mo_1e_int_ecp)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_ecp == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_ecp_64 = CALLOC(dim_size, double);
  if (mo_1e_int_ecp_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_ecp(file, mo_1e_int_ecp_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_ecp(file, mo_1e_int_ecp_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_ecp(file, mo_1e_int_ecp_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_ecp_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_ecp[i] = (float) mo_1e_int_ecp_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_ecp[i] = (float) mo_1e_int_ecp_64[i];
    }
  }

  FREE(mo_1e_int_ecp_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_core_hamiltonian_32 (trexio_t* const file, float* const mo_1e_int_core_hamiltonian)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_core_hamiltonian == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_core_hamiltonian_64 = CALLOC(dim_size, double);
  if (mo_1e_int_core_hamiltonian_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_core_hamiltonian_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_core_hamiltonian[i] = (float) mo_1e_int_core_hamiltonian_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_core_hamiltonian[i] = (float) mo_1e_int_core_hamiltonian_64[i];
    }
  }

  FREE(mo_1e_int_core_hamiltonian_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_overlap_im_32 (trexio_t* const file, float* const mo_1e_int_overlap_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_overlap_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_overlap_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_overlap_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_overlap_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_overlap_im[i] = (float) mo_1e_int_overlap_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_overlap_im[i] = (float) mo_1e_int_overlap_im_64[i];
    }
  }

  FREE(mo_1e_int_overlap_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_kinetic_im_32 (trexio_t* const file, float* const mo_1e_int_kinetic_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_kinetic_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_kinetic_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_kinetic_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_kinetic_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_kinetic_im[i] = (float) mo_1e_int_kinetic_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_kinetic_im[i] = (float) mo_1e_int_kinetic_im_64[i];
    }
  }

  FREE(mo_1e_int_kinetic_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_potential_n_e_im_32 (trexio_t* const file, float* const mo_1e_int_potential_n_e_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_potential_n_e_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_potential_n_e_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_potential_n_e_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_potential_n_e_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_potential_n_e_im[i] = (float) mo_1e_int_potential_n_e_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_potential_n_e_im[i] = (float) mo_1e_int_potential_n_e_im_64[i];
    }
  }

  FREE(mo_1e_int_potential_n_e_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_ecp_im_32 (trexio_t* const file, float* const mo_1e_int_ecp_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_ecp_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_ecp_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_ecp_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_ecp_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_ecp_im[i] = (float) mo_1e_int_ecp_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_ecp_im[i] = (float) mo_1e_int_ecp_im_64[i];
    }
  }

  FREE(mo_1e_int_ecp_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_core_hamiltonian_im_32 (trexio_t* const file, float* const mo_1e_int_core_hamiltonian_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_core_hamiltonian_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_core_hamiltonian_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_core_hamiltonian_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(mo_1e_int_core_hamiltonian_im_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_core_hamiltonian_im[i] = (float) mo_1e_int_core_hamiltonian_im_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_core_hamiltonian_im[i] = (float) mo_1e_int_core_hamiltonian_im_64[i];
    }
  }

  FREE(mo_1e_int_core_hamiltonian_im_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_1e_32 (trexio_t* const file, float* const rdm_1e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* rdm_1e_64 = CALLOC(dim_size, double);
  if (rdm_1e_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_1e(file, rdm_1e_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_1e(file, rdm_1e_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_1e(file, rdm_1e_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(rdm_1e_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e[i] = (float) rdm_1e_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e[i] = (float) rdm_1e_64[i];
    }
  }

  FREE(rdm_1e_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_1e_up_32 (trexio_t* const file, float* const rdm_1e_up)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e_up == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_up(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* rdm_1e_up_64 = CALLOC(dim_size, double);
  if (rdm_1e_up_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_1e_up(file, rdm_1e_up_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_1e_up(file, rdm_1e_up_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_1e_up(file, rdm_1e_up_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(rdm_1e_up_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_up[i] = (float) rdm_1e_up_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_up[i] = (float) rdm_1e_up_64[i];
    }
  }

  FREE(rdm_1e_up_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_1e_dn_32 (trexio_t* const file, float* const rdm_1e_dn)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e_dn == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_dn(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* rdm_1e_dn_64 = CALLOC(dim_size, double);
  if (rdm_1e_dn_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_1e_dn(file, rdm_1e_dn_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_1e_dn(file, rdm_1e_dn_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_1e_dn(file, rdm_1e_dn_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(rdm_1e_dn_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_dn[i] = (float) rdm_1e_dn_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_dn[i] = (float) rdm_1e_dn_64[i];
    }
  }

  FREE(rdm_1e_dn_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_1e_transition_32 (trexio_t* const file, float* const rdm_1e_transition)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e_transition == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_transition(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t state_num = 0;
  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_state_num_64(file, &(state_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (state_num == 0L) return TREXIO_INVALID_NUM;
  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 4;
  uint64_t dims[4] = {state_num, state_num, mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* rdm_1e_transition_64 = CALLOC(dim_size, double);
  if (rdm_1e_transition_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_1e_transition(file, rdm_1e_transition_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_1e_transition(file, rdm_1e_transition_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_1e_transition(file, rdm_1e_transition_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(rdm_1e_transition_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_transition[i] = (float) rdm_1e_transition_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_transition[i] = (float) rdm_1e_transition_64[i];
    }
  }

  FREE(rdm_1e_transition_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_en_32 (trexio_t* const file, float* const jastrow_en)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_en == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_en_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_en_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* jastrow_en_64 = CALLOC(dim_size, double);
  if (jastrow_en_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_en(file, jastrow_en_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_en(file, jastrow_en_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_en(file, jastrow_en_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(jastrow_en_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en[i] = (float) jastrow_en_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en[i] = (float) jastrow_en_64[i];
    }
  }

  FREE(jastrow_en_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_ee_32 (trexio_t* const file, float* const jastrow_ee)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_ee == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_ee_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_ee_num_64(file, &(jastrow_ee_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_ee_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_ee_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* jastrow_ee_64 = CALLOC(dim_size, double);
  if (jastrow_ee_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_ee(file, jastrow_ee_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_ee(file, jastrow_ee_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_ee(file, jastrow_ee_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(jastrow_ee_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_ee[i] = (float) jastrow_ee_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_ee[i] = (float) jastrow_ee_64[i];
    }
  }

  FREE(jastrow_ee_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_een_32 (trexio_t* const file, float* const jastrow_een)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_een == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_een_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_een_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* jastrow_een_64 = CALLOC(dim_size, double);
  if (jastrow_een_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_een(file, jastrow_een_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_een(file, jastrow_een_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_een(file, jastrow_een_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(jastrow_een_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_een[i] = (float) jastrow_een_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_een[i] = (float) jastrow_een_64[i];
    }
  }

  FREE(jastrow_een_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_en_nucleus_32 (trexio_t* const file, int32_t* const jastrow_en_nucleus)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_en_nucleus == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_nucleus(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_en_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_en_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* jastrow_en_nucleus_64 = CALLOC(dim_size, int64_t);
  if (jastrow_en_nucleus_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_en_nucleus(file, jastrow_en_nucleus_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_en_nucleus(file, jastrow_en_nucleus_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_en_nucleus(file, jastrow_en_nucleus_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(jastrow_en_nucleus_64);
    return rc;
  }

  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_nucleus[i] = (int32_t) jastrow_en_nucleus_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_nucleus[i] = (int32_t) jastrow_en_nucleus_64[i];
    }
  }

  FREE(jastrow_en_nucleus_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_een_nucleus_32 (trexio_t* const file, int32_t* const jastrow_een_nucleus)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_een_nucleus == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_nucleus(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_een_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_een_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* jastrow_een_nucleus_64 = CALLOC(dim_size, int64_t);
  if (jastrow_een_nucleus_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_een_nucleus(file, jastrow_een_nucleus_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_een_nucleus(file, jastrow_een_nucleus_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_een_nucleus(file, jastrow_een_nucleus_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(jastrow_een_nucleus_64);
    return rc;
  }

  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_een_nucleus[i] = (int32_t) jastrow_een_nucleus_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_een_nucleus[i] = (int32_t) jastrow_een_nucleus_64[i];
    }
  }

  FREE(jastrow_een_nucleus_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_en_scaling_32 (trexio_t* const file, float* const jastrow_en_scaling)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_en_scaling == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_scaling(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* jastrow_en_scaling_64 = CALLOC(dim_size, double);
  if (jastrow_en_scaling_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_en_scaling(file, jastrow_en_scaling_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_en_scaling(file, jastrow_en_scaling_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_en_scaling(file, jastrow_en_scaling_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(jastrow_en_scaling_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_scaling[i] = (float) jastrow_en_scaling_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_scaling[i] = (float) jastrow_en_scaling_64[i];
    }
  }

  FREE(jastrow_en_scaling_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_qmc_point_32 (trexio_t* const file, float* const qmc_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (qmc_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t qmc_num = 0;
  int64_t electron_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_electron_num_64(file, &(electron_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;
  if (electron_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 3;
  uint64_t dims[3] = {qmc_num, electron_num, 3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* qmc_point_64 = CALLOC(dim_size, double);
  if (qmc_point_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_qmc_point(file, qmc_point_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_qmc_point(file, qmc_point_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_qmc_point(file, qmc_point_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(qmc_point_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_point[i] = (float) qmc_point_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_point[i] = (float) qmc_point_64[i];
    }
  }

  FREE(qmc_point_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_qmc_psi_32 (trexio_t* const file, float* const qmc_psi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (qmc_psi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_psi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t qmc_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {qmc_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* qmc_psi_64 = CALLOC(dim_size, double);
  if (qmc_psi_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_qmc_psi(file, qmc_psi_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_qmc_psi(file, qmc_psi_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_qmc_psi(file, qmc_psi_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(qmc_psi_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_psi[i] = (float) qmc_psi_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_psi[i] = (float) qmc_psi_64[i];
    }
  }

  FREE(qmc_psi_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_qmc_e_loc_32 (trexio_t* const file, float* const qmc_e_loc)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (qmc_e_loc == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_e_loc(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t qmc_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {qmc_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* qmc_e_loc_64 = CALLOC(dim_size, double);
  if (qmc_e_loc_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_qmc_e_loc(file, qmc_e_loc_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_qmc_e_loc(file, qmc_e_loc_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_qmc_e_loc(file, qmc_e_loc_64, rank, dims);
    break;
*/
  }

  if (rc != TREXIO_SUCCESS){
    FREE(qmc_e_loc_64);
    return rc;
  }

  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_e_loc[i] = (float) qmc_e_loc_64[i] + 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_e_loc[i] = (float) qmc_e_loc_64[i];
    }
  }

  FREE(qmc_e_loc_64);
  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_safe_nucleus_charge_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_charge(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_nucleus_charge_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_nucleus_coord_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {nucleus_num, 3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_nucleus_coord_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_a_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_a(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_a_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_b_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_b(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_b_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_c_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_c(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_c_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_g_a_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_a(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_g_a_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_g_b_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_b(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_g_b_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_g_c_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_c(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_g_c_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_pbc_k_point_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_pbc_k_point_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_pbc_k_point_weight_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t pbc_k_point_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_pbc_k_point_num_64(file, &(pbc_k_point_num));
if (rc != TREXIO_SUCCESS) return rc;

if (pbc_k_point_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {pbc_k_point_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_pbc_k_point_weight_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nucleus_index_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nucleus_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nucleus_index_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_shell_ang_mom_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_ang_mom(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_shell_ang_mom_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_shell_factor_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_factor(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_shell_factor_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_r_power_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_r_power(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_r_power_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_start_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_start(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_start_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_size_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_size(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_size_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_shell_index_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_shell_index_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_exponent_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_exponent_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_exponent_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_exponent_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_coefficient_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_coefficient_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_coefficient_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_coefficient_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_oscillation_arg_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_oscillation_arg(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_oscillation_arg_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_prim_factor_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_factor(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_prim_factor_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_radius_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_radius(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_radius_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_phi_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_phi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_phi_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_grad_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_grad(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_grad_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_lap_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_lap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_lap_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_interpolator_phi_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_phi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_interpolator_phi_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_interpolator_grad_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_grad(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_interpolator_grad_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_interpolator_lap_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_lap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_interpolator_lap_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_max_ang_mom_plus_1_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_max_ang_mom_plus_1(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_max_ang_mom_plus_1_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_z_core_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_z_core(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_z_core_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_ang_mom_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_ang_mom(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_ang_mom_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_nucleus_index_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_nucleus_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_nucleus_index_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_exponent_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_exponent(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_exponent_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_coefficient_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_coefficient_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_power_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_power(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_power_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_coord_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_num_64(file, &(grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_coord_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_weight_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_num_64(file, &(grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_weight_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_ang_coord_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_ang_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_ang_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_ang_coord_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_ang_weight_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_ang_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_ang_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_ang_weight_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_rad_coord_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_rad_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_rad_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_rad_coord_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_rad_weight_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_rad_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_rad_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_rad_weight_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_shell_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_shell(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_shell_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_normalization_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_normalization(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_normalization_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_overlap_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_overlap_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_kinetic_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_kinetic_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_potential_n_e_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_potential_n_e_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_ecp_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_ecp_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_core_hamiltonian_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_core_hamiltonian_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_overlap_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_overlap_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_kinetic_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_kinetic_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_potential_n_e_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_potential_n_e_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_ecp_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_ecp_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_core_hamiltonian_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_core_hamiltonian_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_coefficient_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;
int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;
if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_coefficient_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_coefficient_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;
int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;
if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_coefficient_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_occupation_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_occupation(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_occupation_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_energy_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_energy(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_energy_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_spin_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_spin(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_spin_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_k_point_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_k_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_k_point_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_overlap_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_overlap_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_kinetic_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_kinetic_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_potential_n_e_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_potential_n_e_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_ecp_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_ecp_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_core_hamiltonian_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_core_hamiltonian_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_overlap_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_overlap_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_kinetic_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_kinetic_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_potential_n_e_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_potential_n_e_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_ecp_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_ecp_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_core_hamiltonian_im_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_core_hamiltonian_im_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_rdm_1e_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_up_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_up(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_rdm_1e_up_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_dn_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_dn(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_rdm_1e_dn_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_transition_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_transition(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t state_num = 0;
int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_state_num_64(file, &(state_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (state_num == 0L) return TREXIO_INVALID_NUM;
if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 4;
uint64_t dims[4] = {state_num, state_num, mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_rdm_1e_transition_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_en_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_en_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_en_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_en_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_ee_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_ee_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_ee_num_64(file, &(jastrow_ee_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_ee_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_ee_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_ee_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_een_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_een_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_een_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_een_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_en_nucleus_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_nucleus(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_en_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_en_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_en_nucleus_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_een_nucleus_32 (trexio_t* const file, int32_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_nucleus(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_een_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_een_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_een_nucleus_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_en_scaling_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_scaling(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_en_scaling_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_qmc_point_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t qmc_num = 0;
int64_t electron_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_electron_num_64(file, &(electron_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;
if (electron_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 3;
uint64_t dims[3] = {qmc_num, electron_num, 3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_qmc_point_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_qmc_psi_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_psi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t qmc_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {qmc_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_qmc_psi_32(file, dset_out);
}

trexio_exit_code
trexio_read_safe_qmc_e_loc_32 (trexio_t* const file, float* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_e_loc(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t qmc_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {qmc_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_qmc_e_loc_32(file, dset_out);
}

trexio_exit_code
trexio_read_nucleus_charge_64 (trexio_t* const file, double* const nucleus_charge)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (nucleus_charge == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_charge(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_nucleus_charge(file, nucleus_charge, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_nucleus_charge(file, nucleus_charge, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_nucleus_charge(file, nucleus_charge, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       nucleus_charge[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_nucleus_coord_64 (trexio_t* const file, double* const nucleus_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (nucleus_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {nucleus_num, 3};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_nucleus_coord(file, nucleus_coord, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_nucleus_coord(file, nucleus_coord, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_nucleus_coord(file, nucleus_coord, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       nucleus_coord[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_a_64 (trexio_t* const file, double* const cell_a)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_a == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_a(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_a(file, cell_a, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_a(file, cell_a, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_a(file, cell_a, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       cell_a[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_b_64 (trexio_t* const file, double* const cell_b)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_b == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_b(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_b(file, cell_b, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_b(file, cell_b, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_b(file, cell_b, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       cell_b[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_c_64 (trexio_t* const file, double* const cell_c)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_c == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_c(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_c(file, cell_c, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_c(file, cell_c, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_c(file, cell_c, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       cell_c[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_g_a_64 (trexio_t* const file, double* const cell_g_a)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_g_a == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_a(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_g_a(file, cell_g_a, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_g_a(file, cell_g_a, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_g_a(file, cell_g_a, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       cell_g_a[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_g_b_64 (trexio_t* const file, double* const cell_g_b)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_g_b == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_b(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_g_b(file, cell_g_b, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_g_b(file, cell_g_b, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_g_b(file, cell_g_b, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       cell_g_b[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_cell_g_c_64 (trexio_t* const file, double* const cell_g_c)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_g_c == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_c(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_cell_g_c(file, cell_g_c, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_cell_g_c(file, cell_g_c, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_cell_g_c(file, cell_g_c, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       cell_g_c[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_pbc_k_point_64 (trexio_t* const file, double* const pbc_k_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (pbc_k_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_k_point(file, pbc_k_point, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_k_point(file, pbc_k_point, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_pbc_k_point(file, pbc_k_point, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       pbc_k_point[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_pbc_k_point_weight_64 (trexio_t* const file, double* const pbc_k_point_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (pbc_k_point_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t pbc_k_point_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_pbc_k_point_num_64(file, &(pbc_k_point_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (pbc_k_point_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {pbc_k_point_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_pbc_k_point_weight(file, pbc_k_point_weight, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_pbc_k_point_weight(file, pbc_k_point_weight, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_pbc_k_point_weight(file, pbc_k_point_weight, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       pbc_k_point_weight[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nucleus_index_64 (trexio_t* const file, int64_t* const basis_nucleus_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nucleus_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nucleus_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nucleus_index(file, basis_nucleus_index, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nucleus_index(file, basis_nucleus_index, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nucleus_index(file, basis_nucleus_index, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if (file->one_based) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_nucleus_index[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_shell_ang_mom_64 (trexio_t* const file, int64_t* const basis_shell_ang_mom)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_shell_ang_mom == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_ang_mom(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_shell_ang_mom(file, basis_shell_ang_mom, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_shell_ang_mom(file, basis_shell_ang_mom, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_shell_ang_mom(file, basis_shell_ang_mom, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_shell_ang_mom[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_shell_factor_64 (trexio_t* const file, double* const basis_shell_factor)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_shell_factor == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_factor(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_shell_factor(file, basis_shell_factor, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_shell_factor(file, basis_shell_factor, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_shell_factor(file, basis_shell_factor, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_shell_factor[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_r_power_64 (trexio_t* const file, int64_t* const basis_r_power)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_r_power == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_r_power(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_r_power(file, basis_r_power, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_r_power(file, basis_r_power, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_r_power(file, basis_r_power, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_r_power[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_start_64 (trexio_t* const file, int64_t* const basis_nao_grid_start)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_start == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_start(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_start(file, basis_nao_grid_start, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_start(file, basis_nao_grid_start, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_start(file, basis_nao_grid_start, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if (file->one_based) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_start[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_size_64 (trexio_t* const file, int64_t* const basis_nao_grid_size)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_size == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_size(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_size(file, basis_nao_grid_size, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_size(file, basis_nao_grid_size, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_size(file, basis_nao_grid_size, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_size[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_shell_index_64 (trexio_t* const file, int64_t* const basis_shell_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_shell_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_shell_index(file, basis_shell_index, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_shell_index(file, basis_shell_index, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_shell_index(file, basis_shell_index, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if (file->one_based) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_shell_index[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_exponent_64 (trexio_t* const file, double* const basis_exponent)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_exponent == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_exponent(file, basis_exponent, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_exponent(file, basis_exponent, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_exponent(file, basis_exponent, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_exponent[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_exponent_im_64 (trexio_t* const file, double* const basis_exponent_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_exponent_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_exponent_im(file, basis_exponent_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_exponent_im(file, basis_exponent_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_exponent_im(file, basis_exponent_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_exponent_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_coefficient_64 (trexio_t* const file, double* const basis_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_coefficient(file, basis_coefficient, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_coefficient(file, basis_coefficient, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_coefficient(file, basis_coefficient, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_coefficient[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_coefficient_im_64 (trexio_t* const file, double* const basis_coefficient_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_coefficient_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_coefficient_im(file, basis_coefficient_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_coefficient_im(file, basis_coefficient_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_coefficient_im(file, basis_coefficient_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_coefficient_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_oscillation_arg_64 (trexio_t* const file, double* const basis_oscillation_arg)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_oscillation_arg == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_oscillation_arg(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_oscillation_arg(file, basis_oscillation_arg, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_oscillation_arg(file, basis_oscillation_arg, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_oscillation_arg(file, basis_oscillation_arg, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_oscillation_arg[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_prim_factor_64 (trexio_t* const file, double* const basis_prim_factor)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_prim_factor == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_factor(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_prim_factor(file, basis_prim_factor, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_prim_factor(file, basis_prim_factor, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_prim_factor(file, basis_prim_factor, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_prim_factor[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_radius_64 (trexio_t* const file, double* const basis_nao_grid_radius)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_radius == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_radius(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_radius(file, basis_nao_grid_radius, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_radius(file, basis_nao_grid_radius, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_radius(file, basis_nao_grid_radius, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_radius[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_phi_64 (trexio_t* const file, double* const basis_nao_grid_phi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_phi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_phi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_phi(file, basis_nao_grid_phi, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_phi(file, basis_nao_grid_phi, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_phi(file, basis_nao_grid_phi, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_phi[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_grad_64 (trexio_t* const file, double* const basis_nao_grid_grad)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_grad == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_grad(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_grad(file, basis_nao_grid_grad, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_grad(file, basis_nao_grid_grad, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_grad(file, basis_nao_grid_grad, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_grad[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_nao_grid_lap_64 (trexio_t* const file, double* const basis_nao_grid_lap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_lap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_lap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_nao_grid_lap(file, basis_nao_grid_lap, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_nao_grid_lap(file, basis_nao_grid_lap, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_nao_grid_lap(file, basis_nao_grid_lap, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_lap[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_interpolator_phi_64 (trexio_t* const file, double* const basis_interpolator_phi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_interpolator_phi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_phi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_interpolator_phi(file, basis_interpolator_phi, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_interpolator_phi(file, basis_interpolator_phi, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_interpolator_phi(file, basis_interpolator_phi, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_interpolator_phi[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_interpolator_grad_64 (trexio_t* const file, double* const basis_interpolator_grad)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_interpolator_grad == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_grad(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_interpolator_grad(file, basis_interpolator_grad, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_interpolator_grad(file, basis_interpolator_grad, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_interpolator_grad(file, basis_interpolator_grad, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_interpolator_grad[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_basis_interpolator_lap_64 (trexio_t* const file, double* const basis_interpolator_lap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_interpolator_lap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_lap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_basis_interpolator_lap(file, basis_interpolator_lap, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_basis_interpolator_lap(file, basis_interpolator_lap, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_basis_interpolator_lap(file, basis_interpolator_lap, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       basis_interpolator_lap[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_max_ang_mom_plus_1_64 (trexio_t* const file, int64_t* const ecp_max_ang_mom_plus_1)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_max_ang_mom_plus_1 == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_max_ang_mom_plus_1(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ecp_max_ang_mom_plus_1[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_z_core_64 (trexio_t* const file, int64_t* const ecp_z_core)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_z_core == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_z_core(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_z_core(file, ecp_z_core, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_z_core(file, ecp_z_core, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_z_core(file, ecp_z_core, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ecp_z_core[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_ang_mom_64 (trexio_t* const file, int64_t* const ecp_ang_mom)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_ang_mom == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_ang_mom(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_ang_mom(file, ecp_ang_mom, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_ang_mom(file, ecp_ang_mom, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_ang_mom(file, ecp_ang_mom, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ecp_ang_mom[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_nucleus_index_64 (trexio_t* const file, int64_t* const ecp_nucleus_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_nucleus_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_nucleus_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_nucleus_index(file, ecp_nucleus_index, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_nucleus_index(file, ecp_nucleus_index, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_nucleus_index(file, ecp_nucleus_index, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if (file->one_based) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ecp_nucleus_index[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_exponent_64 (trexio_t* const file, double* const ecp_exponent)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_exponent == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_exponent(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_exponent(file, ecp_exponent, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_exponent(file, ecp_exponent, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_exponent(file, ecp_exponent, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ecp_exponent[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_coefficient_64 (trexio_t* const file, double* const ecp_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_coefficient(file, ecp_coefficient, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_coefficient(file, ecp_coefficient, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_coefficient(file, ecp_coefficient, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ecp_coefficient[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ecp_power_64 (trexio_t* const file, int64_t* const ecp_power)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_power == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_power(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ecp_power(file, ecp_power, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ecp_power(file, ecp_power, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ecp_power(file, ecp_power, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ecp_power[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_coord_64 (trexio_t* const file, double* const grid_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_num_64(file, &(grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_coord(file, grid_coord, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_coord(file, grid_coord, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_coord(file, grid_coord, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       grid_coord[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_weight_64 (trexio_t* const file, double* const grid_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_num_64(file, &(grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_weight(file, grid_weight, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_weight(file, grid_weight, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_weight(file, grid_weight, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       grid_weight[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_ang_coord_64 (trexio_t* const file, double* const grid_ang_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_ang_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_ang_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_ang_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_ang_coord(file, grid_ang_coord, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_ang_coord(file, grid_ang_coord, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_ang_coord(file, grid_ang_coord, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       grid_ang_coord[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_ang_weight_64 (trexio_t* const file, double* const grid_ang_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_ang_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_ang_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_ang_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_ang_weight(file, grid_ang_weight, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_ang_weight(file, grid_ang_weight, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_ang_weight(file, grid_ang_weight, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       grid_ang_weight[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_rad_coord_64 (trexio_t* const file, double* const grid_rad_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_rad_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_rad_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_rad_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_rad_coord(file, grid_rad_coord, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_rad_coord(file, grid_rad_coord, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_rad_coord(file, grid_rad_coord, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       grid_rad_coord[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_grid_rad_weight_64 (trexio_t* const file, double* const grid_rad_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_rad_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t grid_rad_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_rad_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_grid_rad_weight(file, grid_rad_weight, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_grid_rad_weight(file, grid_rad_weight, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_grid_rad_weight(file, grid_rad_weight, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       grid_rad_weight[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_shell_64 (trexio_t* const file, int64_t* const ao_shell)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_shell == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_shell(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_shell(file, ao_shell, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_shell(file, ao_shell, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_shell(file, ao_shell, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if (file->one_based) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_shell[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_normalization_64 (trexio_t* const file, double* const ao_normalization)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_normalization == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_normalization(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_normalization(file, ao_normalization, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_normalization(file, ao_normalization, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_normalization(file, ao_normalization, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_normalization[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_overlap_64 (trexio_t* const file, double* const ao_1e_int_overlap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_overlap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_overlap(file, ao_1e_int_overlap, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_overlap(file, ao_1e_int_overlap, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_overlap(file, ao_1e_int_overlap, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_overlap[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_kinetic_64 (trexio_t* const file, double* const ao_1e_int_kinetic)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_kinetic == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_kinetic(file, ao_1e_int_kinetic, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_kinetic(file, ao_1e_int_kinetic, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_kinetic(file, ao_1e_int_kinetic, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_kinetic[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_potential_n_e_64 (trexio_t* const file, double* const ao_1e_int_potential_n_e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_potential_n_e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_potential_n_e[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_ecp_64 (trexio_t* const file, double* const ao_1e_int_ecp)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_ecp == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_ecp(file, ao_1e_int_ecp, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_ecp(file, ao_1e_int_ecp, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_ecp(file, ao_1e_int_ecp, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_ecp[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_core_hamiltonian_64 (trexio_t* const file, double* const ao_1e_int_core_hamiltonian)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_core_hamiltonian == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_core_hamiltonian[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_overlap_im_64 (trexio_t* const file, double* const ao_1e_int_overlap_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_overlap_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_overlap_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_kinetic_im_64 (trexio_t* const file, double* const ao_1e_int_kinetic_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_kinetic_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_kinetic_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_potential_n_e_im_64 (trexio_t* const file, double* const ao_1e_int_potential_n_e_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_potential_n_e_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_potential_n_e_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_ecp_im_64 (trexio_t* const file, double* const ao_1e_int_ecp_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_ecp_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_ecp_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_ao_1e_int_core_hamiltonian_im_64 (trexio_t* const file, double* const ao_1e_int_core_hamiltonian_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_core_hamiltonian_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_core_hamiltonian_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_coefficient_64 (trexio_t* const file, double* const mo_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;
  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;
  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_coefficient(file, mo_coefficient, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_coefficient(file, mo_coefficient, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_coefficient(file, mo_coefficient, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_coefficient[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_coefficient_im_64 (trexio_t* const file, double* const mo_coefficient_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_coefficient_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;
  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;
  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, ao_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_coefficient_im(file, mo_coefficient_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_coefficient_im(file, mo_coefficient_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_coefficient_im(file, mo_coefficient_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_coefficient_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_occupation_64 (trexio_t* const file, double* const mo_occupation)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_occupation == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_occupation(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_occupation(file, mo_occupation, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_occupation(file, mo_occupation, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_occupation(file, mo_occupation, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_occupation[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_energy_64 (trexio_t* const file, double* const mo_energy)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_energy == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_energy(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_energy(file, mo_energy, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_energy(file, mo_energy, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_energy(file, mo_energy, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_energy[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_spin_64 (trexio_t* const file, int64_t* const mo_spin)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_spin == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_spin(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_spin(file, mo_spin, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_spin(file, mo_spin, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_spin(file, mo_spin, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_spin[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_k_point_64 (trexio_t* const file, int64_t* const mo_k_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_k_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_k_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_k_point(file, mo_k_point, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_k_point(file, mo_k_point, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_k_point(file, mo_k_point, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if (file->one_based) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_k_point[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_overlap_64 (trexio_t* const file, double* const mo_1e_int_overlap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_overlap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_overlap(file, mo_1e_int_overlap, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_overlap(file, mo_1e_int_overlap, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_overlap(file, mo_1e_int_overlap, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_overlap[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_kinetic_64 (trexio_t* const file, double* const mo_1e_int_kinetic)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_kinetic == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_kinetic(file, mo_1e_int_kinetic, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_kinetic(file, mo_1e_int_kinetic, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_kinetic(file, mo_1e_int_kinetic, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_kinetic[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_potential_n_e_64 (trexio_t* const file, double* const mo_1e_int_potential_n_e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_potential_n_e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_potential_n_e[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_ecp_64 (trexio_t* const file, double* const mo_1e_int_ecp)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_ecp == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_ecp(file, mo_1e_int_ecp, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_ecp(file, mo_1e_int_ecp, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_ecp(file, mo_1e_int_ecp, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_ecp[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_core_hamiltonian_64 (trexio_t* const file, double* const mo_1e_int_core_hamiltonian)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_core_hamiltonian == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_core_hamiltonian[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_overlap_im_64 (trexio_t* const file, double* const mo_1e_int_overlap_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_overlap_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_overlap_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_kinetic_im_64 (trexio_t* const file, double* const mo_1e_int_kinetic_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_kinetic_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_kinetic_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_potential_n_e_im_64 (trexio_t* const file, double* const mo_1e_int_potential_n_e_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_potential_n_e_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_potential_n_e_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_ecp_im_64 (trexio_t* const file, double* const mo_1e_int_ecp_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_ecp_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_ecp_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_mo_1e_int_core_hamiltonian_im_64 (trexio_t* const file, double* const mo_1e_int_core_hamiltonian_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_core_hamiltonian_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_core_hamiltonian_im[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_1e_64 (trexio_t* const file, double* const rdm_1e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_1e(file, rdm_1e, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_1e(file, rdm_1e, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_1e(file, rdm_1e, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       rdm_1e[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_1e_up_64 (trexio_t* const file, double* const rdm_1e_up)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e_up == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_up(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_1e_up(file, rdm_1e_up, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_1e_up(file, rdm_1e_up, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_1e_up(file, rdm_1e_up, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       rdm_1e_up[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_1e_dn_64 (trexio_t* const file, double* const rdm_1e_dn)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e_dn == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_dn(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_1e_dn(file, rdm_1e_dn, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_1e_dn(file, rdm_1e_dn, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_1e_dn(file, rdm_1e_dn, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       rdm_1e_dn[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_rdm_1e_transition_64 (trexio_t* const file, double* const rdm_1e_transition)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e_transition == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_transition(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t state_num = 0;
  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_state_num_64(file, &(state_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (state_num == 0L) return TREXIO_INVALID_NUM;
  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 4;
  uint64_t dims[4] = {state_num, state_num, mo_num, mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_1e_transition(file, rdm_1e_transition, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_1e_transition(file, rdm_1e_transition, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_rdm_1e_transition(file, rdm_1e_transition, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       rdm_1e_transition[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_en_64 (trexio_t* const file, double* const jastrow_en)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_en == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_en_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_en_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_en(file, jastrow_en, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_en(file, jastrow_en, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_en(file, jastrow_en, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_en[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_ee_64 (trexio_t* const file, double* const jastrow_ee)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_ee == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_ee_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_ee_num_64(file, &(jastrow_ee_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_ee_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_ee_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_ee(file, jastrow_ee, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_ee(file, jastrow_ee, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_ee(file, jastrow_ee, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_ee[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_een_64 (trexio_t* const file, double* const jastrow_een)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_een == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_een_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_een_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_een(file, jastrow_een, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_een(file, jastrow_een, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_een(file, jastrow_een, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_een[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_en_nucleus_64 (trexio_t* const file, int64_t* const jastrow_en_nucleus)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_en_nucleus == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_nucleus(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_en_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_en_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_en_nucleus(file, jastrow_en_nucleus, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_en_nucleus(file, jastrow_en_nucleus, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_en_nucleus(file, jastrow_en_nucleus, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if (file->one_based) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_en_nucleus[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_een_nucleus_64 (trexio_t* const file, int64_t* const jastrow_een_nucleus)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_een_nucleus == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_nucleus(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t jastrow_een_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_een_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_een_nucleus(file, jastrow_een_nucleus, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_een_nucleus(file, jastrow_een_nucleus, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_een_nucleus(file, jastrow_een_nucleus, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if (file->one_based) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_een_nucleus[i] += (int64_t) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_jastrow_en_scaling_64 (trexio_t* const file, double* const jastrow_en_scaling)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_en_scaling == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_scaling(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_jastrow_en_scaling(file, jastrow_en_scaling, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_jastrow_en_scaling(file, jastrow_en_scaling, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_jastrow_en_scaling(file, jastrow_en_scaling, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_en_scaling[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_qmc_point_64 (trexio_t* const file, double* const qmc_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (qmc_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t qmc_num = 0;
  int64_t electron_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_electron_num_64(file, &(electron_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;
  if (electron_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 3;
  uint64_t dims[3] = {qmc_num, electron_num, 3};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_qmc_point(file, qmc_point, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_qmc_point(file, qmc_point, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_qmc_point(file, qmc_point, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       qmc_point[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_qmc_psi_64 (trexio_t* const file, double* const qmc_psi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (qmc_psi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_psi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t qmc_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {qmc_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_qmc_psi(file, qmc_psi, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_qmc_psi(file, qmc_psi, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_qmc_psi(file, qmc_psi, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       qmc_psi[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_qmc_e_loc_64 (trexio_t* const file, double* const qmc_e_loc)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (qmc_e_loc == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_e_loc(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t qmc_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {qmc_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_qmc_e_loc(file, qmc_e_loc, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_qmc_e_loc(file, qmc_e_loc, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_qmc_e_loc(file, qmc_e_loc, rank, dims);
    break;
*/
  }
  if (rc != TREXIO_SUCCESS) return rc;

  /* Handle index type */
  if ((false)) {
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
        dim_size *= dims[i];
    }
    for (uint64_t i=0; i<dim_size; ++i){
       qmc_e_loc[i] += (double) 1;
    }
  }

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_safe_nucleus_charge_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_charge(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_nucleus_charge_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_nucleus_coord_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {nucleus_num, 3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_nucleus_coord_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_a_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_a(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_a_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_b_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_b(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_b_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_c_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_c(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_c_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_g_a_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_a(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_g_a_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_g_b_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_b(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_g_b_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_cell_g_c_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_c(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_cell_g_c_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_pbc_k_point_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_pbc_k_point_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_pbc_k_point_weight_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t pbc_k_point_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_pbc_k_point_num_64(file, &(pbc_k_point_num));
if (rc != TREXIO_SUCCESS) return rc;

if (pbc_k_point_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {pbc_k_point_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_pbc_k_point_weight_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nucleus_index_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nucleus_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nucleus_index_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_shell_ang_mom_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_ang_mom(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_shell_ang_mom_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_shell_factor_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_factor(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_shell_factor_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_r_power_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_r_power(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_r_power_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_start_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_start(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_start_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_size_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_size(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_size_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_shell_index_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_shell_index_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_exponent_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_exponent_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_exponent_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_exponent_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_coefficient_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_coefficient_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_coefficient_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_coefficient_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_oscillation_arg_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_oscillation_arg(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_oscillation_arg_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_prim_factor_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_factor(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_prim_factor_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_radius_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_radius(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_radius_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_phi_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_phi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_phi_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_grad_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_grad(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_grad_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_lap_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_lap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_nao_grid_lap_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_interpolator_phi_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_phi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_interpolator_phi_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_interpolator_grad_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_grad(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_interpolator_grad_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_basis_interpolator_lap_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_lap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_basis_interpolator_lap_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_max_ang_mom_plus_1_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_max_ang_mom_plus_1(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_max_ang_mom_plus_1_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_z_core_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_z_core(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_z_core_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_ang_mom_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_ang_mom(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_ang_mom_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_nucleus_index_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_nucleus_index(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_nucleus_index_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_exponent_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_exponent(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_exponent_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_coefficient_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_coefficient_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ecp_power_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_power(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ecp_power_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_coord_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_num_64(file, &(grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_coord_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_weight_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_num_64(file, &(grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_weight_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_ang_coord_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_ang_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_ang_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_ang_coord_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_ang_weight_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_ang_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_ang_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_ang_weight_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_rad_coord_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_coord(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_rad_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_rad_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_rad_coord_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_grid_rad_weight_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_weight(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t grid_rad_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_rad_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_grid_rad_weight_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_shell_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_shell(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_shell_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_normalization_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_normalization(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_normalization_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_overlap_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_overlap_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_kinetic_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_kinetic_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_potential_n_e_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_potential_n_e_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_ecp_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_ecp_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_core_hamiltonian_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_core_hamiltonian_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_overlap_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_overlap_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_kinetic_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_kinetic_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_potential_n_e_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_potential_n_e_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_ecp_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_ecp_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_core_hamiltonian_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_ao_1e_int_core_hamiltonian_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_coefficient_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;
int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;
if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_coefficient_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_coefficient_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;
int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;
if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_coefficient_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_occupation_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_occupation(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_occupation_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_energy_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_energy(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_energy_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_spin_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_spin(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_spin_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_k_point_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_k_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_k_point_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_overlap_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_overlap_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_kinetic_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_kinetic_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_potential_n_e_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_potential_n_e_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_ecp_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_ecp_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_core_hamiltonian_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_core_hamiltonian_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_overlap_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_overlap_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_kinetic_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_kinetic_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_potential_n_e_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_potential_n_e_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_ecp_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_ecp_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_core_hamiltonian_im_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian_im(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_mo_1e_int_core_hamiltonian_im_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_rdm_1e_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_up_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_up(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_rdm_1e_up_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_dn_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_dn(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_rdm_1e_dn_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_transition_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_transition(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t state_num = 0;
int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_state_num_64(file, &(state_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (state_num == 0L) return TREXIO_INVALID_NUM;
if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 4;
uint64_t dims[4] = {state_num, state_num, mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_rdm_1e_transition_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_en_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_en_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_en_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_en_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_ee_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_ee_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_ee_num_64(file, &(jastrow_ee_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_ee_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_ee_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_ee_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_een_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_een_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_een_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_een_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_en_nucleus_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_nucleus(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_en_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_en_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_en_nucleus_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_een_nucleus_64 (trexio_t* const file, int64_t* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_nucleus(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t jastrow_een_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_een_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_een_nucleus_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_jastrow_en_scaling_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_scaling(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_jastrow_en_scaling_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_qmc_point_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_point(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t qmc_num = 0;
int64_t electron_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_electron_num_64(file, &(electron_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;
if (electron_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 3;
uint64_t dims[3] = {qmc_num, electron_num, 3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_qmc_point_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_qmc_psi_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_psi(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t qmc_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {qmc_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_qmc_psi_64(file, dset_out);
}

trexio_exit_code
trexio_read_safe_qmc_e_loc_64 (trexio_t* const file, double* const dset_out, const int64_t dim_out)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_e_loc(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

int64_t qmc_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {qmc_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_out > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_read_qmc_e_loc_64(file, dset_out);
}

trexio_exit_code
trexio_read_nucleus_charge (trexio_t* const file, double* const nucleus_charge)
{
  return trexio_read_nucleus_charge_64(file, nucleus_charge);
}

trexio_exit_code
trexio_read_nucleus_coord (trexio_t* const file, double* const nucleus_coord)
{
  return trexio_read_nucleus_coord_64(file, nucleus_coord);
}

trexio_exit_code
trexio_read_cell_a (trexio_t* const file, double* const cell_a)
{
  return trexio_read_cell_a_64(file, cell_a);
}

trexio_exit_code
trexio_read_cell_b (trexio_t* const file, double* const cell_b)
{
  return trexio_read_cell_b_64(file, cell_b);
}

trexio_exit_code
trexio_read_cell_c (trexio_t* const file, double* const cell_c)
{
  return trexio_read_cell_c_64(file, cell_c);
}

trexio_exit_code
trexio_read_cell_g_a (trexio_t* const file, double* const cell_g_a)
{
  return trexio_read_cell_g_a_64(file, cell_g_a);
}

trexio_exit_code
trexio_read_cell_g_b (trexio_t* const file, double* const cell_g_b)
{
  return trexio_read_cell_g_b_64(file, cell_g_b);
}

trexio_exit_code
trexio_read_cell_g_c (trexio_t* const file, double* const cell_g_c)
{
  return trexio_read_cell_g_c_64(file, cell_g_c);
}

trexio_exit_code
trexio_read_pbc_k_point (trexio_t* const file, double* const pbc_k_point)
{
  return trexio_read_pbc_k_point_64(file, pbc_k_point);
}

trexio_exit_code
trexio_read_pbc_k_point_weight (trexio_t* const file, double* const pbc_k_point_weight)
{
  return trexio_read_pbc_k_point_weight_64(file, pbc_k_point_weight);
}

trexio_exit_code
trexio_read_basis_nucleus_index (trexio_t* const file, int32_t* const basis_nucleus_index)
{
  return trexio_read_basis_nucleus_index_32(file, basis_nucleus_index);
}

trexio_exit_code
trexio_read_basis_shell_ang_mom (trexio_t* const file, int32_t* const basis_shell_ang_mom)
{
  return trexio_read_basis_shell_ang_mom_32(file, basis_shell_ang_mom);
}

trexio_exit_code
trexio_read_basis_shell_factor (trexio_t* const file, double* const basis_shell_factor)
{
  return trexio_read_basis_shell_factor_64(file, basis_shell_factor);
}

trexio_exit_code
trexio_read_basis_r_power (trexio_t* const file, int32_t* const basis_r_power)
{
  return trexio_read_basis_r_power_32(file, basis_r_power);
}

trexio_exit_code
trexio_read_basis_nao_grid_start (trexio_t* const file, int32_t* const basis_nao_grid_start)
{
  return trexio_read_basis_nao_grid_start_32(file, basis_nao_grid_start);
}

trexio_exit_code
trexio_read_basis_nao_grid_size (trexio_t* const file, int32_t* const basis_nao_grid_size)
{
  return trexio_read_basis_nao_grid_size_32(file, basis_nao_grid_size);
}

trexio_exit_code
trexio_read_basis_shell_index (trexio_t* const file, int32_t* const basis_shell_index)
{
  return trexio_read_basis_shell_index_32(file, basis_shell_index);
}

trexio_exit_code
trexio_read_basis_exponent (trexio_t* const file, double* const basis_exponent)
{
  return trexio_read_basis_exponent_64(file, basis_exponent);
}

trexio_exit_code
trexio_read_basis_exponent_im (trexio_t* const file, double* const basis_exponent_im)
{
  return trexio_read_basis_exponent_im_64(file, basis_exponent_im);
}

trexio_exit_code
trexio_read_basis_coefficient (trexio_t* const file, double* const basis_coefficient)
{
  return trexio_read_basis_coefficient_64(file, basis_coefficient);
}

trexio_exit_code
trexio_read_basis_coefficient_im (trexio_t* const file, double* const basis_coefficient_im)
{
  return trexio_read_basis_coefficient_im_64(file, basis_coefficient_im);
}

trexio_exit_code
trexio_read_basis_oscillation_arg (trexio_t* const file, double* const basis_oscillation_arg)
{
  return trexio_read_basis_oscillation_arg_64(file, basis_oscillation_arg);
}

trexio_exit_code
trexio_read_basis_prim_factor (trexio_t* const file, double* const basis_prim_factor)
{
  return trexio_read_basis_prim_factor_64(file, basis_prim_factor);
}

trexio_exit_code
trexio_read_basis_nao_grid_radius (trexio_t* const file, double* const basis_nao_grid_radius)
{
  return trexio_read_basis_nao_grid_radius_64(file, basis_nao_grid_radius);
}

trexio_exit_code
trexio_read_basis_nao_grid_phi (trexio_t* const file, double* const basis_nao_grid_phi)
{
  return trexio_read_basis_nao_grid_phi_64(file, basis_nao_grid_phi);
}

trexio_exit_code
trexio_read_basis_nao_grid_grad (trexio_t* const file, double* const basis_nao_grid_grad)
{
  return trexio_read_basis_nao_grid_grad_64(file, basis_nao_grid_grad);
}

trexio_exit_code
trexio_read_basis_nao_grid_lap (trexio_t* const file, double* const basis_nao_grid_lap)
{
  return trexio_read_basis_nao_grid_lap_64(file, basis_nao_grid_lap);
}

trexio_exit_code
trexio_read_basis_interpolator_phi (trexio_t* const file, double* const basis_interpolator_phi)
{
  return trexio_read_basis_interpolator_phi_64(file, basis_interpolator_phi);
}

trexio_exit_code
trexio_read_basis_interpolator_grad (trexio_t* const file, double* const basis_interpolator_grad)
{
  return trexio_read_basis_interpolator_grad_64(file, basis_interpolator_grad);
}

trexio_exit_code
trexio_read_basis_interpolator_lap (trexio_t* const file, double* const basis_interpolator_lap)
{
  return trexio_read_basis_interpolator_lap_64(file, basis_interpolator_lap);
}

trexio_exit_code
trexio_read_ecp_max_ang_mom_plus_1 (trexio_t* const file, int32_t* const ecp_max_ang_mom_plus_1)
{
  return trexio_read_ecp_max_ang_mom_plus_1_32(file, ecp_max_ang_mom_plus_1);
}

trexio_exit_code
trexio_read_ecp_z_core (trexio_t* const file, int32_t* const ecp_z_core)
{
  return trexio_read_ecp_z_core_32(file, ecp_z_core);
}

trexio_exit_code
trexio_read_ecp_ang_mom (trexio_t* const file, int32_t* const ecp_ang_mom)
{
  return trexio_read_ecp_ang_mom_32(file, ecp_ang_mom);
}

trexio_exit_code
trexio_read_ecp_nucleus_index (trexio_t* const file, int32_t* const ecp_nucleus_index)
{
  return trexio_read_ecp_nucleus_index_32(file, ecp_nucleus_index);
}

trexio_exit_code
trexio_read_ecp_exponent (trexio_t* const file, double* const ecp_exponent)
{
  return trexio_read_ecp_exponent_64(file, ecp_exponent);
}

trexio_exit_code
trexio_read_ecp_coefficient (trexio_t* const file, double* const ecp_coefficient)
{
  return trexio_read_ecp_coefficient_64(file, ecp_coefficient);
}

trexio_exit_code
trexio_read_ecp_power (trexio_t* const file, int32_t* const ecp_power)
{
  return trexio_read_ecp_power_32(file, ecp_power);
}

trexio_exit_code
trexio_read_grid_coord (trexio_t* const file, double* const grid_coord)
{
  return trexio_read_grid_coord_64(file, grid_coord);
}

trexio_exit_code
trexio_read_grid_weight (trexio_t* const file, double* const grid_weight)
{
  return trexio_read_grid_weight_64(file, grid_weight);
}

trexio_exit_code
trexio_read_grid_ang_coord (trexio_t* const file, double* const grid_ang_coord)
{
  return trexio_read_grid_ang_coord_64(file, grid_ang_coord);
}

trexio_exit_code
trexio_read_grid_ang_weight (trexio_t* const file, double* const grid_ang_weight)
{
  return trexio_read_grid_ang_weight_64(file, grid_ang_weight);
}

trexio_exit_code
trexio_read_grid_rad_coord (trexio_t* const file, double* const grid_rad_coord)
{
  return trexio_read_grid_rad_coord_64(file, grid_rad_coord);
}

trexio_exit_code
trexio_read_grid_rad_weight (trexio_t* const file, double* const grid_rad_weight)
{
  return trexio_read_grid_rad_weight_64(file, grid_rad_weight);
}

trexio_exit_code
trexio_read_ao_shell (trexio_t* const file, int32_t* const ao_shell)
{
  return trexio_read_ao_shell_32(file, ao_shell);
}

trexio_exit_code
trexio_read_ao_normalization (trexio_t* const file, double* const ao_normalization)
{
  return trexio_read_ao_normalization_64(file, ao_normalization);
}

trexio_exit_code
trexio_read_ao_1e_int_overlap (trexio_t* const file, double* const ao_1e_int_overlap)
{
  return trexio_read_ao_1e_int_overlap_64(file, ao_1e_int_overlap);
}

trexio_exit_code
trexio_read_ao_1e_int_kinetic (trexio_t* const file, double* const ao_1e_int_kinetic)
{
  return trexio_read_ao_1e_int_kinetic_64(file, ao_1e_int_kinetic);
}

trexio_exit_code
trexio_read_ao_1e_int_potential_n_e (trexio_t* const file, double* const ao_1e_int_potential_n_e)
{
  return trexio_read_ao_1e_int_potential_n_e_64(file, ao_1e_int_potential_n_e);
}

trexio_exit_code
trexio_read_ao_1e_int_ecp (trexio_t* const file, double* const ao_1e_int_ecp)
{
  return trexio_read_ao_1e_int_ecp_64(file, ao_1e_int_ecp);
}

trexio_exit_code
trexio_read_ao_1e_int_core_hamiltonian (trexio_t* const file, double* const ao_1e_int_core_hamiltonian)
{
  return trexio_read_ao_1e_int_core_hamiltonian_64(file, ao_1e_int_core_hamiltonian);
}

trexio_exit_code
trexio_read_ao_1e_int_overlap_im (trexio_t* const file, double* const ao_1e_int_overlap_im)
{
  return trexio_read_ao_1e_int_overlap_im_64(file, ao_1e_int_overlap_im);
}

trexio_exit_code
trexio_read_ao_1e_int_kinetic_im (trexio_t* const file, double* const ao_1e_int_kinetic_im)
{
  return trexio_read_ao_1e_int_kinetic_im_64(file, ao_1e_int_kinetic_im);
}

trexio_exit_code
trexio_read_ao_1e_int_potential_n_e_im (trexio_t* const file, double* const ao_1e_int_potential_n_e_im)
{
  return trexio_read_ao_1e_int_potential_n_e_im_64(file, ao_1e_int_potential_n_e_im);
}

trexio_exit_code
trexio_read_ao_1e_int_ecp_im (trexio_t* const file, double* const ao_1e_int_ecp_im)
{
  return trexio_read_ao_1e_int_ecp_im_64(file, ao_1e_int_ecp_im);
}

trexio_exit_code
trexio_read_ao_1e_int_core_hamiltonian_im (trexio_t* const file, double* const ao_1e_int_core_hamiltonian_im)
{
  return trexio_read_ao_1e_int_core_hamiltonian_im_64(file, ao_1e_int_core_hamiltonian_im);
}

trexio_exit_code
trexio_read_mo_coefficient (trexio_t* const file, double* const mo_coefficient)
{
  return trexio_read_mo_coefficient_64(file, mo_coefficient);
}

trexio_exit_code
trexio_read_mo_coefficient_im (trexio_t* const file, double* const mo_coefficient_im)
{
  return trexio_read_mo_coefficient_im_64(file, mo_coefficient_im);
}

trexio_exit_code
trexio_read_mo_occupation (trexio_t* const file, double* const mo_occupation)
{
  return trexio_read_mo_occupation_64(file, mo_occupation);
}

trexio_exit_code
trexio_read_mo_energy (trexio_t* const file, double* const mo_energy)
{
  return trexio_read_mo_energy_64(file, mo_energy);
}

trexio_exit_code
trexio_read_mo_spin (trexio_t* const file, int32_t* const mo_spin)
{
  return trexio_read_mo_spin_32(file, mo_spin);
}

trexio_exit_code
trexio_read_mo_k_point (trexio_t* const file, int32_t* const mo_k_point)
{
  return trexio_read_mo_k_point_32(file, mo_k_point);
}

trexio_exit_code
trexio_read_mo_1e_int_overlap (trexio_t* const file, double* const mo_1e_int_overlap)
{
  return trexio_read_mo_1e_int_overlap_64(file, mo_1e_int_overlap);
}

trexio_exit_code
trexio_read_mo_1e_int_kinetic (trexio_t* const file, double* const mo_1e_int_kinetic)
{
  return trexio_read_mo_1e_int_kinetic_64(file, mo_1e_int_kinetic);
}

trexio_exit_code
trexio_read_mo_1e_int_potential_n_e (trexio_t* const file, double* const mo_1e_int_potential_n_e)
{
  return trexio_read_mo_1e_int_potential_n_e_64(file, mo_1e_int_potential_n_e);
}

trexio_exit_code
trexio_read_mo_1e_int_ecp (trexio_t* const file, double* const mo_1e_int_ecp)
{
  return trexio_read_mo_1e_int_ecp_64(file, mo_1e_int_ecp);
}

trexio_exit_code
trexio_read_mo_1e_int_core_hamiltonian (trexio_t* const file, double* const mo_1e_int_core_hamiltonian)
{
  return trexio_read_mo_1e_int_core_hamiltonian_64(file, mo_1e_int_core_hamiltonian);
}

trexio_exit_code
trexio_read_mo_1e_int_overlap_im (trexio_t* const file, double* const mo_1e_int_overlap_im)
{
  return trexio_read_mo_1e_int_overlap_im_64(file, mo_1e_int_overlap_im);
}

trexio_exit_code
trexio_read_mo_1e_int_kinetic_im (trexio_t* const file, double* const mo_1e_int_kinetic_im)
{
  return trexio_read_mo_1e_int_kinetic_im_64(file, mo_1e_int_kinetic_im);
}

trexio_exit_code
trexio_read_mo_1e_int_potential_n_e_im (trexio_t* const file, double* const mo_1e_int_potential_n_e_im)
{
  return trexio_read_mo_1e_int_potential_n_e_im_64(file, mo_1e_int_potential_n_e_im);
}

trexio_exit_code
trexio_read_mo_1e_int_ecp_im (trexio_t* const file, double* const mo_1e_int_ecp_im)
{
  return trexio_read_mo_1e_int_ecp_im_64(file, mo_1e_int_ecp_im);
}

trexio_exit_code
trexio_read_mo_1e_int_core_hamiltonian_im (trexio_t* const file, double* const mo_1e_int_core_hamiltonian_im)
{
  return trexio_read_mo_1e_int_core_hamiltonian_im_64(file, mo_1e_int_core_hamiltonian_im);
}

trexio_exit_code
trexio_read_rdm_1e (trexio_t* const file, double* const rdm_1e)
{
  return trexio_read_rdm_1e_64(file, rdm_1e);
}

trexio_exit_code
trexio_read_rdm_1e_up (trexio_t* const file, double* const rdm_1e_up)
{
  return trexio_read_rdm_1e_up_64(file, rdm_1e_up);
}

trexio_exit_code
trexio_read_rdm_1e_dn (trexio_t* const file, double* const rdm_1e_dn)
{
  return trexio_read_rdm_1e_dn_64(file, rdm_1e_dn);
}

trexio_exit_code
trexio_read_rdm_1e_transition (trexio_t* const file, double* const rdm_1e_transition)
{
  return trexio_read_rdm_1e_transition_64(file, rdm_1e_transition);
}

trexio_exit_code
trexio_read_jastrow_en (trexio_t* const file, double* const jastrow_en)
{
  return trexio_read_jastrow_en_64(file, jastrow_en);
}

trexio_exit_code
trexio_read_jastrow_ee (trexio_t* const file, double* const jastrow_ee)
{
  return trexio_read_jastrow_ee_64(file, jastrow_ee);
}

trexio_exit_code
trexio_read_jastrow_een (trexio_t* const file, double* const jastrow_een)
{
  return trexio_read_jastrow_een_64(file, jastrow_een);
}

trexio_exit_code
trexio_read_jastrow_en_nucleus (trexio_t* const file, int32_t* const jastrow_en_nucleus)
{
  return trexio_read_jastrow_en_nucleus_32(file, jastrow_en_nucleus);
}

trexio_exit_code
trexio_read_jastrow_een_nucleus (trexio_t* const file, int32_t* const jastrow_een_nucleus)
{
  return trexio_read_jastrow_een_nucleus_32(file, jastrow_een_nucleus);
}

trexio_exit_code
trexio_read_jastrow_en_scaling (trexio_t* const file, double* const jastrow_en_scaling)
{
  return trexio_read_jastrow_en_scaling_64(file, jastrow_en_scaling);
}

trexio_exit_code
trexio_read_qmc_point (trexio_t* const file, double* const qmc_point)
{
  return trexio_read_qmc_point_64(file, qmc_point);
}

trexio_exit_code
trexio_read_qmc_psi (trexio_t* const file, double* const qmc_psi)
{
  return trexio_read_qmc_psi_64(file, qmc_psi);
}

trexio_exit_code
trexio_read_qmc_e_loc (trexio_t* const file, double* const qmc_e_loc)
{
  return trexio_read_qmc_e_loc_64(file, qmc_e_loc);
}

trexio_exit_code
trexio_read_safe_nucleus_charge (trexio_t* const file, double* const nucleus_charge, const int64_t dim_out)
{
  return trexio_read_safe_nucleus_charge_64(file, nucleus_charge, dim_out);
}

trexio_exit_code
trexio_read_safe_nucleus_coord (trexio_t* const file, double* const nucleus_coord, const int64_t dim_out)
{
  return trexio_read_safe_nucleus_coord_64(file, nucleus_coord, dim_out);
}

trexio_exit_code
trexio_read_safe_cell_a (trexio_t* const file, double* const cell_a, const int64_t dim_out)
{
  return trexio_read_safe_cell_a_64(file, cell_a, dim_out);
}

trexio_exit_code
trexio_read_safe_cell_b (trexio_t* const file, double* const cell_b, const int64_t dim_out)
{
  return trexio_read_safe_cell_b_64(file, cell_b, dim_out);
}

trexio_exit_code
trexio_read_safe_cell_c (trexio_t* const file, double* const cell_c, const int64_t dim_out)
{
  return trexio_read_safe_cell_c_64(file, cell_c, dim_out);
}

trexio_exit_code
trexio_read_safe_cell_g_a (trexio_t* const file, double* const cell_g_a, const int64_t dim_out)
{
  return trexio_read_safe_cell_g_a_64(file, cell_g_a, dim_out);
}

trexio_exit_code
trexio_read_safe_cell_g_b (trexio_t* const file, double* const cell_g_b, const int64_t dim_out)
{
  return trexio_read_safe_cell_g_b_64(file, cell_g_b, dim_out);
}

trexio_exit_code
trexio_read_safe_cell_g_c (trexio_t* const file, double* const cell_g_c, const int64_t dim_out)
{
  return trexio_read_safe_cell_g_c_64(file, cell_g_c, dim_out);
}

trexio_exit_code
trexio_read_safe_pbc_k_point (trexio_t* const file, double* const pbc_k_point, const int64_t dim_out)
{
  return trexio_read_safe_pbc_k_point_64(file, pbc_k_point, dim_out);
}

trexio_exit_code
trexio_read_safe_pbc_k_point_weight (trexio_t* const file, double* const pbc_k_point_weight, const int64_t dim_out)
{
  return trexio_read_safe_pbc_k_point_weight_64(file, pbc_k_point_weight, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_nucleus_index (trexio_t* const file, int32_t* const basis_nucleus_index, const int64_t dim_out)
{
  return trexio_read_safe_basis_nucleus_index_32(file, basis_nucleus_index, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_shell_ang_mom (trexio_t* const file, int32_t* const basis_shell_ang_mom, const int64_t dim_out)
{
  return trexio_read_safe_basis_shell_ang_mom_32(file, basis_shell_ang_mom, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_shell_factor (trexio_t* const file, double* const basis_shell_factor, const int64_t dim_out)
{
  return trexio_read_safe_basis_shell_factor_64(file, basis_shell_factor, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_r_power (trexio_t* const file, int32_t* const basis_r_power, const int64_t dim_out)
{
  return trexio_read_safe_basis_r_power_32(file, basis_r_power, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_start (trexio_t* const file, int32_t* const basis_nao_grid_start, const int64_t dim_out)
{
  return trexio_read_safe_basis_nao_grid_start_32(file, basis_nao_grid_start, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_size (trexio_t* const file, int32_t* const basis_nao_grid_size, const int64_t dim_out)
{
  return trexio_read_safe_basis_nao_grid_size_32(file, basis_nao_grid_size, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_shell_index (trexio_t* const file, int32_t* const basis_shell_index, const int64_t dim_out)
{
  return trexio_read_safe_basis_shell_index_32(file, basis_shell_index, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_exponent (trexio_t* const file, double* const basis_exponent, const int64_t dim_out)
{
  return trexio_read_safe_basis_exponent_64(file, basis_exponent, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_exponent_im (trexio_t* const file, double* const basis_exponent_im, const int64_t dim_out)
{
  return trexio_read_safe_basis_exponent_im_64(file, basis_exponent_im, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_coefficient (trexio_t* const file, double* const basis_coefficient, const int64_t dim_out)
{
  return trexio_read_safe_basis_coefficient_64(file, basis_coefficient, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_coefficient_im (trexio_t* const file, double* const basis_coefficient_im, const int64_t dim_out)
{
  return trexio_read_safe_basis_coefficient_im_64(file, basis_coefficient_im, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_oscillation_arg (trexio_t* const file, double* const basis_oscillation_arg, const int64_t dim_out)
{
  return trexio_read_safe_basis_oscillation_arg_64(file, basis_oscillation_arg, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_prim_factor (trexio_t* const file, double* const basis_prim_factor, const int64_t dim_out)
{
  return trexio_read_safe_basis_prim_factor_64(file, basis_prim_factor, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_radius (trexio_t* const file, double* const basis_nao_grid_radius, const int64_t dim_out)
{
  return trexio_read_safe_basis_nao_grid_radius_64(file, basis_nao_grid_radius, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_phi (trexio_t* const file, double* const basis_nao_grid_phi, const int64_t dim_out)
{
  return trexio_read_safe_basis_nao_grid_phi_64(file, basis_nao_grid_phi, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_grad (trexio_t* const file, double* const basis_nao_grid_grad, const int64_t dim_out)
{
  return trexio_read_safe_basis_nao_grid_grad_64(file, basis_nao_grid_grad, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_nao_grid_lap (trexio_t* const file, double* const basis_nao_grid_lap, const int64_t dim_out)
{
  return trexio_read_safe_basis_nao_grid_lap_64(file, basis_nao_grid_lap, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_interpolator_phi (trexio_t* const file, double* const basis_interpolator_phi, const int64_t dim_out)
{
  return trexio_read_safe_basis_interpolator_phi_64(file, basis_interpolator_phi, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_interpolator_grad (trexio_t* const file, double* const basis_interpolator_grad, const int64_t dim_out)
{
  return trexio_read_safe_basis_interpolator_grad_64(file, basis_interpolator_grad, dim_out);
}

trexio_exit_code
trexio_read_safe_basis_interpolator_lap (trexio_t* const file, double* const basis_interpolator_lap, const int64_t dim_out)
{
  return trexio_read_safe_basis_interpolator_lap_64(file, basis_interpolator_lap, dim_out);
}

trexio_exit_code
trexio_read_safe_ecp_max_ang_mom_plus_1 (trexio_t* const file, int32_t* const ecp_max_ang_mom_plus_1, const int64_t dim_out)
{
  return trexio_read_safe_ecp_max_ang_mom_plus_1_32(file, ecp_max_ang_mom_plus_1, dim_out);
}

trexio_exit_code
trexio_read_safe_ecp_z_core (trexio_t* const file, int32_t* const ecp_z_core, const int64_t dim_out)
{
  return trexio_read_safe_ecp_z_core_32(file, ecp_z_core, dim_out);
}

trexio_exit_code
trexio_read_safe_ecp_ang_mom (trexio_t* const file, int32_t* const ecp_ang_mom, const int64_t dim_out)
{
  return trexio_read_safe_ecp_ang_mom_32(file, ecp_ang_mom, dim_out);
}

trexio_exit_code
trexio_read_safe_ecp_nucleus_index (trexio_t* const file, int32_t* const ecp_nucleus_index, const int64_t dim_out)
{
  return trexio_read_safe_ecp_nucleus_index_32(file, ecp_nucleus_index, dim_out);
}

trexio_exit_code
trexio_read_safe_ecp_exponent (trexio_t* const file, double* const ecp_exponent, const int64_t dim_out)
{
  return trexio_read_safe_ecp_exponent_64(file, ecp_exponent, dim_out);
}

trexio_exit_code
trexio_read_safe_ecp_coefficient (trexio_t* const file, double* const ecp_coefficient, const int64_t dim_out)
{
  return trexio_read_safe_ecp_coefficient_64(file, ecp_coefficient, dim_out);
}

trexio_exit_code
trexio_read_safe_ecp_power (trexio_t* const file, int32_t* const ecp_power, const int64_t dim_out)
{
  return trexio_read_safe_ecp_power_32(file, ecp_power, dim_out);
}

trexio_exit_code
trexio_read_safe_grid_coord (trexio_t* const file, double* const grid_coord, const int64_t dim_out)
{
  return trexio_read_safe_grid_coord_64(file, grid_coord, dim_out);
}

trexio_exit_code
trexio_read_safe_grid_weight (trexio_t* const file, double* const grid_weight, const int64_t dim_out)
{
  return trexio_read_safe_grid_weight_64(file, grid_weight, dim_out);
}

trexio_exit_code
trexio_read_safe_grid_ang_coord (trexio_t* const file, double* const grid_ang_coord, const int64_t dim_out)
{
  return trexio_read_safe_grid_ang_coord_64(file, grid_ang_coord, dim_out);
}

trexio_exit_code
trexio_read_safe_grid_ang_weight (trexio_t* const file, double* const grid_ang_weight, const int64_t dim_out)
{
  return trexio_read_safe_grid_ang_weight_64(file, grid_ang_weight, dim_out);
}

trexio_exit_code
trexio_read_safe_grid_rad_coord (trexio_t* const file, double* const grid_rad_coord, const int64_t dim_out)
{
  return trexio_read_safe_grid_rad_coord_64(file, grid_rad_coord, dim_out);
}

trexio_exit_code
trexio_read_safe_grid_rad_weight (trexio_t* const file, double* const grid_rad_weight, const int64_t dim_out)
{
  return trexio_read_safe_grid_rad_weight_64(file, grid_rad_weight, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_shell (trexio_t* const file, int32_t* const ao_shell, const int64_t dim_out)
{
  return trexio_read_safe_ao_shell_32(file, ao_shell, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_normalization (trexio_t* const file, double* const ao_normalization, const int64_t dim_out)
{
  return trexio_read_safe_ao_normalization_64(file, ao_normalization, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_overlap (trexio_t* const file, double* const ao_1e_int_overlap, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_overlap_64(file, ao_1e_int_overlap, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_kinetic (trexio_t* const file, double* const ao_1e_int_kinetic, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_kinetic_64(file, ao_1e_int_kinetic, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_potential_n_e (trexio_t* const file, double* const ao_1e_int_potential_n_e, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_potential_n_e_64(file, ao_1e_int_potential_n_e, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_ecp (trexio_t* const file, double* const ao_1e_int_ecp, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_ecp_64(file, ao_1e_int_ecp, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_core_hamiltonian (trexio_t* const file, double* const ao_1e_int_core_hamiltonian, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_core_hamiltonian_64(file, ao_1e_int_core_hamiltonian, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_overlap_im (trexio_t* const file, double* const ao_1e_int_overlap_im, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_overlap_im_64(file, ao_1e_int_overlap_im, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_kinetic_im (trexio_t* const file, double* const ao_1e_int_kinetic_im, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_kinetic_im_64(file, ao_1e_int_kinetic_im, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_potential_n_e_im (trexio_t* const file, double* const ao_1e_int_potential_n_e_im, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_potential_n_e_im_64(file, ao_1e_int_potential_n_e_im, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_ecp_im (trexio_t* const file, double* const ao_1e_int_ecp_im, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_ecp_im_64(file, ao_1e_int_ecp_im, dim_out);
}

trexio_exit_code
trexio_read_safe_ao_1e_int_core_hamiltonian_im (trexio_t* const file, double* const ao_1e_int_core_hamiltonian_im, const int64_t dim_out)
{
  return trexio_read_safe_ao_1e_int_core_hamiltonian_im_64(file, ao_1e_int_core_hamiltonian_im, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_coefficient (trexio_t* const file, double* const mo_coefficient, const int64_t dim_out)
{
  return trexio_read_safe_mo_coefficient_64(file, mo_coefficient, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_coefficient_im (trexio_t* const file, double* const mo_coefficient_im, const int64_t dim_out)
{
  return trexio_read_safe_mo_coefficient_im_64(file, mo_coefficient_im, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_occupation (trexio_t* const file, double* const mo_occupation, const int64_t dim_out)
{
  return trexio_read_safe_mo_occupation_64(file, mo_occupation, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_energy (trexio_t* const file, double* const mo_energy, const int64_t dim_out)
{
  return trexio_read_safe_mo_energy_64(file, mo_energy, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_spin (trexio_t* const file, int32_t* const mo_spin, const int64_t dim_out)
{
  return trexio_read_safe_mo_spin_32(file, mo_spin, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_k_point (trexio_t* const file, int32_t* const mo_k_point, const int64_t dim_out)
{
  return trexio_read_safe_mo_k_point_32(file, mo_k_point, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_overlap (trexio_t* const file, double* const mo_1e_int_overlap, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_overlap_64(file, mo_1e_int_overlap, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_kinetic (trexio_t* const file, double* const mo_1e_int_kinetic, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_kinetic_64(file, mo_1e_int_kinetic, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_potential_n_e (trexio_t* const file, double* const mo_1e_int_potential_n_e, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_potential_n_e_64(file, mo_1e_int_potential_n_e, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_ecp (trexio_t* const file, double* const mo_1e_int_ecp, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_ecp_64(file, mo_1e_int_ecp, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_core_hamiltonian (trexio_t* const file, double* const mo_1e_int_core_hamiltonian, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_core_hamiltonian_64(file, mo_1e_int_core_hamiltonian, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_overlap_im (trexio_t* const file, double* const mo_1e_int_overlap_im, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_overlap_im_64(file, mo_1e_int_overlap_im, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_kinetic_im (trexio_t* const file, double* const mo_1e_int_kinetic_im, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_kinetic_im_64(file, mo_1e_int_kinetic_im, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_potential_n_e_im (trexio_t* const file, double* const mo_1e_int_potential_n_e_im, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_potential_n_e_im_64(file, mo_1e_int_potential_n_e_im, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_ecp_im (trexio_t* const file, double* const mo_1e_int_ecp_im, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_ecp_im_64(file, mo_1e_int_ecp_im, dim_out);
}

trexio_exit_code
trexio_read_safe_mo_1e_int_core_hamiltonian_im (trexio_t* const file, double* const mo_1e_int_core_hamiltonian_im, const int64_t dim_out)
{
  return trexio_read_safe_mo_1e_int_core_hamiltonian_im_64(file, mo_1e_int_core_hamiltonian_im, dim_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e (trexio_t* const file, double* const rdm_1e, const int64_t dim_out)
{
  return trexio_read_safe_rdm_1e_64(file, rdm_1e, dim_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_up (trexio_t* const file, double* const rdm_1e_up, const int64_t dim_out)
{
  return trexio_read_safe_rdm_1e_up_64(file, rdm_1e_up, dim_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_dn (trexio_t* const file, double* const rdm_1e_dn, const int64_t dim_out)
{
  return trexio_read_safe_rdm_1e_dn_64(file, rdm_1e_dn, dim_out);
}

trexio_exit_code
trexio_read_safe_rdm_1e_transition (trexio_t* const file, double* const rdm_1e_transition, const int64_t dim_out)
{
  return trexio_read_safe_rdm_1e_transition_64(file, rdm_1e_transition, dim_out);
}

trexio_exit_code
trexio_read_safe_jastrow_en (trexio_t* const file, double* const jastrow_en, const int64_t dim_out)
{
  return trexio_read_safe_jastrow_en_64(file, jastrow_en, dim_out);
}

trexio_exit_code
trexio_read_safe_jastrow_ee (trexio_t* const file, double* const jastrow_ee, const int64_t dim_out)
{
  return trexio_read_safe_jastrow_ee_64(file, jastrow_ee, dim_out);
}

trexio_exit_code
trexio_read_safe_jastrow_een (trexio_t* const file, double* const jastrow_een, const int64_t dim_out)
{
  return trexio_read_safe_jastrow_een_64(file, jastrow_een, dim_out);
}

trexio_exit_code
trexio_read_safe_jastrow_en_nucleus (trexio_t* const file, int32_t* const jastrow_en_nucleus, const int64_t dim_out)
{
  return trexio_read_safe_jastrow_en_nucleus_32(file, jastrow_en_nucleus, dim_out);
}

trexio_exit_code
trexio_read_safe_jastrow_een_nucleus (trexio_t* const file, int32_t* const jastrow_een_nucleus, const int64_t dim_out)
{
  return trexio_read_safe_jastrow_een_nucleus_32(file, jastrow_een_nucleus, dim_out);
}

trexio_exit_code
trexio_read_safe_jastrow_en_scaling (trexio_t* const file, double* const jastrow_en_scaling, const int64_t dim_out)
{
  return trexio_read_safe_jastrow_en_scaling_64(file, jastrow_en_scaling, dim_out);
}

trexio_exit_code
trexio_read_safe_qmc_point (trexio_t* const file, double* const qmc_point, const int64_t dim_out)
{
  return trexio_read_safe_qmc_point_64(file, qmc_point, dim_out);
}

trexio_exit_code
trexio_read_safe_qmc_psi (trexio_t* const file, double* const qmc_psi, const int64_t dim_out)
{
  return trexio_read_safe_qmc_psi_64(file, qmc_psi, dim_out);
}

trexio_exit_code
trexio_read_safe_qmc_e_loc (trexio_t* const file, double* const qmc_e_loc, const int64_t dim_out)
{
  return trexio_read_safe_qmc_e_loc_64(file, qmc_e_loc, dim_out);
}

trexio_exit_code trexio_read_safe_ao_2e_int_eri(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_ao_2e_int_eri(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_ao_2e_int_eri(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_ao_2e_int_eri(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_ao_2e_int_eri_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_ao_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_2e_int_eri(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_2e_int_eri(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_ao_2e_int_eri(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_ao_2e_int_eri_lr(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_ao_2e_int_eri_lr(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_ao_2e_int_eri_lr(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_ao_2e_int_eri_lr(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_ao_2e_int_eri_lr_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_ao_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_2e_int_eri_lr(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_2e_int_eri_lr(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_ao_2e_int_eri_lr(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_ao_2e_int_eri_cholesky(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_ao_2e_int_eri_cholesky(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_ao_2e_int_eri_cholesky(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_ao_2e_int_eri_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 3;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_ao_2e_int_eri_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_ao_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_2e_int_eri_cholesky_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_2e_int_eri_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_2e_int_eri_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_ao_2e_int_eri_cholesky(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_ao_2e_int_eri_lr_cholesky(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_ao_2e_int_eri_lr_cholesky(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_ao_2e_int_eri_lr_cholesky(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_ao_2e_int_eri_lr_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 3;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_ao_2e_int_eri_lr_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_ao_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_2e_int_eri_lr_cholesky_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_ao_2e_int_eri_lr_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_ao_2e_int_eri_lr_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_ao_2e_int_eri_lr_cholesky(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_mo_2e_int_eri(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_mo_2e_int_eri(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_mo_2e_int_eri(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_mo_2e_int_eri(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_mo_2e_int_eri_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_2e_int_eri(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_2e_int_eri(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_mo_2e_int_eri(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_mo_2e_int_eri_lr(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_mo_2e_int_eri_lr(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_mo_2e_int_eri_lr(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_mo_2e_int_eri_lr(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_mo_2e_int_eri_lr_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_2e_int_eri_lr(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_2e_int_eri_lr(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_mo_2e_int_eri_lr(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_mo_2e_int_eri_cholesky(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_mo_2e_int_eri_cholesky(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_mo_2e_int_eri_cholesky(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_mo_2e_int_eri_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 3;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_mo_2e_int_eri_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_2e_int_eri_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_2e_int_eri_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_2e_int_eri_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_mo_2e_int_eri_cholesky(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_mo_2e_int_eri_lr_cholesky(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_mo_2e_int_eri_lr_cholesky(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_mo_2e_int_eri_lr_cholesky(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_mo_2e_int_eri_lr_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 3;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_mo_2e_int_eri_lr_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_2e_int_eri_lr_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_mo_2e_int_eri_lr_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_mo_2e_int_eri_lr_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_mo_2e_int_eri_lr_cholesky(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_csf_det_coefficient(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 2;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_csf_det_coefficient(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_csf_det_coefficient(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_csf_det_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 2;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_csf_det_coefficient_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_determinant_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_csf_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_csf_det_coefficient(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_csf_det_coefficient(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_csf_det_coefficient(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_amplitude_single(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 2;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_amplitude_single(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_amplitude_single(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_amplitude_single(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 2;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_single_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_amplitude_single(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_amplitude_single(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_single(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_amplitude_single_exp(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 2;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_amplitude_single_exp(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_amplitude_single_exp(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_amplitude_single_exp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 2;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_single_exp_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_amplitude_single_exp(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_amplitude_single_exp(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_single_exp(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_amplitude_double(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_amplitude_double(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_amplitude_double(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_amplitude_double(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_double_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_amplitude_double(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_amplitude_double(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_double(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_amplitude_double_exp(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_amplitude_double_exp(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_amplitude_double_exp(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_amplitude_double_exp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_double_exp_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_amplitude_double_exp(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_amplitude_double_exp(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_double_exp(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_amplitude_triple(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 6;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_amplitude_triple(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_amplitude_triple(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_amplitude_triple(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 6;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_triple_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_amplitude_triple(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_amplitude_triple(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_triple(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_amplitude_triple_exp(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 6;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_amplitude_triple_exp(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_amplitude_triple_exp(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_amplitude_triple_exp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 6;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_triple_exp_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_amplitude_triple_exp(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_amplitude_triple_exp(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_triple_exp(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_amplitude_quadruple(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 8;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_amplitude_quadruple(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_amplitude_quadruple(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_amplitude_quadruple(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 8;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_quadruple_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_amplitude_quadruple(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_amplitude_quadruple(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_quadruple(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_amplitude_quadruple_exp(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 8;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_amplitude_quadruple_exp(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_amplitude_quadruple_exp(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_amplitude_quadruple_exp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 8;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_quadruple_exp_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_amplitude_quadruple_exp(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_amplitude_quadruple_exp(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_quadruple_exp(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_rdm_2e(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_rdm_2e(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_rdm_2e(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_rdm_2e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_rdm_2e_upup(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_rdm_2e_upup(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_rdm_2e_upup(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_rdm_2e_upup(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_upup_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_upup(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_upup(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_upup(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_rdm_2e_dndn(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_rdm_2e_dndn(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_rdm_2e_dndn(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_rdm_2e_dndn(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_dndn_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_dndn(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_dndn(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_dndn(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_rdm_2e_updn(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_rdm_2e_updn(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_rdm_2e_updn(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_rdm_2e_updn(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 4;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_updn_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_updn(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_updn(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_updn(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_rdm_2e_transition(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 6;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_rdm_2e_transition(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_rdm_2e_transition(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_rdm_2e_transition(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 6;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_transition_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_state_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_transition(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_transition(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_transition(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_rdm_2e_cholesky(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_rdm_2e_cholesky(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_rdm_2e_cholesky(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_rdm_2e_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 3;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_rdm_2e_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_cholesky(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_rdm_2e_upup_cholesky(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_rdm_2e_upup_cholesky(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_rdm_2e_upup_cholesky(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_rdm_2e_upup_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 3;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_upup_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_rdm_2e_upup_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_upup_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_upup_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_upup_cholesky(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_rdm_2e_dndn_cholesky(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_rdm_2e_dndn_cholesky(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_rdm_2e_dndn_cholesky(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_rdm_2e_dndn_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 3;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_dndn_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_rdm_2e_dndn_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_dndn_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_dndn_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_dndn_cholesky(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code trexio_read_safe_rdm_2e_updn_cholesky(trexio_t* const file,
                                               const int64_t offset_file,
                                               int64_t* const buffer_size_read,
                                               int32_t* const index_sparse_read,
                                               const int64_t size_index_read,
                                               double* const value_sparse_read,
                                               const int64_t size_value_read
                                               )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_read < rank * (*buffer_size_read)) return TREXIO_INVALID_ARG_5;
  if (size_value_read <        (*buffer_size_read)) return TREXIO_INVALID_ARG_7;

  return trexio_read_rdm_2e_updn_cholesky(file, offset_file, buffer_size_read, index_sparse_read, value_sparse_read);
}

trexio_exit_code
trexio_read_rdm_2e_updn_cholesky(trexio_t* const file,
                         const int64_t offset_file,
                         int64_t* const buffer_size,
                         int32_t* const index_sparse,
                         double* const value_sparse
                         )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (*buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;
  if (trexio_has_rdm_2e_updn_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  const uint32_t rank = 3;  // To be set by generator : number of indices

  int64_t size_max;         // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_updn_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS) return rc;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_rdm_2e_updn_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_rdm_2e_updn_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_rdm_2e_updn_cholesky(file, offset_file, *buffer_size, max_dim, &eof_read_size, index_sparse, value_sparse);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_updn_cholesky(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size = eof_read_size;

  // shift indices to be one-based if Fortran API is used
  if (file->one_based) {
    // if EOF is reached - shift only indices that have been read, not an entire buffer
    uint64_t index_size = rank*(*buffer_size) ;
    for (uint64_t i=0; i<index_size; ++i){
      index_sparse[i] += 1;
    }
  }

  return rc;
}

trexio_exit_code
trexio_read_ao_2e_int_eri_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_2e_int_eri(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_ao_2e_int_eri_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_ao_2e_int_eri_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_ao_2e_int_eri_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_ao_2e_int_eri_lr_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_2e_int_eri_lr(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_ao_2e_int_eri_lr_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_ao_2e_int_eri_lr_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_ao_2e_int_eri_lr_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_ao_2e_int_eri_cholesky_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_2e_int_eri_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_ao_2e_int_eri_cholesky_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_ao_2e_int_eri_cholesky_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_ao_2e_int_eri_cholesky_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_ao_2e_int_eri_lr_cholesky_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_2e_int_eri_lr_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_ao_2e_int_eri_lr_cholesky_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_ao_2e_int_eri_lr_cholesky_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_ao_2e_int_eri_lr_cholesky_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_mo_2e_int_eri_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_2e_int_eri(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_mo_2e_int_eri_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_mo_2e_int_eri_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_mo_2e_int_eri_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_mo_2e_int_eri_lr_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_2e_int_eri_lr(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_mo_2e_int_eri_lr_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_mo_2e_int_eri_lr_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_mo_2e_int_eri_lr_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_mo_2e_int_eri_cholesky_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_2e_int_eri_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_mo_2e_int_eri_cholesky_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_mo_2e_int_eri_cholesky_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_mo_2e_int_eri_cholesky_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_mo_2e_int_eri_lr_cholesky_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_2e_int_eri_lr_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_mo_2e_int_eri_lr_cholesky_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_mo_2e_int_eri_lr_cholesky_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_mo_2e_int_eri_lr_cholesky_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_csf_det_coefficient_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_csf_det_coefficient(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_csf_det_coefficient_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_csf_det_coefficient_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_csf_det_coefficient_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_amplitude_single_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_amplitude_single(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_amplitude_single_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_amplitude_single_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_single_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_amplitude_single_exp_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_amplitude_single_exp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_amplitude_single_exp_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_amplitude_single_exp_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_single_exp_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_amplitude_double_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_amplitude_double(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_amplitude_double_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_amplitude_double_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_double_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_amplitude_double_exp_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_amplitude_double_exp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_amplitude_double_exp_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_amplitude_double_exp_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_double_exp_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_amplitude_triple_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_amplitude_triple(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_amplitude_triple_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_amplitude_triple_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_triple_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_amplitude_triple_exp_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_amplitude_triple_exp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_amplitude_triple_exp_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_amplitude_triple_exp_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_triple_exp_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_amplitude_quadruple_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_amplitude_quadruple(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_amplitude_quadruple_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_amplitude_quadruple_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_quadruple_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_amplitude_quadruple_exp_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_amplitude_quadruple_exp(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_amplitude_quadruple_exp_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_amplitude_quadruple_exp_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_amplitude_quadruple_exp_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_rdm_2e_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_rdm_2e_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_rdm_2e_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_rdm_2e_upup_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_upup(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_rdm_2e_upup_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_rdm_2e_upup_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_upup_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_rdm_2e_dndn_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_dndn(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_rdm_2e_dndn_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_rdm_2e_dndn_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_dndn_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_rdm_2e_updn_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_updn(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_rdm_2e_updn_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_rdm_2e_updn_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_updn_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_rdm_2e_transition_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_transition(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_rdm_2e_transition_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_rdm_2e_transition_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_transition_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_rdm_2e_cholesky_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_rdm_2e_cholesky_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_rdm_2e_cholesky_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_cholesky_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_rdm_2e_upup_cholesky_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_upup_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_rdm_2e_upup_cholesky_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_rdm_2e_upup_cholesky_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_upup_cholesky_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_rdm_2e_dndn_cholesky_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_dndn_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_rdm_2e_dndn_cholesky_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_rdm_2e_dndn_cholesky_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_dndn_cholesky_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_rdm_2e_updn_cholesky_size(trexio_t* const file, int64_t* const size_max)
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (size_max == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_2e_updn_cholesky(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_rdm_2e_updn_cholesky_size(file, size_max);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_rdm_2e_updn_cholesky_size(file, size_max);
    break;
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_rdm_2e_updn_cholesky_size(...);
    break;
*/
  default:
    return TREXIO_FAILURE;  /* Impossible case */
  }
}

trexio_exit_code
trexio_read_metadata_code_low (trexio_t* const file, char* dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_code(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t metadata_code_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_metadata_code_num_64(file, &(metadata_code_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (metadata_code_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {metadata_code_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);
  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_metadata_code(file, dset_out, rank, dims, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_metadata_code(file, dset_out, rank, dims, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_metadata_code(file, dset_out, rank, dims);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_metadata_code (trexio_t* const file, char** dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_code(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_metadata_code_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*(max_str_len+1) + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  rc = trexio_read_metadata_code_low(file, str_compiled, max_str_len);
  if (rc != TREXIO_SUCCESS) {
    FREE(str_compiled);
    return rc;
  }

  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {

    char * pch;
    pch = i == 0 ? strtok(str_compiled, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;
    if (pch == NULL) {
      FREE(str_compiled);
      return TREXIO_FAILURE;
    }

    strcpy(dset_out[i], "");
    strcat(dset_out[i], pch);

  }

  FREE(str_compiled);
  return TREXIO_SUCCESS;

}

trexio_exit_code
trexio_read_metadata_author_low (trexio_t* const file, char* dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_author(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t metadata_author_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_metadata_author_num_64(file, &(metadata_author_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (metadata_author_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {metadata_author_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);
  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_metadata_author(file, dset_out, rank, dims, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_metadata_author(file, dset_out, rank, dims, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_metadata_author(file, dset_out, rank, dims);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_metadata_author (trexio_t* const file, char** dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_author(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_metadata_author_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*(max_str_len+1) + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  rc = trexio_read_metadata_author_low(file, str_compiled, max_str_len);
  if (rc != TREXIO_SUCCESS) {
    FREE(str_compiled);
    return rc;
  }

  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {

    char * pch;
    pch = i == 0 ? strtok(str_compiled, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;
    if (pch == NULL) {
      FREE(str_compiled);
      return TREXIO_FAILURE;
    }

    strcpy(dset_out[i], "");
    strcat(dset_out[i], pch);

  }

  FREE(str_compiled);
  return TREXIO_SUCCESS;

}

trexio_exit_code
trexio_read_nucleus_label_low (trexio_t* const file, char* dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_nucleus_label(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t nucleus_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);
  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_nucleus_label(file, dset_out, rank, dims, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_nucleus_label(file, dset_out, rank, dims, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_nucleus_label(file, dset_out, rank, dims);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_nucleus_label (trexio_t* const file, char** dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_nucleus_label(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_nucleus_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*(max_str_len+1) + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  rc = trexio_read_nucleus_label_low(file, str_compiled, max_str_len);
  if (rc != TREXIO_SUCCESS) {
    FREE(str_compiled);
    return rc;
  }

  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {

    char * pch;
    pch = i == 0 ? strtok(str_compiled, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;
    if (pch == NULL) {
      FREE(str_compiled);
      return TREXIO_FAILURE;
    }

    strcpy(dset_out[i], "");
    strcat(dset_out[i], pch);

  }

  FREE(str_compiled);
  return TREXIO_SUCCESS;

}

trexio_exit_code
trexio_read_state_label_low (trexio_t* const file, char* dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_label(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t state_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_state_num_64(file, &(state_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (state_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {state_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);
  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_state_label(file, dset_out, rank, dims, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_state_label(file, dset_out, rank, dims, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_state_label(file, dset_out, rank, dims);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_state_label (trexio_t* const file, char** dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_label(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_state_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*(max_str_len+1) + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  rc = trexio_read_state_label_low(file, str_compiled, max_str_len);
  if (rc != TREXIO_SUCCESS) {
    FREE(str_compiled);
    return rc;
  }

  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {

    char * pch;
    pch = i == 0 ? strtok(str_compiled, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;
    if (pch == NULL) {
      FREE(str_compiled);
      return TREXIO_FAILURE;
    }

    strcpy(dset_out[i], "");
    strcat(dset_out[i], pch);

  }

  FREE(str_compiled);
  return TREXIO_SUCCESS;

}

trexio_exit_code
trexio_read_state_file_name_low (trexio_t* const file, char* dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_file_name(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t state_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_state_num_64(file, &(state_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (state_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {state_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);
  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_state_file_name(file, dset_out, rank, dims, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_state_file_name(file, dset_out, rank, dims, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_state_file_name(file, dset_out, rank, dims);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_state_file_name (trexio_t* const file, char** dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_file_name(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_state_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*(max_str_len+1) + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  rc = trexio_read_state_file_name_low(file, str_compiled, max_str_len);
  if (rc != TREXIO_SUCCESS) {
    FREE(str_compiled);
    return rc;
  }

  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {

    char * pch;
    pch = i == 0 ? strtok(str_compiled, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;
    if (pch == NULL) {
      FREE(str_compiled);
      return TREXIO_FAILURE;
    }

    strcpy(dset_out[i], "");
    strcat(dset_out[i], pch);

  }

  FREE(str_compiled);
  return TREXIO_SUCCESS;

}

trexio_exit_code
trexio_read_mo_class_low (trexio_t* const file, char* dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_class(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);
  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_mo_class(file, dset_out, rank, dims, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_mo_class(file, dset_out, rank, dims, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_class(file, dset_out, rank, dims);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_mo_class (trexio_t* const file, char** dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_class(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_mo_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*(max_str_len+1) + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  rc = trexio_read_mo_class_low(file, str_compiled, max_str_len);
  if (rc != TREXIO_SUCCESS) {
    FREE(str_compiled);
    return rc;
  }

  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {

    char * pch;
    pch = i == 0 ? strtok(str_compiled, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;
    if (pch == NULL) {
      FREE(str_compiled);
      return TREXIO_FAILURE;
    }

    strcpy(dset_out[i], "");
    strcat(dset_out[i], pch);

  }

  FREE(str_compiled);
  return TREXIO_SUCCESS;

}

trexio_exit_code
trexio_read_mo_symmetry_low (trexio_t* const file, char* dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_symmetry(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  int64_t mo_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);
  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_read_mo_symmetry(file, dset_out, rank, dims, (uint32_t) max_str_len);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_read_mo_symmetry(file, dset_out, rank, dims, (uint32_t) max_str_len);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_mo_symmetry(file, dset_out, rank, dims);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_read_mo_symmetry (trexio_t* const file, char** dset_out, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_out == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_symmetry(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_mo_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*(max_str_len+1) + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  rc = trexio_read_mo_symmetry_low(file, str_compiled, max_str_len);
  if (rc != TREXIO_SUCCESS) {
    FREE(str_compiled);
    return rc;
  }

  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {

    char * pch;
    pch = i == 0 ? strtok(str_compiled, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;
    if (pch == NULL) {
      FREE(str_compiled);
      return TREXIO_FAILURE;
    }

    strcpy(dset_out[i], "");
    strcat(dset_out[i], pch);

  }

  FREE(str_compiled);
  return TREXIO_SUCCESS;

}

trexio_exit_code
trexio_write_metadata_code_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_metadata_code_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_metadata_code_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_metadata_code_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_metadata_code_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_metadata_author_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_metadata_author_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_metadata_author_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_metadata_author_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_metadata_author_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_metadata_unsafe_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_metadata_unsafe(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_metadata_unsafe(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_metadata_unsafe(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_metadata_unsafe(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_nucleus_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_nucleus_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_nucleus_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_nucleus_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_nucleus_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_nucleus_repulsion_32 (trexio_t* const file, const float num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_nucleus_repulsion(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  float num_write = num;
  if ((false)) {
    num_write -= (float) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_nucleus_repulsion(file, (double) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_nucleus_repulsion(file, (double) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_nucleus_repulsion(file, (double) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_cell_two_pi_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_cell_two_pi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_cell_two_pi(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_cell_two_pi(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_cell_two_pi(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_pbc_periodic_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_pbc_periodic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_pbc_periodic(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_pbc_periodic(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_pbc_periodic(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_pbc_k_point_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_pbc_k_point_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_pbc_k_point_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_pbc_k_point_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_pbc_k_point_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_pbc_madelung_32 (trexio_t* const file, const float num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_pbc_madelung(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  float num_write = num;
  if ((false)) {
    num_write -= (float) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_pbc_madelung(file, (double) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_pbc_madelung(file, (double) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_pbc_madelung(file, (double) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_electron_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_electron_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_electron_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_electron_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_electron_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_electron_up_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_electron_up_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_electron_up_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_electron_up_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_electron_up_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_electron_dn_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_electron_dn_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_electron_dn_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_electron_dn_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_electron_dn_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_state_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_state_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_state_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_state_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_state_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_state_id_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_state_id(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if (file->one_based) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_state_id(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_state_id(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_state_id(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_state_energy_32 (trexio_t* const file, const float num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_state_energy(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  float num_write = num;
  if ((false)) {
    num_write -= (float) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_state_energy(file, (double) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_state_energy(file, (double) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_state_energy(file, (double) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_prim_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_basis_prim_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_prim_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_prim_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_prim_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_shell_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_basis_shell_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_shell_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_shell_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_shell_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_nao_grid_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_basis_nao_grid_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_nao_grid_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_nao_grid_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_nao_grid_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_interp_coeff_cnt_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_basis_interp_coeff_cnt(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_interp_coeff_cnt(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_interp_coeff_cnt(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_interp_coeff_cnt(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_e_cut_32 (trexio_t* const file, const float num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_basis_e_cut(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  float num_write = num;
  if ((false)) {
    num_write -= (float) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_e_cut(file, (double) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_e_cut(file, (double) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_e_cut(file, (double) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ecp_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_ecp_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ecp_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ecp_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ecp_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_rad_precision_32 (trexio_t* const file, const float num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_grid_rad_precision(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  float num_write = num;
  if ((false)) {
    num_write -= (float) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_rad_precision(file, (double) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_rad_precision(file, (double) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_rad_precision(file, (double) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_grid_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_max_ang_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_grid_max_ang_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_max_ang_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_max_ang_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_max_ang_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_min_ang_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_grid_min_ang_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_min_ang_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_min_ang_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_min_ang_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_ang_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_grid_ang_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_ang_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_ang_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_ang_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_rad_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_grid_rad_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_rad_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_rad_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_rad_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ao_cartesian_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_ao_cartesian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ao_cartesian(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ao_cartesian(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ao_cartesian(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ao_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_ao_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ao_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ao_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ao_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ao_2e_int_eri_cholesky_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_ao_2e_int_eri_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ao_2e_int_eri_cholesky_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ao_2e_int_eri_cholesky_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ao_2e_int_eri_cholesky_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ao_2e_int_eri_lr_cholesky_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_ao_2e_int_eri_lr_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ao_2e_int_eri_lr_cholesky_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ao_2e_int_eri_lr_cholesky_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ao_2e_int_eri_lr_cholesky_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_mo_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_mo_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_mo_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_mo_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_mo_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_mo_2e_int_eri_cholesky_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_mo_2e_int_eri_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_mo_2e_int_eri_cholesky_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_mo_2e_int_eri_cholesky_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_mo_2e_int_eri_cholesky_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_mo_2e_int_eri_lr_cholesky_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_mo_2e_int_eri_lr_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_mo_2e_int_eri_lr_cholesky_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_mo_2e_int_eri_lr_cholesky_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_mo_2e_int_eri_lr_cholesky_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_determinant_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_determinant_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_determinant_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_determinant_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_determinant_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_csf_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_csf_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_csf_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_csf_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_csf_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_rdm_2e_cholesky_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_rdm_2e_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_rdm_2e_cholesky_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_rdm_2e_cholesky_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_rdm_2e_cholesky_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_rdm_2e_upup_cholesky_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_rdm_2e_upup_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_rdm_2e_upup_cholesky_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_rdm_2e_upup_cholesky_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_rdm_2e_upup_cholesky_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_rdm_2e_dndn_cholesky_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_rdm_2e_dndn_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_rdm_2e_dndn_cholesky_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_rdm_2e_dndn_cholesky_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_rdm_2e_dndn_cholesky_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_rdm_2e_updn_cholesky_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_rdm_2e_updn_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_rdm_2e_updn_cholesky_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_rdm_2e_updn_cholesky_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_rdm_2e_updn_cholesky_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_jastrow_en_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_jastrow_en_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_jastrow_en_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_jastrow_en_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_jastrow_en_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_jastrow_ee_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_jastrow_ee_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_jastrow_ee_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_jastrow_ee_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_jastrow_ee_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_jastrow_een_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_jastrow_een_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_jastrow_een_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_jastrow_een_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_jastrow_een_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_jastrow_ee_scaling_32 (trexio_t* const file, const float num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_jastrow_ee_scaling(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  float num_write = num;
  if ((false)) {
    num_write -= (float) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_jastrow_ee_scaling(file, (double) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_jastrow_ee_scaling(file, (double) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_jastrow_ee_scaling(file, (double) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_qmc_num_32 (trexio_t* const file, const int32_t num)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_qmc_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int32_t num_write = num;
  if ((false)) {
    num_write -= (int32_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_qmc_num(file, (int64_t) num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_qmc_num(file, (int64_t) num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_qmc_num(file, (int64_t) num_write);
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_metadata_code_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_metadata_code_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_metadata_code_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_metadata_code_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_metadata_code_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_metadata_author_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_metadata_author_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_metadata_author_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_metadata_author_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_metadata_author_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_metadata_unsafe_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_metadata_unsafe(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_metadata_unsafe(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_metadata_unsafe(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_metadata_unsafe(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_nucleus_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_nucleus_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_nucleus_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_nucleus_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_nucleus_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_nucleus_repulsion_64 (trexio_t* const file, const double num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_nucleus_repulsion(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  double num_write = num;
  if ((false)) {
    num_write -= (double) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_nucleus_repulsion(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_nucleus_repulsion(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_nucleus_repulsion(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_cell_two_pi_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_cell_two_pi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_cell_two_pi(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_cell_two_pi(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_cell_two_pi(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_pbc_periodic_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_pbc_periodic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_pbc_periodic(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_pbc_periodic(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_pbc_periodic(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_pbc_k_point_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_pbc_k_point_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_pbc_k_point_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_pbc_k_point_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_pbc_k_point_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_pbc_madelung_64 (trexio_t* const file, const double num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_pbc_madelung(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  double num_write = num;
  if ((false)) {
    num_write -= (double) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_pbc_madelung(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_pbc_madelung(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_pbc_madelung(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_electron_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_electron_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_electron_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_electron_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_electron_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_electron_up_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_electron_up_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_electron_up_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_electron_up_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_electron_up_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_electron_dn_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_electron_dn_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_electron_dn_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_electron_dn_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_electron_dn_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_state_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_state_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_state_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_state_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_state_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_state_id_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_state_id(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if (file->one_based) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_state_id(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_state_id(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_state_id(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_state_energy_64 (trexio_t* const file, const double num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_state_energy(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  double num_write = num;
  if ((false)) {
    num_write -= (double) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_state_energy(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_state_energy(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_state_energy(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_prim_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_basis_prim_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_prim_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_prim_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_prim_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_shell_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_basis_shell_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_shell_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_shell_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_shell_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_nao_grid_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_basis_nao_grid_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_nao_grid_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_nao_grid_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_nao_grid_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_interp_coeff_cnt_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_basis_interp_coeff_cnt(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_interp_coeff_cnt(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_interp_coeff_cnt(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_interp_coeff_cnt(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_e_cut_64 (trexio_t* const file, const double num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_basis_e_cut(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  double num_write = num;
  if ((false)) {
    num_write -= (double) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_e_cut(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_e_cut(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_e_cut(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ecp_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_ecp_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ecp_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ecp_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ecp_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_rad_precision_64 (trexio_t* const file, const double num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_grid_rad_precision(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  double num_write = num;
  if ((false)) {
    num_write -= (double) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_rad_precision(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_rad_precision(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_rad_precision(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_grid_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_max_ang_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_grid_max_ang_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_max_ang_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_max_ang_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_max_ang_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_min_ang_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_grid_min_ang_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_min_ang_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_min_ang_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_min_ang_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_ang_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_grid_ang_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_ang_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_ang_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_ang_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_rad_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_grid_rad_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_rad_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_rad_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_rad_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ao_cartesian_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_ao_cartesian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ao_cartesian(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ao_cartesian(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ao_cartesian(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ao_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_ao_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ao_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ao_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ao_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ao_2e_int_eri_cholesky_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_ao_2e_int_eri_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ao_2e_int_eri_cholesky_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ao_2e_int_eri_cholesky_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ao_2e_int_eri_cholesky_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_ao_2e_int_eri_lr_cholesky_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_ao_2e_int_eri_lr_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_ao_2e_int_eri_lr_cholesky_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_ao_2e_int_eri_lr_cholesky_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_ao_2e_int_eri_lr_cholesky_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_mo_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_mo_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_mo_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_mo_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_mo_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_mo_2e_int_eri_cholesky_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_mo_2e_int_eri_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_mo_2e_int_eri_cholesky_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_mo_2e_int_eri_cholesky_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_mo_2e_int_eri_cholesky_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_mo_2e_int_eri_lr_cholesky_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_mo_2e_int_eri_lr_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_mo_2e_int_eri_lr_cholesky_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_mo_2e_int_eri_lr_cholesky_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_mo_2e_int_eri_lr_cholesky_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_determinant_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_determinant_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_determinant_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_determinant_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_determinant_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_csf_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_csf_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_csf_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_csf_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_csf_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_rdm_2e_cholesky_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_rdm_2e_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_rdm_2e_cholesky_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_rdm_2e_cholesky_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_rdm_2e_cholesky_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_rdm_2e_upup_cholesky_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_rdm_2e_upup_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_rdm_2e_upup_cholesky_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_rdm_2e_upup_cholesky_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_rdm_2e_upup_cholesky_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_rdm_2e_dndn_cholesky_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_rdm_2e_dndn_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_rdm_2e_dndn_cholesky_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_rdm_2e_dndn_cholesky_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_rdm_2e_dndn_cholesky_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_rdm_2e_updn_cholesky_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_rdm_2e_updn_cholesky_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_rdm_2e_updn_cholesky_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_rdm_2e_updn_cholesky_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_rdm_2e_updn_cholesky_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_jastrow_en_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_jastrow_en_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_jastrow_en_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_jastrow_en_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_jastrow_en_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_jastrow_ee_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_jastrow_ee_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_jastrow_ee_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_jastrow_ee_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_jastrow_ee_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_jastrow_een_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_jastrow_een_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_jastrow_een_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_jastrow_een_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_jastrow_een_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_jastrow_ee_scaling_64 (trexio_t* const file, const double num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (trexio_has_jastrow_ee_scaling(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  double num_write = num;
  if ((false)) {
    num_write -= (double) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_jastrow_ee_scaling(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_jastrow_ee_scaling(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_jastrow_ee_scaling(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_qmc_num_64 (trexio_t* const file, const int64_t num)
{
  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (num <= 0L) return TREXIO_INVALID_NUM; /* this line is uncommented by the generator for dimensioning variables; do NOT remove! */
  if (trexio_has_qmc_num(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  /* Handle index type */
  int64_t num_write = num;
  if ((false)) {
    num_write -= (int64_t) 1;
  }

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_qmc_num(file, num_write);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_qmc_num(file, num_write);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_qmc_num(file, num_write);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_metadata_code_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_metadata_code_num_32(file, num);
}

trexio_exit_code
trexio_write_metadata_author_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_metadata_author_num_32(file, num);
}

trexio_exit_code
trexio_write_metadata_unsafe (trexio_t* const file, const int32_t num)
{
  return trexio_write_metadata_unsafe_32(file, num);
}

trexio_exit_code
trexio_write_nucleus_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_nucleus_num_32(file, num);
}

trexio_exit_code
trexio_write_nucleus_repulsion (trexio_t* const file, const double num)
{
  return trexio_write_nucleus_repulsion_64(file, num);
}

trexio_exit_code
trexio_write_cell_two_pi (trexio_t* const file, const int32_t num)
{
  return trexio_write_cell_two_pi_32(file, num);
}

trexio_exit_code
trexio_write_pbc_periodic (trexio_t* const file, const int32_t num)
{
  return trexio_write_pbc_periodic_32(file, num);
}

trexio_exit_code
trexio_write_pbc_k_point_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_pbc_k_point_num_32(file, num);
}

trexio_exit_code
trexio_write_pbc_madelung (trexio_t* const file, const double num)
{
  return trexio_write_pbc_madelung_64(file, num);
}

trexio_exit_code
trexio_write_electron_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_electron_num_32(file, num);
}

trexio_exit_code
trexio_write_electron_up_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_electron_up_num_32(file, num);
}

trexio_exit_code
trexio_write_electron_dn_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_electron_dn_num_32(file, num);
}

trexio_exit_code
trexio_write_state_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_state_num_32(file, num);
}

trexio_exit_code
trexio_write_state_id (trexio_t* const file, const int32_t num)
{
  return trexio_write_state_id_32(file, num);
}

trexio_exit_code
trexio_write_state_energy (trexio_t* const file, const double num)
{
  return trexio_write_state_energy_64(file, num);
}

trexio_exit_code
trexio_write_basis_prim_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_basis_prim_num_32(file, num);
}

trexio_exit_code
trexio_write_basis_shell_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_basis_shell_num_32(file, num);
}

trexio_exit_code
trexio_write_basis_nao_grid_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_basis_nao_grid_num_32(file, num);
}

trexio_exit_code
trexio_write_basis_interp_coeff_cnt (trexio_t* const file, const int32_t num)
{
  return trexio_write_basis_interp_coeff_cnt_32(file, num);
}

trexio_exit_code
trexio_write_basis_e_cut (trexio_t* const file, const double num)
{
  return trexio_write_basis_e_cut_64(file, num);
}

trexio_exit_code
trexio_write_ecp_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_ecp_num_32(file, num);
}

trexio_exit_code
trexio_write_grid_rad_precision (trexio_t* const file, const double num)
{
  return trexio_write_grid_rad_precision_64(file, num);
}

trexio_exit_code
trexio_write_grid_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_grid_num_32(file, num);
}

trexio_exit_code
trexio_write_grid_max_ang_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_grid_max_ang_num_32(file, num);
}

trexio_exit_code
trexio_write_grid_min_ang_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_grid_min_ang_num_32(file, num);
}

trexio_exit_code
trexio_write_grid_ang_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_grid_ang_num_32(file, num);
}

trexio_exit_code
trexio_write_grid_rad_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_grid_rad_num_32(file, num);
}

trexio_exit_code
trexio_write_ao_cartesian (trexio_t* const file, const int32_t num)
{
  return trexio_write_ao_cartesian_32(file, num);
}

trexio_exit_code
trexio_write_ao_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_ao_num_32(file, num);
}

trexio_exit_code
trexio_write_ao_2e_int_eri_cholesky_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_ao_2e_int_eri_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_write_ao_2e_int_eri_lr_cholesky_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_ao_2e_int_eri_lr_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_write_mo_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_mo_num_32(file, num);
}

trexio_exit_code
trexio_write_mo_2e_int_eri_cholesky_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_mo_2e_int_eri_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_write_mo_2e_int_eri_lr_cholesky_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_mo_2e_int_eri_lr_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_write_determinant_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_determinant_num_32(file, num);
}

trexio_exit_code
trexio_write_csf_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_csf_num_32(file, num);
}

trexio_exit_code
trexio_write_rdm_2e_cholesky_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_rdm_2e_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_write_rdm_2e_upup_cholesky_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_rdm_2e_upup_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_write_rdm_2e_dndn_cholesky_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_rdm_2e_dndn_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_write_rdm_2e_updn_cholesky_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_rdm_2e_updn_cholesky_num_32(file, num);
}

trexio_exit_code
trexio_write_jastrow_en_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_jastrow_en_num_32(file, num);
}

trexio_exit_code
trexio_write_jastrow_ee_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_jastrow_ee_num_32(file, num);
}

trexio_exit_code
trexio_write_jastrow_een_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_jastrow_een_num_32(file, num);
}

trexio_exit_code
trexio_write_jastrow_ee_scaling (trexio_t* const file, const double num)
{
  return trexio_write_jastrow_ee_scaling_64(file, num);
}

trexio_exit_code
trexio_write_qmc_num (trexio_t* const file, const int32_t num)
{
  return trexio_write_qmc_num_32(file, num);
}

trexio_exit_code
trexio_write_metadata_package_version (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_package_version(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_metadata_package_version(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_metadata_package_version(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_metadata_package_version(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_metadata_description (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_description(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_metadata_description(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_metadata_description(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_metadata_description(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_nucleus_point_group (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_nucleus_point_group(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_nucleus_point_group(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_nucleus_point_group(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_nucleus_point_group(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_state_current_label (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_current_label(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_state_current_label(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_state_current_label(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_state_current_label(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_type (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_basis_type(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_type(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_type(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_type(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_oscillation_kind (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_basis_oscillation_kind(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_oscillation_kind(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_oscillation_kind(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_oscillation_kind(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_basis_interpolator_kind (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_basis_interpolator_kind(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_basis_interpolator_kind(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_basis_interpolator_kind(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_basis_interpolator_kind(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_grid_description (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_grid_description(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_grid_description(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_grid_description(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_grid_description(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_mo_type (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_type(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_mo_type(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_mo_type(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_mo_type(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_jastrow_type (trexio_t* const file, const char* str, const int32_t max_str_len)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (str  == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_jastrow_type(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_ATTR_ALREADY_EXISTS;

  size_t len_write = strlen(str);
  if ((size_t) max_str_len < len_write) return TREXIO_INVALID_STR_LEN;

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_jastrow_type(file, str);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_jastrow_type(file, str);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_write_jastrow_type(file, str);
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_determinant_coefficient (trexio_t* const file, const int64_t offset_file, const int64_t buffer_size, const double* dset)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (dset == NULL) return TREXIO_INVALID_ARG_2;

  uint32_t rank = 1;
  uint64_t dims[1] = {buffer_size};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_determinant_coefficient(file, offset_file, rank, dims, dset);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_determinant_coefficient(file, offset_file, rank, dims, dset);
    break;
#else
    return TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_safe_determinant_coefficient (trexio_t* const file, const int64_t offset_file, const int64_t buffer_size, const double* dset_in, const int64_t dim_in)
{
  /* Check that dim_in is large enough */
  if (dim_in < buffer_size) return TREXIO_INVALID_ARG_5;

  return trexio_write_determinant_coefficient(file, offset_file, buffer_size, dset_in);
}

trexio_exit_code
trexio_write_csf_coefficient (trexio_t* const file, const int64_t offset_file, const int64_t buffer_size, const double* dset)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (dset == NULL) return TREXIO_INVALID_ARG_2;

  uint32_t rank = 1;
  uint64_t dims[1] = {buffer_size};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_write_csf_coefficient(file, offset_file, rank, dims, dset);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_write_csf_coefficient(file, offset_file, rank, dims, dset);
    break;
#else
    return TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_
    break;
*/
  }

  return TREXIO_FAILURE;
}

trexio_exit_code
trexio_write_safe_csf_coefficient (trexio_t* const file, const int64_t offset_file, const int64_t buffer_size, const double* dset_in, const int64_t dim_in)
{
  /* Check that dim_in is large enough */
  if (dim_in < buffer_size) return TREXIO_INVALID_ARG_5;

  return trexio_write_csf_coefficient(file, offset_file, buffer_size, dset_in);
}

trexio_exit_code
trexio_write_nucleus_charge_32 (trexio_t* const file, const float* nucleus_charge)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (nucleus_charge == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_charge(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* nucleus_charge_64 = CALLOC(dim_size, double);
  if (nucleus_charge_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      nucleus_charge_64[i] = (double) nucleus_charge[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      nucleus_charge_64[i] = (double) nucleus_charge[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_nucleus_charge(file, nucleus_charge_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_nucleus_charge(file, nucleus_charge_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_nucleus_charge(file, nucleus_charge_64, rank, dims);
    break;
*/
  }

  FREE(nucleus_charge_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_nucleus_coord_32 (trexio_t* const file, const float* nucleus_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (nucleus_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {nucleus_num, 3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* nucleus_coord_64 = CALLOC(dim_size, double);
  if (nucleus_coord_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      nucleus_coord_64[i] = (double) nucleus_coord[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      nucleus_coord_64[i] = (double) nucleus_coord[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_nucleus_coord(file, nucleus_coord_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_nucleus_coord(file, nucleus_coord_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_nucleus_coord(file, nucleus_coord_64, rank, dims);
    break;
*/
  }

  FREE(nucleus_coord_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_cell_a_32 (trexio_t* const file, const float* cell_a)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_a == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_a(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_a_64 = CALLOC(dim_size, double);
  if (cell_a_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_a_64[i] = (double) cell_a[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_a_64[i] = (double) cell_a[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_cell_a(file, cell_a_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_cell_a(file, cell_a_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_cell_a(file, cell_a_64, rank, dims);
    break;
*/
  }

  FREE(cell_a_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_cell_b_32 (trexio_t* const file, const float* cell_b)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_b == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_b(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_b_64 = CALLOC(dim_size, double);
  if (cell_b_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_b_64[i] = (double) cell_b[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_b_64[i] = (double) cell_b[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_cell_b(file, cell_b_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_cell_b(file, cell_b_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_cell_b(file, cell_b_64, rank, dims);
    break;
*/
  }

  FREE(cell_b_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_cell_c_32 (trexio_t* const file, const float* cell_c)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_c == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_c(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_c_64 = CALLOC(dim_size, double);
  if (cell_c_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_c_64[i] = (double) cell_c[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_c_64[i] = (double) cell_c[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_cell_c(file, cell_c_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_cell_c(file, cell_c_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_cell_c(file, cell_c_64, rank, dims);
    break;
*/
  }

  FREE(cell_c_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_cell_g_a_32 (trexio_t* const file, const float* cell_g_a)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_g_a == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_a(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_g_a_64 = CALLOC(dim_size, double);
  if (cell_g_a_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_a_64[i] = (double) cell_g_a[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_a_64[i] = (double) cell_g_a[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_cell_g_a(file, cell_g_a_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_cell_g_a(file, cell_g_a_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_cell_g_a(file, cell_g_a_64, rank, dims);
    break;
*/
  }

  FREE(cell_g_a_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_cell_g_b_32 (trexio_t* const file, const float* cell_g_b)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_g_b == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_b(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_g_b_64 = CALLOC(dim_size, double);
  if (cell_g_b_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_b_64[i] = (double) cell_g_b[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_b_64[i] = (double) cell_g_b[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_cell_g_b(file, cell_g_b_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_cell_g_b(file, cell_g_b_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_cell_g_b(file, cell_g_b_64, rank, dims);
    break;
*/
  }

  FREE(cell_g_b_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_cell_g_c_32 (trexio_t* const file, const float* cell_g_c)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (cell_g_c == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_c(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* cell_g_c_64 = CALLOC(dim_size, double);
  if (cell_g_c_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_c_64[i] = (double) cell_g_c[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      cell_g_c_64[i] = (double) cell_g_c[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_cell_g_c(file, cell_g_c_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_cell_g_c(file, cell_g_c_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_cell_g_c(file, cell_g_c_64, rank, dims);
    break;
*/
  }

  FREE(cell_g_c_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_pbc_k_point_32 (trexio_t* const file, const float* pbc_k_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (pbc_k_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* pbc_k_point_64 = CALLOC(dim_size, double);
  if (pbc_k_point_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      pbc_k_point_64[i] = (double) pbc_k_point[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      pbc_k_point_64[i] = (double) pbc_k_point[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_pbc_k_point(file, pbc_k_point_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_pbc_k_point(file, pbc_k_point_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_pbc_k_point(file, pbc_k_point_64, rank, dims);
    break;
*/
  }

  FREE(pbc_k_point_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_pbc_k_point_weight_32 (trexio_t* const file, const float* pbc_k_point_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (pbc_k_point_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t pbc_k_point_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_pbc_k_point_num_64(file, &(pbc_k_point_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (pbc_k_point_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {pbc_k_point_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* pbc_k_point_weight_64 = CALLOC(dim_size, double);
  if (pbc_k_point_weight_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      pbc_k_point_weight_64[i] = (double) pbc_k_point_weight[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      pbc_k_point_weight_64[i] = (double) pbc_k_point_weight[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_pbc_k_point_weight(file, pbc_k_point_weight_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_pbc_k_point_weight(file, pbc_k_point_weight_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_pbc_k_point_weight(file, pbc_k_point_weight_64, rank, dims);
    break;
*/
  }

  FREE(pbc_k_point_weight_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_nucleus_index_32 (trexio_t* const file, const int32_t* basis_nucleus_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nucleus_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nucleus_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_nucleus_index_64 = CALLOC(dim_size, int64_t);
  if (basis_nucleus_index_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nucleus_index_64[i] = (int64_t) basis_nucleus_index[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nucleus_index_64[i] = (int64_t) basis_nucleus_index[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_nucleus_index(file, basis_nucleus_index_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_nucleus_index(file, basis_nucleus_index_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_nucleus_index(file, basis_nucleus_index_64, rank, dims);
    break;
*/
  }

  FREE(basis_nucleus_index_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_shell_ang_mom_32 (trexio_t* const file, const int32_t* basis_shell_ang_mom)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_shell_ang_mom == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_ang_mom(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_shell_ang_mom_64 = CALLOC(dim_size, int64_t);
  if (basis_shell_ang_mom_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_ang_mom_64[i] = (int64_t) basis_shell_ang_mom[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_ang_mom_64[i] = (int64_t) basis_shell_ang_mom[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_shell_ang_mom(file, basis_shell_ang_mom_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_shell_ang_mom(file, basis_shell_ang_mom_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_shell_ang_mom(file, basis_shell_ang_mom_64, rank, dims);
    break;
*/
  }

  FREE(basis_shell_ang_mom_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_shell_factor_32 (trexio_t* const file, const float* basis_shell_factor)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_shell_factor == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_factor(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_shell_factor_64 = CALLOC(dim_size, double);
  if (basis_shell_factor_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_factor_64[i] = (double) basis_shell_factor[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_factor_64[i] = (double) basis_shell_factor[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_shell_factor(file, basis_shell_factor_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_shell_factor(file, basis_shell_factor_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_shell_factor(file, basis_shell_factor_64, rank, dims);
    break;
*/
  }

  FREE(basis_shell_factor_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_r_power_32 (trexio_t* const file, const int32_t* basis_r_power)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_r_power == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_r_power(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_r_power_64 = CALLOC(dim_size, int64_t);
  if (basis_r_power_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_r_power_64[i] = (int64_t) basis_r_power[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_r_power_64[i] = (int64_t) basis_r_power[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_r_power(file, basis_r_power_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_r_power(file, basis_r_power_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_r_power(file, basis_r_power_64, rank, dims);
    break;
*/
  }

  FREE(basis_r_power_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_nao_grid_start_32 (trexio_t* const file, const int32_t* basis_nao_grid_start)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_start == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_start(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_nao_grid_start_64 = CALLOC(dim_size, int64_t);
  if (basis_nao_grid_start_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_start_64[i] = (int64_t) basis_nao_grid_start[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_start_64[i] = (int64_t) basis_nao_grid_start[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_nao_grid_start(file, basis_nao_grid_start_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_nao_grid_start(file, basis_nao_grid_start_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_nao_grid_start(file, basis_nao_grid_start_64, rank, dims);
    break;
*/
  }

  FREE(basis_nao_grid_start_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_nao_grid_size_32 (trexio_t* const file, const int32_t* basis_nao_grid_size)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_size == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_size(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_nao_grid_size_64 = CALLOC(dim_size, int64_t);
  if (basis_nao_grid_size_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_size_64[i] = (int64_t) basis_nao_grid_size[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_size_64[i] = (int64_t) basis_nao_grid_size[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_nao_grid_size(file, basis_nao_grid_size_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_nao_grid_size(file, basis_nao_grid_size_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_nao_grid_size(file, basis_nao_grid_size_64, rank, dims);
    break;
*/
  }

  FREE(basis_nao_grid_size_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_shell_index_32 (trexio_t* const file, const int32_t* basis_shell_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_shell_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* basis_shell_index_64 = CALLOC(dim_size, int64_t);
  if (basis_shell_index_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_index_64[i] = (int64_t) basis_shell_index[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_shell_index_64[i] = (int64_t) basis_shell_index[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_shell_index(file, basis_shell_index_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_shell_index(file, basis_shell_index_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_shell_index(file, basis_shell_index_64, rank, dims);
    break;
*/
  }

  FREE(basis_shell_index_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_exponent_32 (trexio_t* const file, const float* basis_exponent)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_exponent == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_exponent_64 = CALLOC(dim_size, double);
  if (basis_exponent_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_exponent_64[i] = (double) basis_exponent[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_exponent_64[i] = (double) basis_exponent[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_exponent(file, basis_exponent_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_exponent(file, basis_exponent_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_exponent(file, basis_exponent_64, rank, dims);
    break;
*/
  }

  FREE(basis_exponent_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_exponent_im_32 (trexio_t* const file, const float* basis_exponent_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_exponent_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_exponent_im_64 = CALLOC(dim_size, double);
  if (basis_exponent_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_exponent_im_64[i] = (double) basis_exponent_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_exponent_im_64[i] = (double) basis_exponent_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_exponent_im(file, basis_exponent_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_exponent_im(file, basis_exponent_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_exponent_im(file, basis_exponent_im_64, rank, dims);
    break;
*/
  }

  FREE(basis_exponent_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_coefficient_32 (trexio_t* const file, const float* basis_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_coefficient_64 = CALLOC(dim_size, double);
  if (basis_coefficient_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_coefficient_64[i] = (double) basis_coefficient[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_coefficient_64[i] = (double) basis_coefficient[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_coefficient(file, basis_coefficient_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_coefficient(file, basis_coefficient_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_coefficient(file, basis_coefficient_64, rank, dims);
    break;
*/
  }

  FREE(basis_coefficient_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_coefficient_im_32 (trexio_t* const file, const float* basis_coefficient_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_coefficient_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_coefficient_im_64 = CALLOC(dim_size, double);
  if (basis_coefficient_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_coefficient_im_64[i] = (double) basis_coefficient_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_coefficient_im_64[i] = (double) basis_coefficient_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_coefficient_im(file, basis_coefficient_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_coefficient_im(file, basis_coefficient_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_coefficient_im(file, basis_coefficient_im_64, rank, dims);
    break;
*/
  }

  FREE(basis_coefficient_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_oscillation_arg_32 (trexio_t* const file, const float* basis_oscillation_arg)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_oscillation_arg == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_oscillation_arg(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_oscillation_arg_64 = CALLOC(dim_size, double);
  if (basis_oscillation_arg_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_oscillation_arg_64[i] = (double) basis_oscillation_arg[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_oscillation_arg_64[i] = (double) basis_oscillation_arg[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_oscillation_arg(file, basis_oscillation_arg_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_oscillation_arg(file, basis_oscillation_arg_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_oscillation_arg(file, basis_oscillation_arg_64, rank, dims);
    break;
*/
  }

  FREE(basis_oscillation_arg_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_prim_factor_32 (trexio_t* const file, const float* basis_prim_factor)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_prim_factor == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_factor(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_prim_factor_64 = CALLOC(dim_size, double);
  if (basis_prim_factor_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_prim_factor_64[i] = (double) basis_prim_factor[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_prim_factor_64[i] = (double) basis_prim_factor[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_prim_factor(file, basis_prim_factor_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_prim_factor(file, basis_prim_factor_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_prim_factor(file, basis_prim_factor_64, rank, dims);
    break;
*/
  }

  FREE(basis_prim_factor_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_nao_grid_radius_32 (trexio_t* const file, const float* basis_nao_grid_radius)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_radius == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_radius(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_nao_grid_radius_64 = CALLOC(dim_size, double);
  if (basis_nao_grid_radius_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_radius_64[i] = (double) basis_nao_grid_radius[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_radius_64[i] = (double) basis_nao_grid_radius[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_nao_grid_radius(file, basis_nao_grid_radius_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_nao_grid_radius(file, basis_nao_grid_radius_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_nao_grid_radius(file, basis_nao_grid_radius_64, rank, dims);
    break;
*/
  }

  FREE(basis_nao_grid_radius_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_nao_grid_phi_32 (trexio_t* const file, const float* basis_nao_grid_phi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_phi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_phi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_nao_grid_phi_64 = CALLOC(dim_size, double);
  if (basis_nao_grid_phi_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_phi_64[i] = (double) basis_nao_grid_phi[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_phi_64[i] = (double) basis_nao_grid_phi[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_nao_grid_phi(file, basis_nao_grid_phi_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_nao_grid_phi(file, basis_nao_grid_phi_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_nao_grid_phi(file, basis_nao_grid_phi_64, rank, dims);
    break;
*/
  }

  FREE(basis_nao_grid_phi_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_nao_grid_grad_32 (trexio_t* const file, const float* basis_nao_grid_grad)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_grad == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_grad(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_nao_grid_grad_64 = CALLOC(dim_size, double);
  if (basis_nao_grid_grad_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_grad_64[i] = (double) basis_nao_grid_grad[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_grad_64[i] = (double) basis_nao_grid_grad[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_nao_grid_grad(file, basis_nao_grid_grad_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_nao_grid_grad(file, basis_nao_grid_grad_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_nao_grid_grad(file, basis_nao_grid_grad_64, rank, dims);
    break;
*/
  }

  FREE(basis_nao_grid_grad_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_nao_grid_lap_32 (trexio_t* const file, const float* basis_nao_grid_lap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_nao_grid_lap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_lap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_nao_grid_lap_64 = CALLOC(dim_size, double);
  if (basis_nao_grid_lap_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_lap_64[i] = (double) basis_nao_grid_lap[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_nao_grid_lap_64[i] = (double) basis_nao_grid_lap[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_nao_grid_lap(file, basis_nao_grid_lap_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_nao_grid_lap(file, basis_nao_grid_lap_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_nao_grid_lap(file, basis_nao_grid_lap_64, rank, dims);
    break;
*/
  }

  FREE(basis_nao_grid_lap_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_interpolator_phi_32 (trexio_t* const file, const float* basis_interpolator_phi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_interpolator_phi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_phi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_interpolator_phi_64 = CALLOC(dim_size, double);
  if (basis_interpolator_phi_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_phi_64[i] = (double) basis_interpolator_phi[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_phi_64[i] = (double) basis_interpolator_phi[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_interpolator_phi(file, basis_interpolator_phi_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_interpolator_phi(file, basis_interpolator_phi_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_interpolator_phi(file, basis_interpolator_phi_64, rank, dims);
    break;
*/
  }

  FREE(basis_interpolator_phi_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_interpolator_grad_32 (trexio_t* const file, const float* basis_interpolator_grad)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_interpolator_grad == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_grad(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_interpolator_grad_64 = CALLOC(dim_size, double);
  if (basis_interpolator_grad_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_grad_64[i] = (double) basis_interpolator_grad[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_grad_64[i] = (double) basis_interpolator_grad[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_interpolator_grad(file, basis_interpolator_grad_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_interpolator_grad(file, basis_interpolator_grad_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_interpolator_grad(file, basis_interpolator_grad_64, rank, dims);
    break;
*/
  }

  FREE(basis_interpolator_grad_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_basis_interpolator_lap_32 (trexio_t* const file, const float* basis_interpolator_lap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (basis_interpolator_lap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_lap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* basis_interpolator_lap_64 = CALLOC(dim_size, double);
  if (basis_interpolator_lap_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_lap_64[i] = (double) basis_interpolator_lap[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      basis_interpolator_lap_64[i] = (double) basis_interpolator_lap[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_basis_interpolator_lap(file, basis_interpolator_lap_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_basis_interpolator_lap(file, basis_interpolator_lap_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_basis_interpolator_lap(file, basis_interpolator_lap_64, rank, dims);
    break;
*/
  }

  FREE(basis_interpolator_lap_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ecp_max_ang_mom_plus_1_32 (trexio_t* const file, const int32_t* ecp_max_ang_mom_plus_1)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_max_ang_mom_plus_1 == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_max_ang_mom_plus_1(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_max_ang_mom_plus_1_64 = CALLOC(dim_size, int64_t);
  if (ecp_max_ang_mom_plus_1_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_max_ang_mom_plus_1_64[i] = (int64_t) ecp_max_ang_mom_plus_1[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_max_ang_mom_plus_1_64[i] = (int64_t) ecp_max_ang_mom_plus_1[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1_64, rank, dims);
    break;
*/
  }

  FREE(ecp_max_ang_mom_plus_1_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ecp_z_core_32 (trexio_t* const file, const int32_t* ecp_z_core)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_z_core == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_z_core(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_z_core_64 = CALLOC(dim_size, int64_t);
  if (ecp_z_core_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_z_core_64[i] = (int64_t) ecp_z_core[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_z_core_64[i] = (int64_t) ecp_z_core[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ecp_z_core(file, ecp_z_core_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ecp_z_core(file, ecp_z_core_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ecp_z_core(file, ecp_z_core_64, rank, dims);
    break;
*/
  }

  FREE(ecp_z_core_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ecp_ang_mom_32 (trexio_t* const file, const int32_t* ecp_ang_mom)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_ang_mom == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_ang_mom(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_ang_mom_64 = CALLOC(dim_size, int64_t);
  if (ecp_ang_mom_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_ang_mom_64[i] = (int64_t) ecp_ang_mom[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_ang_mom_64[i] = (int64_t) ecp_ang_mom[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ecp_ang_mom(file, ecp_ang_mom_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ecp_ang_mom(file, ecp_ang_mom_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ecp_ang_mom(file, ecp_ang_mom_64, rank, dims);
    break;
*/
  }

  FREE(ecp_ang_mom_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ecp_nucleus_index_32 (trexio_t* const file, const int32_t* ecp_nucleus_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_nucleus_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_nucleus_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_nucleus_index_64 = CALLOC(dim_size, int64_t);
  if (ecp_nucleus_index_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_nucleus_index_64[i] = (int64_t) ecp_nucleus_index[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_nucleus_index_64[i] = (int64_t) ecp_nucleus_index[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ecp_nucleus_index(file, ecp_nucleus_index_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ecp_nucleus_index(file, ecp_nucleus_index_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ecp_nucleus_index(file, ecp_nucleus_index_64, rank, dims);
    break;
*/
  }

  FREE(ecp_nucleus_index_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ecp_exponent_32 (trexio_t* const file, const float* ecp_exponent)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_exponent == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_exponent(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ecp_exponent_64 = CALLOC(dim_size, double);
  if (ecp_exponent_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_exponent_64[i] = (double) ecp_exponent[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_exponent_64[i] = (double) ecp_exponent[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ecp_exponent(file, ecp_exponent_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ecp_exponent(file, ecp_exponent_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ecp_exponent(file, ecp_exponent_64, rank, dims);
    break;
*/
  }

  FREE(ecp_exponent_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ecp_coefficient_32 (trexio_t* const file, const float* ecp_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ecp_coefficient_64 = CALLOC(dim_size, double);
  if (ecp_coefficient_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_coefficient_64[i] = (double) ecp_coefficient[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_coefficient_64[i] = (double) ecp_coefficient[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ecp_coefficient(file, ecp_coefficient_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ecp_coefficient(file, ecp_coefficient_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ecp_coefficient(file, ecp_coefficient_64, rank, dims);
    break;
*/
  }

  FREE(ecp_coefficient_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ecp_power_32 (trexio_t* const file, const int32_t* ecp_power)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ecp_power == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_power(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ecp_power_64 = CALLOC(dim_size, int64_t);
  if (ecp_power_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_power_64[i] = (int64_t) ecp_power[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ecp_power_64[i] = (int64_t) ecp_power[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ecp_power(file, ecp_power_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ecp_power(file, ecp_power_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ecp_power(file, ecp_power_64, rank, dims);
    break;
*/
  }

  FREE(ecp_power_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_grid_coord_32 (trexio_t* const file, const float* grid_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_num_64(file, &(grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_coord_64 = CALLOC(dim_size, double);
  if (grid_coord_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_coord_64[i] = (double) grid_coord[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_coord_64[i] = (double) grid_coord[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_grid_coord(file, grid_coord_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_grid_coord(file, grid_coord_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_grid_coord(file, grid_coord_64, rank, dims);
    break;
*/
  }

  FREE(grid_coord_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_grid_weight_32 (trexio_t* const file, const float* grid_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_num_64(file, &(grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_weight_64 = CALLOC(dim_size, double);
  if (grid_weight_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_weight_64[i] = (double) grid_weight[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_weight_64[i] = (double) grid_weight[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_grid_weight(file, grid_weight_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_grid_weight(file, grid_weight_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_grid_weight(file, grid_weight_64, rank, dims);
    break;
*/
  }

  FREE(grid_weight_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_grid_ang_coord_32 (trexio_t* const file, const float* grid_ang_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_ang_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_ang_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_ang_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_ang_coord_64 = CALLOC(dim_size, double);
  if (grid_ang_coord_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_ang_coord_64[i] = (double) grid_ang_coord[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_ang_coord_64[i] = (double) grid_ang_coord[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_grid_ang_coord(file, grid_ang_coord_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_grid_ang_coord(file, grid_ang_coord_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_grid_ang_coord(file, grid_ang_coord_64, rank, dims);
    break;
*/
  }

  FREE(grid_ang_coord_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_grid_ang_weight_32 (trexio_t* const file, const float* grid_ang_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_ang_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_ang_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_ang_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_ang_weight_64 = CALLOC(dim_size, double);
  if (grid_ang_weight_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_ang_weight_64[i] = (double) grid_ang_weight[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_ang_weight_64[i] = (double) grid_ang_weight[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_grid_ang_weight(file, grid_ang_weight_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_grid_ang_weight(file, grid_ang_weight_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_grid_ang_weight(file, grid_ang_weight_64, rank, dims);
    break;
*/
  }

  FREE(grid_ang_weight_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_grid_rad_coord_32 (trexio_t* const file, const float* grid_rad_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_rad_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_rad_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_rad_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_rad_coord_64 = CALLOC(dim_size, double);
  if (grid_rad_coord_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_rad_coord_64[i] = (double) grid_rad_coord[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_rad_coord_64[i] = (double) grid_rad_coord[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_grid_rad_coord(file, grid_rad_coord_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_grid_rad_coord(file, grid_rad_coord_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_grid_rad_coord(file, grid_rad_coord_64, rank, dims);
    break;
*/
  }

  FREE(grid_rad_coord_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_grid_rad_weight_32 (trexio_t* const file, const float* grid_rad_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (grid_rad_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_rad_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_rad_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* grid_rad_weight_64 = CALLOC(dim_size, double);
  if (grid_rad_weight_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_rad_weight_64[i] = (double) grid_rad_weight[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      grid_rad_weight_64[i] = (double) grid_rad_weight[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_grid_rad_weight(file, grid_rad_weight_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_grid_rad_weight(file, grid_rad_weight_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_grid_rad_weight(file, grid_rad_weight_64, rank, dims);
    break;
*/
  }

  FREE(grid_rad_weight_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_shell_32 (trexio_t* const file, const int32_t* ao_shell)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_shell == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_shell(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* ao_shell_64 = CALLOC(dim_size, int64_t);
  if (ao_shell_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_shell_64[i] = (int64_t) ao_shell[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_shell_64[i] = (int64_t) ao_shell[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_shell(file, ao_shell_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_shell(file, ao_shell_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_shell(file, ao_shell_64, rank, dims);
    break;
*/
  }

  FREE(ao_shell_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_normalization_32 (trexio_t* const file, const float* ao_normalization)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_normalization == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_normalization(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_normalization_64 = CALLOC(dim_size, double);
  if (ao_normalization_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_normalization_64[i] = (double) ao_normalization[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_normalization_64[i] = (double) ao_normalization[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_normalization(file, ao_normalization_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_normalization(file, ao_normalization_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_normalization(file, ao_normalization_64, rank, dims);
    break;
*/
  }

  FREE(ao_normalization_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_overlap_32 (trexio_t* const file, const float* ao_1e_int_overlap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_overlap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_overlap_64 = CALLOC(dim_size, double);
  if (ao_1e_int_overlap_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_overlap_64[i] = (double) ao_1e_int_overlap[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_overlap_64[i] = (double) ao_1e_int_overlap[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_overlap(file, ao_1e_int_overlap_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_overlap(file, ao_1e_int_overlap_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_overlap(file, ao_1e_int_overlap_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_overlap_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_kinetic_32 (trexio_t* const file, const float* ao_1e_int_kinetic)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_kinetic == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_kinetic_64 = CALLOC(dim_size, double);
  if (ao_1e_int_kinetic_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_kinetic_64[i] = (double) ao_1e_int_kinetic[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_kinetic_64[i] = (double) ao_1e_int_kinetic[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_kinetic(file, ao_1e_int_kinetic_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_kinetic(file, ao_1e_int_kinetic_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_kinetic(file, ao_1e_int_kinetic_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_kinetic_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_potential_n_e_32 (trexio_t* const file, const float* ao_1e_int_potential_n_e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_potential_n_e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_potential_n_e_64 = CALLOC(dim_size, double);
  if (ao_1e_int_potential_n_e_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_potential_n_e_64[i] = (double) ao_1e_int_potential_n_e[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_potential_n_e_64[i] = (double) ao_1e_int_potential_n_e[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_potential_n_e_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_ecp_32 (trexio_t* const file, const float* ao_1e_int_ecp)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_ecp == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_ecp_64 = CALLOC(dim_size, double);
  if (ao_1e_int_ecp_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_ecp_64[i] = (double) ao_1e_int_ecp[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_ecp_64[i] = (double) ao_1e_int_ecp[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_ecp(file, ao_1e_int_ecp_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_ecp(file, ao_1e_int_ecp_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_ecp(file, ao_1e_int_ecp_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_ecp_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_core_hamiltonian_32 (trexio_t* const file, const float* ao_1e_int_core_hamiltonian)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_core_hamiltonian == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_core_hamiltonian_64 = CALLOC(dim_size, double);
  if (ao_1e_int_core_hamiltonian_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_core_hamiltonian_64[i] = (double) ao_1e_int_core_hamiltonian[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_core_hamiltonian_64[i] = (double) ao_1e_int_core_hamiltonian[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_core_hamiltonian_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_overlap_im_32 (trexio_t* const file, const float* ao_1e_int_overlap_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_overlap_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_overlap_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_overlap_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_overlap_im_64[i] = (double) ao_1e_int_overlap_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_overlap_im_64[i] = (double) ao_1e_int_overlap_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_overlap_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_kinetic_im_32 (trexio_t* const file, const float* ao_1e_int_kinetic_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_kinetic_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_kinetic_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_kinetic_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_kinetic_im_64[i] = (double) ao_1e_int_kinetic_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_kinetic_im_64[i] = (double) ao_1e_int_kinetic_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_kinetic_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_potential_n_e_im_32 (trexio_t* const file, const float* ao_1e_int_potential_n_e_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_potential_n_e_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_potential_n_e_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_potential_n_e_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_potential_n_e_im_64[i] = (double) ao_1e_int_potential_n_e_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_potential_n_e_im_64[i] = (double) ao_1e_int_potential_n_e_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_potential_n_e_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_ecp_im_32 (trexio_t* const file, const float* ao_1e_int_ecp_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_ecp_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_ecp_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_ecp_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_ecp_im_64[i] = (double) ao_1e_int_ecp_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_ecp_im_64[i] = (double) ao_1e_int_ecp_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_ecp_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_ao_1e_int_core_hamiltonian_im_32 (trexio_t* const file, const float* ao_1e_int_core_hamiltonian_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (ao_1e_int_core_hamiltonian_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* ao_1e_int_core_hamiltonian_im_64 = CALLOC(dim_size, double);
  if (ao_1e_int_core_hamiltonian_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_core_hamiltonian_im_64[i] = (double) ao_1e_int_core_hamiltonian_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      ao_1e_int_core_hamiltonian_im_64[i] = (double) ao_1e_int_core_hamiltonian_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im_64, rank, dims);
    break;
*/
  }

  FREE(ao_1e_int_core_hamiltonian_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_coefficient_32 (trexio_t* const file, const float* mo_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;
  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;
  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_coefficient_64 = CALLOC(dim_size, double);
  if (mo_coefficient_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_coefficient_64[i] = (double) mo_coefficient[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_coefficient_64[i] = (double) mo_coefficient[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_coefficient(file, mo_coefficient_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_coefficient(file, mo_coefficient_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_coefficient(file, mo_coefficient_64, rank, dims);
    break;
*/
  }

  FREE(mo_coefficient_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_coefficient_im_32 (trexio_t* const file, const float* mo_coefficient_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_coefficient_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;
  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;
  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, ao_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_coefficient_im_64 = CALLOC(dim_size, double);
  if (mo_coefficient_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_coefficient_im_64[i] = (double) mo_coefficient_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_coefficient_im_64[i] = (double) mo_coefficient_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_coefficient_im(file, mo_coefficient_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_coefficient_im(file, mo_coefficient_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_coefficient_im(file, mo_coefficient_im_64, rank, dims);
    break;
*/
  }

  FREE(mo_coefficient_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_occupation_32 (trexio_t* const file, const float* mo_occupation)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_occupation == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_occupation(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_occupation_64 = CALLOC(dim_size, double);
  if (mo_occupation_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_occupation_64[i] = (double) mo_occupation[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_occupation_64[i] = (double) mo_occupation[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_occupation(file, mo_occupation_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_occupation(file, mo_occupation_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_occupation(file, mo_occupation_64, rank, dims);
    break;
*/
  }

  FREE(mo_occupation_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_energy_32 (trexio_t* const file, const float* mo_energy)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_energy == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_energy(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_energy_64 = CALLOC(dim_size, double);
  if (mo_energy_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_energy_64[i] = (double) mo_energy[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_energy_64[i] = (double) mo_energy[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_energy(file, mo_energy_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_energy(file, mo_energy_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_energy(file, mo_energy_64, rank, dims);
    break;
*/
  }

  FREE(mo_energy_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_spin_32 (trexio_t* const file, const int32_t* mo_spin)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_spin == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_spin(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* mo_spin_64 = CALLOC(dim_size, int64_t);
  if (mo_spin_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_spin_64[i] = (int64_t) mo_spin[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_spin_64[i] = (int64_t) mo_spin[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_spin(file, mo_spin_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_spin(file, mo_spin_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_spin(file, mo_spin_64, rank, dims);
    break;
*/
  }

  FREE(mo_spin_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_k_point_32 (trexio_t* const file, const int32_t* mo_k_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_k_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_k_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* mo_k_point_64 = CALLOC(dim_size, int64_t);
  if (mo_k_point_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_k_point_64[i] = (int64_t) mo_k_point[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_k_point_64[i] = (int64_t) mo_k_point[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_k_point(file, mo_k_point_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_k_point(file, mo_k_point_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_k_point(file, mo_k_point_64, rank, dims);
    break;
*/
  }

  FREE(mo_k_point_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_overlap_32 (trexio_t* const file, const float* mo_1e_int_overlap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_overlap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_overlap_64 = CALLOC(dim_size, double);
  if (mo_1e_int_overlap_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_overlap_64[i] = (double) mo_1e_int_overlap[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_overlap_64[i] = (double) mo_1e_int_overlap[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_overlap(file, mo_1e_int_overlap_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_overlap(file, mo_1e_int_overlap_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_overlap(file, mo_1e_int_overlap_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_overlap_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_kinetic_32 (trexio_t* const file, const float* mo_1e_int_kinetic)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_kinetic == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_kinetic_64 = CALLOC(dim_size, double);
  if (mo_1e_int_kinetic_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_kinetic_64[i] = (double) mo_1e_int_kinetic[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_kinetic_64[i] = (double) mo_1e_int_kinetic[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_kinetic(file, mo_1e_int_kinetic_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_kinetic(file, mo_1e_int_kinetic_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_kinetic(file, mo_1e_int_kinetic_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_kinetic_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_potential_n_e_32 (trexio_t* const file, const float* mo_1e_int_potential_n_e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_potential_n_e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_potential_n_e_64 = CALLOC(dim_size, double);
  if (mo_1e_int_potential_n_e_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_potential_n_e_64[i] = (double) mo_1e_int_potential_n_e[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_potential_n_e_64[i] = (double) mo_1e_int_potential_n_e[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_potential_n_e_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_ecp_32 (trexio_t* const file, const float* mo_1e_int_ecp)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_ecp == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_ecp_64 = CALLOC(dim_size, double);
  if (mo_1e_int_ecp_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_ecp_64[i] = (double) mo_1e_int_ecp[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_ecp_64[i] = (double) mo_1e_int_ecp[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_ecp(file, mo_1e_int_ecp_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_ecp(file, mo_1e_int_ecp_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_ecp(file, mo_1e_int_ecp_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_ecp_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_core_hamiltonian_32 (trexio_t* const file, const float* mo_1e_int_core_hamiltonian)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_core_hamiltonian == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_core_hamiltonian_64 = CALLOC(dim_size, double);
  if (mo_1e_int_core_hamiltonian_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_core_hamiltonian_64[i] = (double) mo_1e_int_core_hamiltonian[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_core_hamiltonian_64[i] = (double) mo_1e_int_core_hamiltonian[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_core_hamiltonian_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_overlap_im_32 (trexio_t* const file, const float* mo_1e_int_overlap_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_overlap_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_overlap_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_overlap_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_overlap_im_64[i] = (double) mo_1e_int_overlap_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_overlap_im_64[i] = (double) mo_1e_int_overlap_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_overlap_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_kinetic_im_32 (trexio_t* const file, const float* mo_1e_int_kinetic_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_kinetic_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_kinetic_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_kinetic_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_kinetic_im_64[i] = (double) mo_1e_int_kinetic_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_kinetic_im_64[i] = (double) mo_1e_int_kinetic_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_kinetic_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_potential_n_e_im_32 (trexio_t* const file, const float* mo_1e_int_potential_n_e_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_potential_n_e_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_potential_n_e_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_potential_n_e_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_potential_n_e_im_64[i] = (double) mo_1e_int_potential_n_e_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_potential_n_e_im_64[i] = (double) mo_1e_int_potential_n_e_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_potential_n_e_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_ecp_im_32 (trexio_t* const file, const float* mo_1e_int_ecp_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_ecp_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_ecp_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_ecp_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_ecp_im_64[i] = (double) mo_1e_int_ecp_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_ecp_im_64[i] = (double) mo_1e_int_ecp_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_ecp_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_mo_1e_int_core_hamiltonian_im_32 (trexio_t* const file, const float* mo_1e_int_core_hamiltonian_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (mo_1e_int_core_hamiltonian_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* mo_1e_int_core_hamiltonian_im_64 = CALLOC(dim_size, double);
  if (mo_1e_int_core_hamiltonian_im_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_core_hamiltonian_im_64[i] = (double) mo_1e_int_core_hamiltonian_im[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      mo_1e_int_core_hamiltonian_im_64[i] = (double) mo_1e_int_core_hamiltonian_im[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im_64, rank, dims);
    break;
*/
  }

  FREE(mo_1e_int_core_hamiltonian_im_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_rdm_1e_32 (trexio_t* const file, const float* rdm_1e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* rdm_1e_64 = CALLOC(dim_size, double);
  if (rdm_1e_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_64[i] = (double) rdm_1e[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_64[i] = (double) rdm_1e[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_rdm_1e(file, rdm_1e_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_rdm_1e(file, rdm_1e_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_rdm_1e(file, rdm_1e_64, rank, dims);
    break;
*/
  }

  FREE(rdm_1e_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_rdm_1e_up_32 (trexio_t* const file, const float* rdm_1e_up)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e_up == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_up(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* rdm_1e_up_64 = CALLOC(dim_size, double);
  if (rdm_1e_up_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_up_64[i] = (double) rdm_1e_up[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_up_64[i] = (double) rdm_1e_up[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_rdm_1e_up(file, rdm_1e_up_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_rdm_1e_up(file, rdm_1e_up_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_rdm_1e_up(file, rdm_1e_up_64, rank, dims);
    break;
*/
  }

  FREE(rdm_1e_up_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_rdm_1e_dn_32 (trexio_t* const file, const float* rdm_1e_dn)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e_dn == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_dn(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* rdm_1e_dn_64 = CALLOC(dim_size, double);
  if (rdm_1e_dn_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_dn_64[i] = (double) rdm_1e_dn[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_dn_64[i] = (double) rdm_1e_dn[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_rdm_1e_dn(file, rdm_1e_dn_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_rdm_1e_dn(file, rdm_1e_dn_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_rdm_1e_dn(file, rdm_1e_dn_64, rank, dims);
    break;
*/
  }

  FREE(rdm_1e_dn_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_rdm_1e_transition_32 (trexio_t* const file, const float* rdm_1e_transition)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (rdm_1e_transition == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_transition(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t state_num = 0;
  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_state_num_64(file, &(state_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (state_num == 0L) return TREXIO_INVALID_NUM;
  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 4;
  uint64_t dims[4] = {state_num, state_num, mo_num, mo_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* rdm_1e_transition_64 = CALLOC(dim_size, double);
  if (rdm_1e_transition_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_transition_64[i] = (double) rdm_1e_transition[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      rdm_1e_transition_64[i] = (double) rdm_1e_transition[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_rdm_1e_transition(file, rdm_1e_transition_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_rdm_1e_transition(file, rdm_1e_transition_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_rdm_1e_transition(file, rdm_1e_transition_64, rank, dims);
    break;
*/
  }

  FREE(rdm_1e_transition_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_jastrow_en_32 (trexio_t* const file, const float* jastrow_en)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_en == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_en_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_en_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* jastrow_en_64 = CALLOC(dim_size, double);
  if (jastrow_en_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_64[i] = (double) jastrow_en[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_64[i] = (double) jastrow_en[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_jastrow_en(file, jastrow_en_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_jastrow_en(file, jastrow_en_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_jastrow_en(file, jastrow_en_64, rank, dims);
    break;
*/
  }

  FREE(jastrow_en_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_jastrow_ee_32 (trexio_t* const file, const float* jastrow_ee)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_ee == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_ee_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_ee_num_64(file, &(jastrow_ee_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_ee_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_ee_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* jastrow_ee_64 = CALLOC(dim_size, double);
  if (jastrow_ee_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_ee_64[i] = (double) jastrow_ee[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_ee_64[i] = (double) jastrow_ee[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_jastrow_ee(file, jastrow_ee_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_jastrow_ee(file, jastrow_ee_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_jastrow_ee(file, jastrow_ee_64, rank, dims);
    break;
*/
  }

  FREE(jastrow_ee_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_jastrow_een_32 (trexio_t* const file, const float* jastrow_een)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_een == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_een_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_een_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* jastrow_een_64 = CALLOC(dim_size, double);
  if (jastrow_een_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_een_64[i] = (double) jastrow_een[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_een_64[i] = (double) jastrow_een[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_jastrow_een(file, jastrow_een_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_jastrow_een(file, jastrow_een_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_jastrow_een(file, jastrow_een_64, rank, dims);
    break;
*/
  }

  FREE(jastrow_een_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_jastrow_en_nucleus_32 (trexio_t* const file, const int32_t* jastrow_en_nucleus)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_en_nucleus == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_nucleus(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_en_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_en_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* jastrow_en_nucleus_64 = CALLOC(dim_size, int64_t);
  if (jastrow_en_nucleus_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_nucleus_64[i] = (int64_t) jastrow_en_nucleus[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_nucleus_64[i] = (int64_t) jastrow_en_nucleus[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_jastrow_en_nucleus(file, jastrow_en_nucleus_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_jastrow_en_nucleus(file, jastrow_en_nucleus_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_jastrow_en_nucleus(file, jastrow_en_nucleus_64, rank, dims);
    break;
*/
  }

  FREE(jastrow_en_nucleus_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_jastrow_een_nucleus_32 (trexio_t* const file, const int32_t* jastrow_een_nucleus)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_een_nucleus == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_nucleus(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_een_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_een_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  int64_t* jastrow_een_nucleus_64 = CALLOC(dim_size, int64_t);
  if (jastrow_een_nucleus_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if (file->one_based) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_een_nucleus_64[i] = (int64_t) jastrow_een_nucleus[i] - (int64_t) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_een_nucleus_64[i] = (int64_t) jastrow_een_nucleus[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_jastrow_een_nucleus(file, jastrow_een_nucleus_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_jastrow_een_nucleus(file, jastrow_een_nucleus_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_jastrow_een_nucleus(file, jastrow_een_nucleus_64, rank, dims);
    break;
*/
  }

  FREE(jastrow_een_nucleus_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_jastrow_en_scaling_32 (trexio_t* const file, const float* jastrow_en_scaling)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (jastrow_en_scaling == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_scaling(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* jastrow_en_scaling_64 = CALLOC(dim_size, double);
  if (jastrow_en_scaling_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_scaling_64[i] = (double) jastrow_en_scaling[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      jastrow_en_scaling_64[i] = (double) jastrow_en_scaling[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_jastrow_en_scaling(file, jastrow_en_scaling_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_jastrow_en_scaling(file, jastrow_en_scaling_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_jastrow_en_scaling(file, jastrow_en_scaling_64, rank, dims);
    break;
*/
  }

  FREE(jastrow_en_scaling_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_qmc_point_32 (trexio_t* const file, const float* qmc_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (qmc_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t qmc_num = 0;
  int64_t electron_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_electron_num_64(file, &(electron_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;
  if (electron_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 3;
  uint64_t dims[3] = {qmc_num, electron_num, 3};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* qmc_point_64 = CALLOC(dim_size, double);
  if (qmc_point_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_point_64[i] = (double) qmc_point[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_point_64[i] = (double) qmc_point[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_qmc_point(file, qmc_point_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_qmc_point(file, qmc_point_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_qmc_point(file, qmc_point_64, rank, dims);
    break;
*/
  }

  FREE(qmc_point_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_qmc_psi_32 (trexio_t* const file, const float* qmc_psi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (qmc_psi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_psi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t qmc_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {qmc_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* qmc_psi_64 = CALLOC(dim_size, double);
  if (qmc_psi_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_psi_64[i] = (double) qmc_psi[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_psi_64[i] = (double) qmc_psi[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_qmc_psi(file, qmc_psi_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_qmc_psi(file, qmc_psi_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_qmc_psi(file, qmc_psi_64, rank, dims);
    break;
*/
  }

  FREE(qmc_psi_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_qmc_e_loc_32 (trexio_t* const file, const float* qmc_e_loc)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (qmc_e_loc == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_e_loc(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t qmc_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;

  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {qmc_num};

  uint64_t dim_size = 1;
  for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
  }

  double* qmc_e_loc_64 = CALLOC(dim_size, double);
  if (qmc_e_loc_64 == NULL) return TREXIO_ALLOCATION_FAILED;

  /* A type conversion from single precision to double required since back end only accepts 64-bit data */
  if ((false)) {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_e_loc_64[i] = (double) qmc_e_loc[i] - (double) 1;
    }
  } else {
    for (uint64_t i=0; i<dim_size; ++i){
      qmc_e_loc_64[i] = (double) qmc_e_loc[i];
    }
  }

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_qmc_e_loc(file, qmc_e_loc_64, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_qmc_e_loc(file, qmc_e_loc_64, rank, dims);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_qmc_e_loc(file, qmc_e_loc_64, rank, dims);
    break;
*/
  }

  FREE(qmc_e_loc_64);

  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_safe_nucleus_charge_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_charge(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_nucleus_charge_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_nucleus_coord_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {nucleus_num, 3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_nucleus_coord_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_a_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_a(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_a_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_b_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_b(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_b_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_c_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_c(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_c_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_g_a_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_a(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_g_a_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_g_b_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_b(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_g_b_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_g_c_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_c(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_g_c_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_pbc_k_point_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_pbc_k_point_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_pbc_k_point_weight_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t pbc_k_point_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_pbc_k_point_num_64(file, &(pbc_k_point_num));
if (rc != TREXIO_SUCCESS) return rc;

if (pbc_k_point_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {pbc_k_point_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_pbc_k_point_weight_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nucleus_index_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nucleus_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nucleus_index_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_shell_ang_mom_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_ang_mom(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_shell_ang_mom_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_shell_factor_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_factor(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_shell_factor_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_r_power_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_r_power(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_r_power_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_start_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_start(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_start_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_size_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_size(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_size_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_shell_index_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_shell_index_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_exponent_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_exponent_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_exponent_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_exponent_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_coefficient_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_coefficient_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_coefficient_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_coefficient_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_oscillation_arg_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_oscillation_arg(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_oscillation_arg_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_prim_factor_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_factor(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_prim_factor_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_radius_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_radius(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_radius_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_phi_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_phi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_phi_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_grad_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_grad(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_grad_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_lap_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_lap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_lap_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_interpolator_phi_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_phi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_interpolator_phi_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_interpolator_grad_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_grad(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_interpolator_grad_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_interpolator_lap_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_lap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_interpolator_lap_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_max_ang_mom_plus_1_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_max_ang_mom_plus_1(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_max_ang_mom_plus_1_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_z_core_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_z_core(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_z_core_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_ang_mom_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_ang_mom(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_ang_mom_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_nucleus_index_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_nucleus_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_nucleus_index_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_exponent_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_exponent(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_exponent_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_coefficient_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_coefficient_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_power_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_power(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_power_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_coord_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_num_64(file, &(grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_coord_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_weight_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_num_64(file, &(grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_weight_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_ang_coord_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_ang_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_ang_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_ang_coord_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_ang_weight_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_ang_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_ang_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_ang_weight_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_rad_coord_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_rad_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_rad_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_rad_coord_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_rad_weight_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_rad_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_rad_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_rad_weight_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_shell_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_shell(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_shell_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_normalization_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_normalization(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_normalization_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_overlap_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_overlap_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_kinetic_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_kinetic_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_potential_n_e_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_potential_n_e_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_ecp_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_ecp_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_core_hamiltonian_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_core_hamiltonian_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_overlap_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_overlap_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_kinetic_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_kinetic_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_potential_n_e_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_potential_n_e_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_ecp_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_ecp_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_core_hamiltonian_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_core_hamiltonian_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_coefficient_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;
int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;
if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_coefficient_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_coefficient_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;
int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;
if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_coefficient_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_occupation_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_occupation(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_occupation_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_energy_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_energy(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_energy_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_spin_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_spin(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_spin_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_k_point_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_k_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_k_point_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_overlap_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_overlap_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_kinetic_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_kinetic_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_potential_n_e_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_potential_n_e_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_ecp_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_ecp_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_core_hamiltonian_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_core_hamiltonian_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_overlap_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_overlap_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_kinetic_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_kinetic_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_potential_n_e_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_potential_n_e_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_ecp_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_ecp_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_core_hamiltonian_im_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_core_hamiltonian_im_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_rdm_1e_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_up_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_up(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_rdm_1e_up_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_dn_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_dn(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_rdm_1e_dn_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_transition_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_transition(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t state_num = 0;
int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_state_num_64(file, &(state_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (state_num == 0L) return TREXIO_INVALID_NUM;
if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 4;
uint64_t dims[4] = {state_num, state_num, mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_rdm_1e_transition_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_en_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_en_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_en_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_en_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_ee_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_ee_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_ee_num_64(file, &(jastrow_ee_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_ee_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_ee_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_ee_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_een_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_een_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_een_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_een_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_en_nucleus_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_nucleus(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_en_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_en_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_en_nucleus_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_een_nucleus_32 (trexio_t* const file, const int32_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_nucleus(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_een_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_een_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_een_nucleus_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_en_scaling_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_scaling(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_en_scaling_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_qmc_point_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t qmc_num = 0;
int64_t electron_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_electron_num_64(file, &(electron_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;
if (electron_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 3;
uint64_t dims[3] = {qmc_num, electron_num, 3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_qmc_point_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_qmc_psi_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_psi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t qmc_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {qmc_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_qmc_psi_32(file, dset_in);
}

trexio_exit_code
trexio_write_safe_qmc_e_loc_32 (trexio_t* const file, const float* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_e_loc(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t qmc_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {qmc_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_qmc_e_loc_32(file, dset_in);
}

trexio_exit_code
trexio_write_nucleus_charge_64 (trexio_t* const file, const double* nucleus_charge)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (nucleus_charge == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_charge(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* nucleus_charge_p =
       CALLOC(dim_size, double);

    if (nucleus_charge_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       nucleus_charge_p[i] = nucleus_charge[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_nucleus_charge(file,
                                          (const double*) nucleus_charge_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_nucleus_charge(file,
                                          (const double*) nucleus_charge_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_nucleus_charge(file, nucleus_charge_p, rank, dims);
        break;
      */
      FREE(nucleus_charge_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_nucleus_charge(file, nucleus_charge, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_nucleus_charge(file, nucleus_charge, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_nucleus_charge(file, nucleus_charge, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_nucleus_coord_64 (trexio_t* const file, const double* nucleus_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (nucleus_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {nucleus_num, 3};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* nucleus_coord_p =
       CALLOC(dim_size, double);

    if (nucleus_coord_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       nucleus_coord_p[i] = nucleus_coord[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_nucleus_coord(file,
                                          (const double*) nucleus_coord_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_nucleus_coord(file,
                                          (const double*) nucleus_coord_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_nucleus_coord(file, nucleus_coord_p, rank, dims);
        break;
      */
      FREE(nucleus_coord_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_nucleus_coord(file, nucleus_coord, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_nucleus_coord(file, nucleus_coord, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_nucleus_coord(file, nucleus_coord, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_cell_a_64 (trexio_t* const file, const double* cell_a)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (cell_a == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_a(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* cell_a_p =
       CALLOC(dim_size, double);

    if (cell_a_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       cell_a_p[i] = cell_a[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_a(file,
                                          (const double*) cell_a_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_a(file,
                                          (const double*) cell_a_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_a(file, cell_a_p, rank, dims);
        break;
      */
      FREE(cell_a_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_a(file, cell_a, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_a(file, cell_a, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_a(file, cell_a, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_cell_b_64 (trexio_t* const file, const double* cell_b)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (cell_b == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_b(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* cell_b_p =
       CALLOC(dim_size, double);

    if (cell_b_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       cell_b_p[i] = cell_b[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_b(file,
                                          (const double*) cell_b_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_b(file,
                                          (const double*) cell_b_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_b(file, cell_b_p, rank, dims);
        break;
      */
      FREE(cell_b_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_b(file, cell_b, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_b(file, cell_b, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_b(file, cell_b, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_cell_c_64 (trexio_t* const file, const double* cell_c)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (cell_c == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_c(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* cell_c_p =
       CALLOC(dim_size, double);

    if (cell_c_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       cell_c_p[i] = cell_c[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_c(file,
                                          (const double*) cell_c_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_c(file,
                                          (const double*) cell_c_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_c(file, cell_c_p, rank, dims);
        break;
      */
      FREE(cell_c_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_c(file, cell_c, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_c(file, cell_c, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_c(file, cell_c, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_cell_g_a_64 (trexio_t* const file, const double* cell_g_a)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (cell_g_a == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_a(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* cell_g_a_p =
       CALLOC(dim_size, double);

    if (cell_g_a_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       cell_g_a_p[i] = cell_g_a[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_g_a(file,
                                          (const double*) cell_g_a_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_g_a(file,
                                          (const double*) cell_g_a_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_g_a(file, cell_g_a_p, rank, dims);
        break;
      */
      FREE(cell_g_a_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_g_a(file, cell_g_a, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_g_a(file, cell_g_a, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_g_a(file, cell_g_a, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_cell_g_b_64 (trexio_t* const file, const double* cell_g_b)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (cell_g_b == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_b(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* cell_g_b_p =
       CALLOC(dim_size, double);

    if (cell_g_b_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       cell_g_b_p[i] = cell_g_b[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_g_b(file,
                                          (const double*) cell_g_b_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_g_b(file,
                                          (const double*) cell_g_b_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_g_b(file, cell_g_b_p, rank, dims);
        break;
      */
      FREE(cell_g_b_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_g_b(file, cell_g_b, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_g_b(file, cell_g_b, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_g_b(file, cell_g_b, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_cell_g_c_64 (trexio_t* const file, const double* cell_g_c)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (cell_g_c == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_c(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* cell_g_c_p =
       CALLOC(dim_size, double);

    if (cell_g_c_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       cell_g_c_p[i] = cell_g_c[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_g_c(file,
                                          (const double*) cell_g_c_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_g_c(file,
                                          (const double*) cell_g_c_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_g_c(file, cell_g_c_p, rank, dims);
        break;
      */
      FREE(cell_g_c_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_cell_g_c(file, cell_g_c, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_cell_g_c(file, cell_g_c, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_cell_g_c(file, cell_g_c, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_pbc_k_point_64 (trexio_t* const file, const double* pbc_k_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (pbc_k_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */


  uint32_t rank = 1;
  uint64_t dims[1] = {3};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* pbc_k_point_p =
       CALLOC(dim_size, double);

    if (pbc_k_point_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       pbc_k_point_p[i] = pbc_k_point[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_pbc_k_point(file,
                                          (const double*) pbc_k_point_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_pbc_k_point(file,
                                          (const double*) pbc_k_point_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_pbc_k_point(file, pbc_k_point_p, rank, dims);
        break;
      */
      FREE(pbc_k_point_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_pbc_k_point(file, pbc_k_point, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_pbc_k_point(file, pbc_k_point, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_pbc_k_point(file, pbc_k_point, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_pbc_k_point_weight_64 (trexio_t* const file, const double* pbc_k_point_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (pbc_k_point_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t pbc_k_point_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_pbc_k_point_num_64(file, &(pbc_k_point_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (pbc_k_point_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {pbc_k_point_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* pbc_k_point_weight_p =
       CALLOC(dim_size, double);

    if (pbc_k_point_weight_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       pbc_k_point_weight_p[i] = pbc_k_point_weight[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_pbc_k_point_weight(file,
                                          (const double*) pbc_k_point_weight_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_pbc_k_point_weight(file,
                                          (const double*) pbc_k_point_weight_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_pbc_k_point_weight(file, pbc_k_point_weight_p, rank, dims);
        break;
      */
      FREE(pbc_k_point_weight_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_pbc_k_point_weight(file, pbc_k_point_weight, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_pbc_k_point_weight(file, pbc_k_point_weight, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_pbc_k_point_weight(file, pbc_k_point_weight, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_nucleus_index_64 (trexio_t* const file, const int64_t* basis_nucleus_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_nucleus_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nucleus_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  if (file->one_based) {
    /* Handle index type : is_index = file->one_based */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* basis_nucleus_index_p =
       CALLOC(dim_size, int64_t);

    if (basis_nucleus_index_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_nucleus_index_p[i] = basis_nucleus_index[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nucleus_index(file,
                                          (const int64_t*) basis_nucleus_index_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nucleus_index(file,
                                          (const int64_t*) basis_nucleus_index_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nucleus_index(file, basis_nucleus_index_p, rank, dims);
        break;
      */
      FREE(basis_nucleus_index_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nucleus_index(file, basis_nucleus_index, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nucleus_index(file, basis_nucleus_index, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nucleus_index(file, basis_nucleus_index, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_shell_ang_mom_64 (trexio_t* const file, const int64_t* basis_shell_ang_mom)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_shell_ang_mom == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_ang_mom(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* basis_shell_ang_mom_p =
       CALLOC(dim_size, int64_t);

    if (basis_shell_ang_mom_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_shell_ang_mom_p[i] = basis_shell_ang_mom[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_shell_ang_mom(file,
                                          (const int64_t*) basis_shell_ang_mom_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_shell_ang_mom(file,
                                          (const int64_t*) basis_shell_ang_mom_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_shell_ang_mom(file, basis_shell_ang_mom_p, rank, dims);
        break;
      */
      FREE(basis_shell_ang_mom_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_shell_ang_mom(file, basis_shell_ang_mom, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_shell_ang_mom(file, basis_shell_ang_mom, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_shell_ang_mom(file, basis_shell_ang_mom, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_shell_factor_64 (trexio_t* const file, const double* basis_shell_factor)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_shell_factor == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_factor(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_shell_factor_p =
       CALLOC(dim_size, double);

    if (basis_shell_factor_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_shell_factor_p[i] = basis_shell_factor[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_shell_factor(file,
                                          (const double*) basis_shell_factor_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_shell_factor(file,
                                          (const double*) basis_shell_factor_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_shell_factor(file, basis_shell_factor_p, rank, dims);
        break;
      */
      FREE(basis_shell_factor_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_shell_factor(file, basis_shell_factor, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_shell_factor(file, basis_shell_factor, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_shell_factor(file, basis_shell_factor, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_r_power_64 (trexio_t* const file, const int64_t* basis_r_power)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_r_power == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_r_power(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* basis_r_power_p =
       CALLOC(dim_size, int64_t);

    if (basis_r_power_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_r_power_p[i] = basis_r_power[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_r_power(file,
                                          (const int64_t*) basis_r_power_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_r_power(file,
                                          (const int64_t*) basis_r_power_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_r_power(file, basis_r_power_p, rank, dims);
        break;
      */
      FREE(basis_r_power_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_r_power(file, basis_r_power, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_r_power(file, basis_r_power, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_r_power(file, basis_r_power, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_nao_grid_start_64 (trexio_t* const file, const int64_t* basis_nao_grid_start)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_nao_grid_start == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_start(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  if (file->one_based) {
    /* Handle index type : is_index = file->one_based */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* basis_nao_grid_start_p =
       CALLOC(dim_size, int64_t);

    if (basis_nao_grid_start_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_start_p[i] = basis_nao_grid_start[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_start(file,
                                          (const int64_t*) basis_nao_grid_start_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_start(file,
                                          (const int64_t*) basis_nao_grid_start_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_start(file, basis_nao_grid_start_p, rank, dims);
        break;
      */
      FREE(basis_nao_grid_start_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_start(file, basis_nao_grid_start, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_start(file, basis_nao_grid_start, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_start(file, basis_nao_grid_start, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_nao_grid_size_64 (trexio_t* const file, const int64_t* basis_nao_grid_size)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_nao_grid_size == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_size(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_shell_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_shell_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* basis_nao_grid_size_p =
       CALLOC(dim_size, int64_t);

    if (basis_nao_grid_size_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_size_p[i] = basis_nao_grid_size[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_size(file,
                                          (const int64_t*) basis_nao_grid_size_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_size(file,
                                          (const int64_t*) basis_nao_grid_size_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_size(file, basis_nao_grid_size_p, rank, dims);
        break;
      */
      FREE(basis_nao_grid_size_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_size(file, basis_nao_grid_size, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_size(file, basis_nao_grid_size, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_size(file, basis_nao_grid_size, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_shell_index_64 (trexio_t* const file, const int64_t* basis_shell_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_shell_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  if (file->one_based) {
    /* Handle index type : is_index = file->one_based */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* basis_shell_index_p =
       CALLOC(dim_size, int64_t);

    if (basis_shell_index_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_shell_index_p[i] = basis_shell_index[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_shell_index(file,
                                          (const int64_t*) basis_shell_index_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_shell_index(file,
                                          (const int64_t*) basis_shell_index_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_shell_index(file, basis_shell_index_p, rank, dims);
        break;
      */
      FREE(basis_shell_index_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_shell_index(file, basis_shell_index, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_shell_index(file, basis_shell_index, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_shell_index(file, basis_shell_index, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_exponent_64 (trexio_t* const file, const double* basis_exponent)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_exponent == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_exponent_p =
       CALLOC(dim_size, double);

    if (basis_exponent_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_exponent_p[i] = basis_exponent[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_exponent(file,
                                          (const double*) basis_exponent_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_exponent(file,
                                          (const double*) basis_exponent_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_exponent(file, basis_exponent_p, rank, dims);
        break;
      */
      FREE(basis_exponent_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_exponent(file, basis_exponent, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_exponent(file, basis_exponent, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_exponent(file, basis_exponent, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_exponent_im_64 (trexio_t* const file, const double* basis_exponent_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_exponent_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_exponent_im_p =
       CALLOC(dim_size, double);

    if (basis_exponent_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_exponent_im_p[i] = basis_exponent_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_exponent_im(file,
                                          (const double*) basis_exponent_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_exponent_im(file,
                                          (const double*) basis_exponent_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_exponent_im(file, basis_exponent_im_p, rank, dims);
        break;
      */
      FREE(basis_exponent_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_exponent_im(file, basis_exponent_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_exponent_im(file, basis_exponent_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_exponent_im(file, basis_exponent_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_coefficient_64 (trexio_t* const file, const double* basis_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_coefficient_p =
       CALLOC(dim_size, double);

    if (basis_coefficient_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_coefficient_p[i] = basis_coefficient[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_coefficient(file,
                                          (const double*) basis_coefficient_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_coefficient(file,
                                          (const double*) basis_coefficient_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_coefficient(file, basis_coefficient_p, rank, dims);
        break;
      */
      FREE(basis_coefficient_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_coefficient(file, basis_coefficient, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_coefficient(file, basis_coefficient, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_coefficient(file, basis_coefficient, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_coefficient_im_64 (trexio_t* const file, const double* basis_coefficient_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_coefficient_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_coefficient_im_p =
       CALLOC(dim_size, double);

    if (basis_coefficient_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_coefficient_im_p[i] = basis_coefficient_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_coefficient_im(file,
                                          (const double*) basis_coefficient_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_coefficient_im(file,
                                          (const double*) basis_coefficient_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_coefficient_im(file, basis_coefficient_im_p, rank, dims);
        break;
      */
      FREE(basis_coefficient_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_coefficient_im(file, basis_coefficient_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_coefficient_im(file, basis_coefficient_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_coefficient_im(file, basis_coefficient_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_oscillation_arg_64 (trexio_t* const file, const double* basis_oscillation_arg)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_oscillation_arg == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_oscillation_arg(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_oscillation_arg_p =
       CALLOC(dim_size, double);

    if (basis_oscillation_arg_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_oscillation_arg_p[i] = basis_oscillation_arg[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_oscillation_arg(file,
                                          (const double*) basis_oscillation_arg_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_oscillation_arg(file,
                                          (const double*) basis_oscillation_arg_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_oscillation_arg(file, basis_oscillation_arg_p, rank, dims);
        break;
      */
      FREE(basis_oscillation_arg_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_oscillation_arg(file, basis_oscillation_arg, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_oscillation_arg(file, basis_oscillation_arg, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_oscillation_arg(file, basis_oscillation_arg, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_prim_factor_64 (trexio_t* const file, const double* basis_prim_factor)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_prim_factor == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_factor(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_prim_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_prim_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_prim_factor_p =
       CALLOC(dim_size, double);

    if (basis_prim_factor_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_prim_factor_p[i] = basis_prim_factor[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_prim_factor(file,
                                          (const double*) basis_prim_factor_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_prim_factor(file,
                                          (const double*) basis_prim_factor_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_prim_factor(file, basis_prim_factor_p, rank, dims);
        break;
      */
      FREE(basis_prim_factor_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_prim_factor(file, basis_prim_factor, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_prim_factor(file, basis_prim_factor, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_prim_factor(file, basis_prim_factor, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_nao_grid_radius_64 (trexio_t* const file, const double* basis_nao_grid_radius)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_nao_grid_radius == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_radius(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_nao_grid_radius_p =
       CALLOC(dim_size, double);

    if (basis_nao_grid_radius_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_radius_p[i] = basis_nao_grid_radius[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_radius(file,
                                          (const double*) basis_nao_grid_radius_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_radius(file,
                                          (const double*) basis_nao_grid_radius_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_radius(file, basis_nao_grid_radius_p, rank, dims);
        break;
      */
      FREE(basis_nao_grid_radius_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_radius(file, basis_nao_grid_radius, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_radius(file, basis_nao_grid_radius, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_radius(file, basis_nao_grid_radius, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_nao_grid_phi_64 (trexio_t* const file, const double* basis_nao_grid_phi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_nao_grid_phi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_phi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_nao_grid_phi_p =
       CALLOC(dim_size, double);

    if (basis_nao_grid_phi_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_phi_p[i] = basis_nao_grid_phi[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_phi(file,
                                          (const double*) basis_nao_grid_phi_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_phi(file,
                                          (const double*) basis_nao_grid_phi_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_phi(file, basis_nao_grid_phi_p, rank, dims);
        break;
      */
      FREE(basis_nao_grid_phi_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_phi(file, basis_nao_grid_phi, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_phi(file, basis_nao_grid_phi, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_phi(file, basis_nao_grid_phi, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_nao_grid_grad_64 (trexio_t* const file, const double* basis_nao_grid_grad)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_nao_grid_grad == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_grad(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_nao_grid_grad_p =
       CALLOC(dim_size, double);

    if (basis_nao_grid_grad_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_grad_p[i] = basis_nao_grid_grad[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_grad(file,
                                          (const double*) basis_nao_grid_grad_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_grad(file,
                                          (const double*) basis_nao_grid_grad_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_grad(file, basis_nao_grid_grad_p, rank, dims);
        break;
      */
      FREE(basis_nao_grid_grad_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_grad(file, basis_nao_grid_grad, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_grad(file, basis_nao_grid_grad, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_grad(file, basis_nao_grid_grad, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_nao_grid_lap_64 (trexio_t* const file, const double* basis_nao_grid_lap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_nao_grid_lap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_lap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {basis_nao_grid_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_nao_grid_lap_p =
       CALLOC(dim_size, double);

    if (basis_nao_grid_lap_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_nao_grid_lap_p[i] = basis_nao_grid_lap[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_lap(file,
                                          (const double*) basis_nao_grid_lap_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_lap(file,
                                          (const double*) basis_nao_grid_lap_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_lap(file, basis_nao_grid_lap_p, rank, dims);
        break;
      */
      FREE(basis_nao_grid_lap_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_nao_grid_lap(file, basis_nao_grid_lap, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_nao_grid_lap(file, basis_nao_grid_lap, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_nao_grid_lap(file, basis_nao_grid_lap, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_interpolator_phi_64 (trexio_t* const file, const double* basis_interpolator_phi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_interpolator_phi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_phi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_interpolator_phi_p =
       CALLOC(dim_size, double);

    if (basis_interpolator_phi_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_interpolator_phi_p[i] = basis_interpolator_phi[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_interpolator_phi(file,
                                          (const double*) basis_interpolator_phi_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_interpolator_phi(file,
                                          (const double*) basis_interpolator_phi_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_interpolator_phi(file, basis_interpolator_phi_p, rank, dims);
        break;
      */
      FREE(basis_interpolator_phi_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_interpolator_phi(file, basis_interpolator_phi, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_interpolator_phi(file, basis_interpolator_phi, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_interpolator_phi(file, basis_interpolator_phi, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_interpolator_grad_64 (trexio_t* const file, const double* basis_interpolator_grad)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_interpolator_grad == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_grad(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_interpolator_grad_p =
       CALLOC(dim_size, double);

    if (basis_interpolator_grad_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_interpolator_grad_p[i] = basis_interpolator_grad[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_interpolator_grad(file,
                                          (const double*) basis_interpolator_grad_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_interpolator_grad(file,
                                          (const double*) basis_interpolator_grad_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_interpolator_grad(file, basis_interpolator_grad_p, rank, dims);
        break;
      */
      FREE(basis_interpolator_grad_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_interpolator_grad(file, basis_interpolator_grad, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_interpolator_grad(file, basis_interpolator_grad, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_interpolator_grad(file, basis_interpolator_grad, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_basis_interpolator_lap_64 (trexio_t* const file, const double* basis_interpolator_lap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (basis_interpolator_lap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_lap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t basis_nao_grid_num = 0;
  int64_t basis_interp_coeff_cnt = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
  if (rc != TREXIO_SUCCESS) return rc;

  if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
  if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* basis_interpolator_lap_p =
       CALLOC(dim_size, double);

    if (basis_interpolator_lap_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       basis_interpolator_lap_p[i] = basis_interpolator_lap[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_interpolator_lap(file,
                                          (const double*) basis_interpolator_lap_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_interpolator_lap(file,
                                          (const double*) basis_interpolator_lap_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_interpolator_lap(file, basis_interpolator_lap_p, rank, dims);
        break;
      */
      FREE(basis_interpolator_lap_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_basis_interpolator_lap(file, basis_interpolator_lap, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_basis_interpolator_lap(file, basis_interpolator_lap, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_basis_interpolator_lap(file, basis_interpolator_lap, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ecp_max_ang_mom_plus_1_64 (trexio_t* const file, const int64_t* ecp_max_ang_mom_plus_1)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ecp_max_ang_mom_plus_1 == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_max_ang_mom_plus_1(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* ecp_max_ang_mom_plus_1_p =
       CALLOC(dim_size, int64_t);

    if (ecp_max_ang_mom_plus_1_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ecp_max_ang_mom_plus_1_p[i] = ecp_max_ang_mom_plus_1[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_max_ang_mom_plus_1(file,
                                          (const int64_t*) ecp_max_ang_mom_plus_1_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_max_ang_mom_plus_1(file,
                                          (const int64_t*) ecp_max_ang_mom_plus_1_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1_p, rank, dims);
        break;
      */
      FREE(ecp_max_ang_mom_plus_1_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_max_ang_mom_plus_1(file, ecp_max_ang_mom_plus_1, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ecp_z_core_64 (trexio_t* const file, const int64_t* ecp_z_core)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ecp_z_core == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_z_core(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* ecp_z_core_p =
       CALLOC(dim_size, int64_t);

    if (ecp_z_core_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ecp_z_core_p[i] = ecp_z_core[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_z_core(file,
                                          (const int64_t*) ecp_z_core_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_z_core(file,
                                          (const int64_t*) ecp_z_core_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_z_core(file, ecp_z_core_p, rank, dims);
        break;
      */
      FREE(ecp_z_core_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_z_core(file, ecp_z_core, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_z_core(file, ecp_z_core, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_z_core(file, ecp_z_core, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ecp_ang_mom_64 (trexio_t* const file, const int64_t* ecp_ang_mom)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ecp_ang_mom == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_ang_mom(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* ecp_ang_mom_p =
       CALLOC(dim_size, int64_t);

    if (ecp_ang_mom_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ecp_ang_mom_p[i] = ecp_ang_mom[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_ang_mom(file,
                                          (const int64_t*) ecp_ang_mom_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_ang_mom(file,
                                          (const int64_t*) ecp_ang_mom_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_ang_mom(file, ecp_ang_mom_p, rank, dims);
        break;
      */
      FREE(ecp_ang_mom_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_ang_mom(file, ecp_ang_mom, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_ang_mom(file, ecp_ang_mom, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_ang_mom(file, ecp_ang_mom, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ecp_nucleus_index_64 (trexio_t* const file, const int64_t* ecp_nucleus_index)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ecp_nucleus_index == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_nucleus_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  if (file->one_based) {
    /* Handle index type : is_index = file->one_based */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* ecp_nucleus_index_p =
       CALLOC(dim_size, int64_t);

    if (ecp_nucleus_index_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ecp_nucleus_index_p[i] = ecp_nucleus_index[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_nucleus_index(file,
                                          (const int64_t*) ecp_nucleus_index_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_nucleus_index(file,
                                          (const int64_t*) ecp_nucleus_index_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_nucleus_index(file, ecp_nucleus_index_p, rank, dims);
        break;
      */
      FREE(ecp_nucleus_index_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_nucleus_index(file, ecp_nucleus_index, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_nucleus_index(file, ecp_nucleus_index, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_nucleus_index(file, ecp_nucleus_index, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ecp_exponent_64 (trexio_t* const file, const double* ecp_exponent)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ecp_exponent == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_exponent(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ecp_exponent_p =
       CALLOC(dim_size, double);

    if (ecp_exponent_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ecp_exponent_p[i] = ecp_exponent[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_exponent(file,
                                          (const double*) ecp_exponent_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_exponent(file,
                                          (const double*) ecp_exponent_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_exponent(file, ecp_exponent_p, rank, dims);
        break;
      */
      FREE(ecp_exponent_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_exponent(file, ecp_exponent, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_exponent(file, ecp_exponent, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_exponent(file, ecp_exponent, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ecp_coefficient_64 (trexio_t* const file, const double* ecp_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ecp_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ecp_coefficient_p =
       CALLOC(dim_size, double);

    if (ecp_coefficient_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ecp_coefficient_p[i] = ecp_coefficient[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_coefficient(file,
                                          (const double*) ecp_coefficient_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_coefficient(file,
                                          (const double*) ecp_coefficient_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_coefficient(file, ecp_coefficient_p, rank, dims);
        break;
      */
      FREE(ecp_coefficient_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_coefficient(file, ecp_coefficient, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_coefficient(file, ecp_coefficient, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_coefficient(file, ecp_coefficient, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ecp_power_64 (trexio_t* const file, const int64_t* ecp_power)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ecp_power == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_power(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ecp_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ecp_num_64(file, &(ecp_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ecp_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ecp_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* ecp_power_p =
       CALLOC(dim_size, int64_t);

    if (ecp_power_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ecp_power_p[i] = ecp_power[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_power(file,
                                          (const int64_t*) ecp_power_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_power(file,
                                          (const int64_t*) ecp_power_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_power(file, ecp_power_p, rank, dims);
        break;
      */
      FREE(ecp_power_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ecp_power(file, ecp_power, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ecp_power(file, ecp_power, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ecp_power(file, ecp_power, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_grid_coord_64 (trexio_t* const file, const double* grid_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (grid_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_num_64(file, &(grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* grid_coord_p =
       CALLOC(dim_size, double);

    if (grid_coord_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       grid_coord_p[i] = grid_coord[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_coord(file,
                                          (const double*) grid_coord_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_coord(file,
                                          (const double*) grid_coord_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_coord(file, grid_coord_p, rank, dims);
        break;
      */
      FREE(grid_coord_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_coord(file, grid_coord, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_coord(file, grid_coord, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_coord(file, grid_coord, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_grid_weight_64 (trexio_t* const file, const double* grid_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (grid_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_num_64(file, &(grid_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* grid_weight_p =
       CALLOC(dim_size, double);

    if (grid_weight_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       grid_weight_p[i] = grid_weight[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_weight(file,
                                          (const double*) grid_weight_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_weight(file,
                                          (const double*) grid_weight_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_weight(file, grid_weight_p, rank, dims);
        break;
      */
      FREE(grid_weight_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_weight(file, grid_weight, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_weight(file, grid_weight, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_weight(file, grid_weight, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_grid_ang_coord_64 (trexio_t* const file, const double* grid_ang_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (grid_ang_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_ang_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_ang_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* grid_ang_coord_p =
       CALLOC(dim_size, double);

    if (grid_ang_coord_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       grid_ang_coord_p[i] = grid_ang_coord[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_ang_coord(file,
                                          (const double*) grid_ang_coord_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_ang_coord(file,
                                          (const double*) grid_ang_coord_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_ang_coord(file, grid_ang_coord_p, rank, dims);
        break;
      */
      FREE(grid_ang_coord_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_ang_coord(file, grid_ang_coord, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_ang_coord(file, grid_ang_coord, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_ang_coord(file, grid_ang_coord, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_grid_ang_weight_64 (trexio_t* const file, const double* grid_ang_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (grid_ang_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_ang_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_ang_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* grid_ang_weight_p =
       CALLOC(dim_size, double);

    if (grid_ang_weight_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       grid_ang_weight_p[i] = grid_ang_weight[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_ang_weight(file,
                                          (const double*) grid_ang_weight_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_ang_weight(file,
                                          (const double*) grid_ang_weight_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_ang_weight(file, grid_ang_weight_p, rank, dims);
        break;
      */
      FREE(grid_ang_weight_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_ang_weight(file, grid_ang_weight, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_ang_weight(file, grid_ang_weight, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_ang_weight(file, grid_ang_weight, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_grid_rad_coord_64 (trexio_t* const file, const double* grid_rad_coord)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (grid_rad_coord == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_rad_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_rad_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* grid_rad_coord_p =
       CALLOC(dim_size, double);

    if (grid_rad_coord_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       grid_rad_coord_p[i] = grid_rad_coord[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_rad_coord(file,
                                          (const double*) grid_rad_coord_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_rad_coord(file,
                                          (const double*) grid_rad_coord_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_rad_coord(file, grid_rad_coord_p, rank, dims);
        break;
      */
      FREE(grid_rad_coord_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_rad_coord(file, grid_rad_coord, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_rad_coord(file, grid_rad_coord, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_rad_coord(file, grid_rad_coord, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_grid_rad_weight_64 (trexio_t* const file, const double* grid_rad_weight)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (grid_rad_weight == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t grid_rad_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {grid_rad_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* grid_rad_weight_p =
       CALLOC(dim_size, double);

    if (grid_rad_weight_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       grid_rad_weight_p[i] = grid_rad_weight[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_rad_weight(file,
                                          (const double*) grid_rad_weight_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_rad_weight(file,
                                          (const double*) grid_rad_weight_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_rad_weight(file, grid_rad_weight_p, rank, dims);
        break;
      */
      FREE(grid_rad_weight_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_grid_rad_weight(file, grid_rad_weight, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_grid_rad_weight(file, grid_rad_weight, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_grid_rad_weight(file, grid_rad_weight, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_shell_64 (trexio_t* const file, const int64_t* ao_shell)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_shell == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_shell(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ao_num};

  if (file->one_based) {
    /* Handle index type : is_index = file->one_based */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* ao_shell_p =
       CALLOC(dim_size, int64_t);

    if (ao_shell_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_shell_p[i] = ao_shell[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_shell(file,
                                          (const int64_t*) ao_shell_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_shell(file,
                                          (const int64_t*) ao_shell_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_shell(file, ao_shell_p, rank, dims);
        break;
      */
      FREE(ao_shell_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_shell(file, ao_shell, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_shell(file, ao_shell, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_shell(file, ao_shell, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_normalization_64 (trexio_t* const file, const double* ao_normalization)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_normalization == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_normalization(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_normalization_p =
       CALLOC(dim_size, double);

    if (ao_normalization_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_normalization_p[i] = ao_normalization[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_normalization(file,
                                          (const double*) ao_normalization_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_normalization(file,
                                          (const double*) ao_normalization_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_normalization(file, ao_normalization_p, rank, dims);
        break;
      */
      FREE(ao_normalization_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_normalization(file, ao_normalization, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_normalization(file, ao_normalization, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_normalization(file, ao_normalization, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_overlap_64 (trexio_t* const file, const double* ao_1e_int_overlap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_overlap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_overlap_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_overlap_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_overlap_p[i] = ao_1e_int_overlap[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_overlap(file,
                                          (const double*) ao_1e_int_overlap_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_overlap(file,
                                          (const double*) ao_1e_int_overlap_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_overlap(file, ao_1e_int_overlap_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_overlap_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_overlap(file, ao_1e_int_overlap, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_overlap(file, ao_1e_int_overlap, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_overlap(file, ao_1e_int_overlap, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_kinetic_64 (trexio_t* const file, const double* ao_1e_int_kinetic)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_kinetic == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_kinetic_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_kinetic_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_kinetic_p[i] = ao_1e_int_kinetic[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_kinetic(file,
                                          (const double*) ao_1e_int_kinetic_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_kinetic(file,
                                          (const double*) ao_1e_int_kinetic_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_kinetic(file, ao_1e_int_kinetic_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_kinetic_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_kinetic(file, ao_1e_int_kinetic, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_kinetic(file, ao_1e_int_kinetic, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_kinetic(file, ao_1e_int_kinetic, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_potential_n_e_64 (trexio_t* const file, const double* ao_1e_int_potential_n_e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_potential_n_e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_potential_n_e_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_potential_n_e_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_potential_n_e_p[i] = ao_1e_int_potential_n_e[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_potential_n_e(file,
                                          (const double*) ao_1e_int_potential_n_e_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_potential_n_e(file,
                                          (const double*) ao_1e_int_potential_n_e_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_potential_n_e_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_potential_n_e(file, ao_1e_int_potential_n_e, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_ecp_64 (trexio_t* const file, const double* ao_1e_int_ecp)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_ecp == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_ecp_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_ecp_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_ecp_p[i] = ao_1e_int_ecp[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_ecp(file,
                                          (const double*) ao_1e_int_ecp_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_ecp(file,
                                          (const double*) ao_1e_int_ecp_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_ecp(file, ao_1e_int_ecp_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_ecp_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_ecp(file, ao_1e_int_ecp, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_ecp(file, ao_1e_int_ecp, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_ecp(file, ao_1e_int_ecp, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_core_hamiltonian_64 (trexio_t* const file, const double* ao_1e_int_core_hamiltonian)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_core_hamiltonian == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_core_hamiltonian_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_core_hamiltonian_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_core_hamiltonian_p[i] = ao_1e_int_core_hamiltonian[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_core_hamiltonian(file,
                                          (const double*) ao_1e_int_core_hamiltonian_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_core_hamiltonian(file,
                                          (const double*) ao_1e_int_core_hamiltonian_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_core_hamiltonian_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_core_hamiltonian(file, ao_1e_int_core_hamiltonian, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_overlap_im_64 (trexio_t* const file, const double* ao_1e_int_overlap_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_overlap_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_overlap_im_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_overlap_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_overlap_im_p[i] = ao_1e_int_overlap_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_overlap_im(file,
                                          (const double*) ao_1e_int_overlap_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_overlap_im(file,
                                          (const double*) ao_1e_int_overlap_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_overlap_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_overlap_im(file, ao_1e_int_overlap_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_kinetic_im_64 (trexio_t* const file, const double* ao_1e_int_kinetic_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_kinetic_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_kinetic_im_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_kinetic_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_kinetic_im_p[i] = ao_1e_int_kinetic_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_kinetic_im(file,
                                          (const double*) ao_1e_int_kinetic_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_kinetic_im(file,
                                          (const double*) ao_1e_int_kinetic_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_kinetic_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_kinetic_im(file, ao_1e_int_kinetic_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_potential_n_e_im_64 (trexio_t* const file, const double* ao_1e_int_potential_n_e_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_potential_n_e_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_potential_n_e_im_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_potential_n_e_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_potential_n_e_im_p[i] = ao_1e_int_potential_n_e_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_potential_n_e_im(file,
                                          (const double*) ao_1e_int_potential_n_e_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_potential_n_e_im(file,
                                          (const double*) ao_1e_int_potential_n_e_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_potential_n_e_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_potential_n_e_im(file, ao_1e_int_potential_n_e_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_ecp_im_64 (trexio_t* const file, const double* ao_1e_int_ecp_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_ecp_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_ecp_im_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_ecp_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_ecp_im_p[i] = ao_1e_int_ecp_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_ecp_im(file,
                                          (const double*) ao_1e_int_ecp_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_ecp_im(file,
                                          (const double*) ao_1e_int_ecp_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_ecp_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_ecp_im(file, ao_1e_int_ecp_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_ao_1e_int_core_hamiltonian_im_64 (trexio_t* const file, const double* ao_1e_int_core_hamiltonian_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (ao_1e_int_core_hamiltonian_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {ao_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* ao_1e_int_core_hamiltonian_im_p =
       CALLOC(dim_size, double);

    if (ao_1e_int_core_hamiltonian_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       ao_1e_int_core_hamiltonian_im_p[i] = ao_1e_int_core_hamiltonian_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_core_hamiltonian_im(file,
                                          (const double*) ao_1e_int_core_hamiltonian_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_core_hamiltonian_im(file,
                                          (const double*) ao_1e_int_core_hamiltonian_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im_p, rank, dims);
        break;
      */
      FREE(ao_1e_int_core_hamiltonian_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_1e_int_core_hamiltonian_im(file, ao_1e_int_core_hamiltonian_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_coefficient_64 (trexio_t* const file, const double* mo_coefficient)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_coefficient == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;
  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;
  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_coefficient_p =
       CALLOC(dim_size, double);

    if (mo_coefficient_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_coefficient_p[i] = mo_coefficient[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_coefficient(file,
                                          (const double*) mo_coefficient_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_coefficient(file,
                                          (const double*) mo_coefficient_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_coefficient(file, mo_coefficient_p, rank, dims);
        break;
      */
      FREE(mo_coefficient_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_coefficient(file, mo_coefficient, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_coefficient(file, mo_coefficient, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_coefficient(file, mo_coefficient, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_coefficient_im_64 (trexio_t* const file, const double* mo_coefficient_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_coefficient_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;
  int64_t ao_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_num_64(file, &(ao_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;
  if (ao_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, ao_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_coefficient_im_p =
       CALLOC(dim_size, double);

    if (mo_coefficient_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_coefficient_im_p[i] = mo_coefficient_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_coefficient_im(file,
                                          (const double*) mo_coefficient_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_coefficient_im(file,
                                          (const double*) mo_coefficient_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_coefficient_im(file, mo_coefficient_im_p, rank, dims);
        break;
      */
      FREE(mo_coefficient_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_coefficient_im(file, mo_coefficient_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_coefficient_im(file, mo_coefficient_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_coefficient_im(file, mo_coefficient_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_occupation_64 (trexio_t* const file, const double* mo_occupation)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_occupation == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_occupation(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_occupation_p =
       CALLOC(dim_size, double);

    if (mo_occupation_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_occupation_p[i] = mo_occupation[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_occupation(file,
                                          (const double*) mo_occupation_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_occupation(file,
                                          (const double*) mo_occupation_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_occupation(file, mo_occupation_p, rank, dims);
        break;
      */
      FREE(mo_occupation_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_occupation(file, mo_occupation, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_occupation(file, mo_occupation, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_occupation(file, mo_occupation, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_energy_64 (trexio_t* const file, const double* mo_energy)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_energy == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_energy(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_energy_p =
       CALLOC(dim_size, double);

    if (mo_energy_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_energy_p[i] = mo_energy[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_energy(file,
                                          (const double*) mo_energy_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_energy(file,
                                          (const double*) mo_energy_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_energy(file, mo_energy_p, rank, dims);
        break;
      */
      FREE(mo_energy_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_energy(file, mo_energy, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_energy(file, mo_energy, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_energy(file, mo_energy, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_spin_64 (trexio_t* const file, const int64_t* mo_spin)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_spin == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_spin(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* mo_spin_p =
       CALLOC(dim_size, int64_t);

    if (mo_spin_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_spin_p[i] = mo_spin[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_spin(file,
                                          (const int64_t*) mo_spin_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_spin(file,
                                          (const int64_t*) mo_spin_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_spin(file, mo_spin_p, rank, dims);
        break;
      */
      FREE(mo_spin_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_spin(file, mo_spin, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_spin(file, mo_spin, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_spin(file, mo_spin, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_k_point_64 (trexio_t* const file, const int64_t* mo_k_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_k_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_k_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  if (file->one_based) {
    /* Handle index type : is_index = file->one_based */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* mo_k_point_p =
       CALLOC(dim_size, int64_t);

    if (mo_k_point_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_k_point_p[i] = mo_k_point[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_k_point(file,
                                          (const int64_t*) mo_k_point_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_k_point(file,
                                          (const int64_t*) mo_k_point_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_k_point(file, mo_k_point_p, rank, dims);
        break;
      */
      FREE(mo_k_point_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_k_point(file, mo_k_point, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_k_point(file, mo_k_point, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_k_point(file, mo_k_point, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_overlap_64 (trexio_t* const file, const double* mo_1e_int_overlap)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_overlap == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_overlap_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_overlap_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_overlap_p[i] = mo_1e_int_overlap[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_overlap(file,
                                          (const double*) mo_1e_int_overlap_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_overlap(file,
                                          (const double*) mo_1e_int_overlap_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_overlap(file, mo_1e_int_overlap_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_overlap_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_overlap(file, mo_1e_int_overlap, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_overlap(file, mo_1e_int_overlap, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_overlap(file, mo_1e_int_overlap, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_kinetic_64 (trexio_t* const file, const double* mo_1e_int_kinetic)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_kinetic == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_kinetic_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_kinetic_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_kinetic_p[i] = mo_1e_int_kinetic[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_kinetic(file,
                                          (const double*) mo_1e_int_kinetic_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_kinetic(file,
                                          (const double*) mo_1e_int_kinetic_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_kinetic(file, mo_1e_int_kinetic_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_kinetic_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_kinetic(file, mo_1e_int_kinetic, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_kinetic(file, mo_1e_int_kinetic, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_kinetic(file, mo_1e_int_kinetic, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_potential_n_e_64 (trexio_t* const file, const double* mo_1e_int_potential_n_e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_potential_n_e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_potential_n_e_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_potential_n_e_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_potential_n_e_p[i] = mo_1e_int_potential_n_e[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_potential_n_e(file,
                                          (const double*) mo_1e_int_potential_n_e_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_potential_n_e(file,
                                          (const double*) mo_1e_int_potential_n_e_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_potential_n_e_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_potential_n_e(file, mo_1e_int_potential_n_e, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_ecp_64 (trexio_t* const file, const double* mo_1e_int_ecp)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_ecp == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_ecp_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_ecp_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_ecp_p[i] = mo_1e_int_ecp[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_ecp(file,
                                          (const double*) mo_1e_int_ecp_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_ecp(file,
                                          (const double*) mo_1e_int_ecp_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_ecp(file, mo_1e_int_ecp_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_ecp_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_ecp(file, mo_1e_int_ecp, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_ecp(file, mo_1e_int_ecp, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_ecp(file, mo_1e_int_ecp, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_core_hamiltonian_64 (trexio_t* const file, const double* mo_1e_int_core_hamiltonian)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_core_hamiltonian == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_core_hamiltonian_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_core_hamiltonian_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_core_hamiltonian_p[i] = mo_1e_int_core_hamiltonian[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_core_hamiltonian(file,
                                          (const double*) mo_1e_int_core_hamiltonian_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_core_hamiltonian(file,
                                          (const double*) mo_1e_int_core_hamiltonian_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_core_hamiltonian_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_core_hamiltonian(file, mo_1e_int_core_hamiltonian, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_overlap_im_64 (trexio_t* const file, const double* mo_1e_int_overlap_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_overlap_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_overlap_im_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_overlap_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_overlap_im_p[i] = mo_1e_int_overlap_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_overlap_im(file,
                                          (const double*) mo_1e_int_overlap_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_overlap_im(file,
                                          (const double*) mo_1e_int_overlap_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_overlap_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_overlap_im(file, mo_1e_int_overlap_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_kinetic_im_64 (trexio_t* const file, const double* mo_1e_int_kinetic_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_kinetic_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_kinetic_im_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_kinetic_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_kinetic_im_p[i] = mo_1e_int_kinetic_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_kinetic_im(file,
                                          (const double*) mo_1e_int_kinetic_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_kinetic_im(file,
                                          (const double*) mo_1e_int_kinetic_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_kinetic_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_kinetic_im(file, mo_1e_int_kinetic_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_potential_n_e_im_64 (trexio_t* const file, const double* mo_1e_int_potential_n_e_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_potential_n_e_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_potential_n_e_im_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_potential_n_e_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_potential_n_e_im_p[i] = mo_1e_int_potential_n_e_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_potential_n_e_im(file,
                                          (const double*) mo_1e_int_potential_n_e_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_potential_n_e_im(file,
                                          (const double*) mo_1e_int_potential_n_e_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_potential_n_e_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_potential_n_e_im(file, mo_1e_int_potential_n_e_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_ecp_im_64 (trexio_t* const file, const double* mo_1e_int_ecp_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_ecp_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_ecp_im_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_ecp_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_ecp_im_p[i] = mo_1e_int_ecp_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_ecp_im(file,
                                          (const double*) mo_1e_int_ecp_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_ecp_im(file,
                                          (const double*) mo_1e_int_ecp_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_ecp_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_ecp_im(file, mo_1e_int_ecp_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_mo_1e_int_core_hamiltonian_im_64 (trexio_t* const file, const double* mo_1e_int_core_hamiltonian_im)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (mo_1e_int_core_hamiltonian_im == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* mo_1e_int_core_hamiltonian_im_p =
       CALLOC(dim_size, double);

    if (mo_1e_int_core_hamiltonian_im_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       mo_1e_int_core_hamiltonian_im_p[i] = mo_1e_int_core_hamiltonian_im[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_core_hamiltonian_im(file,
                                          (const double*) mo_1e_int_core_hamiltonian_im_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_core_hamiltonian_im(file,
                                          (const double*) mo_1e_int_core_hamiltonian_im_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im_p, rank, dims);
        break;
      */
      FREE(mo_1e_int_core_hamiltonian_im_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_1e_int_core_hamiltonian_im(file, mo_1e_int_core_hamiltonian_im, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_rdm_1e_64 (trexio_t* const file, const double* rdm_1e)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (rdm_1e == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* rdm_1e_p =
       CALLOC(dim_size, double);

    if (rdm_1e_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       rdm_1e_p[i] = rdm_1e[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_1e(file,
                                          (const double*) rdm_1e_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_1e(file,
                                          (const double*) rdm_1e_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_1e(file, rdm_1e_p, rank, dims);
        break;
      */
      FREE(rdm_1e_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_1e(file, rdm_1e, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_1e(file, rdm_1e, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_1e(file, rdm_1e, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_rdm_1e_up_64 (trexio_t* const file, const double* rdm_1e_up)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (rdm_1e_up == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_up(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* rdm_1e_up_p =
       CALLOC(dim_size, double);

    if (rdm_1e_up_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       rdm_1e_up_p[i] = rdm_1e_up[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_1e_up(file,
                                          (const double*) rdm_1e_up_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_1e_up(file,
                                          (const double*) rdm_1e_up_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_1e_up(file, rdm_1e_up_p, rank, dims);
        break;
      */
      FREE(rdm_1e_up_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_1e_up(file, rdm_1e_up, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_1e_up(file, rdm_1e_up, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_1e_up(file, rdm_1e_up, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_rdm_1e_dn_64 (trexio_t* const file, const double* rdm_1e_dn)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (rdm_1e_dn == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_dn(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 2;
  uint64_t dims[2] = {mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* rdm_1e_dn_p =
       CALLOC(dim_size, double);

    if (rdm_1e_dn_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       rdm_1e_dn_p[i] = rdm_1e_dn[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_1e_dn(file,
                                          (const double*) rdm_1e_dn_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_1e_dn(file,
                                          (const double*) rdm_1e_dn_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_1e_dn(file, rdm_1e_dn_p, rank, dims);
        break;
      */
      FREE(rdm_1e_dn_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_1e_dn(file, rdm_1e_dn, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_1e_dn(file, rdm_1e_dn, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_1e_dn(file, rdm_1e_dn, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_rdm_1e_transition_64 (trexio_t* const file, const double* rdm_1e_transition)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (rdm_1e_transition == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_transition(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t state_num = 0;
  int64_t mo_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_state_num_64(file, &(state_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (state_num == 0L) return TREXIO_INVALID_NUM;
  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 4;
  uint64_t dims[4] = {state_num, state_num, mo_num, mo_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* rdm_1e_transition_p =
       CALLOC(dim_size, double);

    if (rdm_1e_transition_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       rdm_1e_transition_p[i] = rdm_1e_transition[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_1e_transition(file,
                                          (const double*) rdm_1e_transition_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_1e_transition(file,
                                          (const double*) rdm_1e_transition_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_1e_transition(file, rdm_1e_transition_p, rank, dims);
        break;
      */
      FREE(rdm_1e_transition_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_1e_transition(file, rdm_1e_transition, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_1e_transition(file, rdm_1e_transition, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_1e_transition(file, rdm_1e_transition, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_jastrow_en_64 (trexio_t* const file, const double* jastrow_en)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (jastrow_en == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_en_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_en_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* jastrow_en_p =
       CALLOC(dim_size, double);

    if (jastrow_en_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_en_p[i] = jastrow_en[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_en(file,
                                          (const double*) jastrow_en_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_en(file,
                                          (const double*) jastrow_en_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_en(file, jastrow_en_p, rank, dims);
        break;
      */
      FREE(jastrow_en_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_en(file, jastrow_en, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_en(file, jastrow_en, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_en(file, jastrow_en, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_jastrow_ee_64 (trexio_t* const file, const double* jastrow_ee)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (jastrow_ee == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_ee_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_ee_num_64(file, &(jastrow_ee_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_ee_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_ee_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* jastrow_ee_p =
       CALLOC(dim_size, double);

    if (jastrow_ee_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_ee_p[i] = jastrow_ee[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_ee(file,
                                          (const double*) jastrow_ee_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_ee(file,
                                          (const double*) jastrow_ee_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_ee(file, jastrow_ee_p, rank, dims);
        break;
      */
      FREE(jastrow_ee_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_ee(file, jastrow_ee, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_ee(file, jastrow_ee, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_ee(file, jastrow_ee, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_jastrow_een_64 (trexio_t* const file, const double* jastrow_een)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (jastrow_een == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_een_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_een_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* jastrow_een_p =
       CALLOC(dim_size, double);

    if (jastrow_een_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_een_p[i] = jastrow_een[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_een(file,
                                          (const double*) jastrow_een_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_een(file,
                                          (const double*) jastrow_een_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_een(file, jastrow_een_p, rank, dims);
        break;
      */
      FREE(jastrow_een_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_een(file, jastrow_een, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_een(file, jastrow_een, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_een(file, jastrow_een, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_jastrow_en_nucleus_64 (trexio_t* const file, const int64_t* jastrow_en_nucleus)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (jastrow_en_nucleus == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_nucleus(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_en_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_en_num};

  if (file->one_based) {
    /* Handle index type : is_index = file->one_based */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* jastrow_en_nucleus_p =
       CALLOC(dim_size, int64_t);

    if (jastrow_en_nucleus_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_en_nucleus_p[i] = jastrow_en_nucleus[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_en_nucleus(file,
                                          (const int64_t*) jastrow_en_nucleus_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_en_nucleus(file,
                                          (const int64_t*) jastrow_en_nucleus_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_en_nucleus(file, jastrow_en_nucleus_p, rank, dims);
        break;
      */
      FREE(jastrow_en_nucleus_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_en_nucleus(file, jastrow_en_nucleus, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_en_nucleus(file, jastrow_en_nucleus, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_en_nucleus(file, jastrow_en_nucleus, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_jastrow_een_nucleus_64 (trexio_t* const file, const int64_t* jastrow_een_nucleus)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (jastrow_een_nucleus == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_nucleus(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t jastrow_een_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {jastrow_een_num};

  if (file->one_based) {
    /* Handle index type : is_index = file->one_based */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    int64_t* jastrow_een_nucleus_p =
       CALLOC(dim_size, int64_t);

    if (jastrow_een_nucleus_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_een_nucleus_p[i] = jastrow_een_nucleus[i] - (int64_t) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_een_nucleus(file,
                                          (const int64_t*) jastrow_een_nucleus_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_een_nucleus(file,
                                          (const int64_t*) jastrow_een_nucleus_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_een_nucleus(file, jastrow_een_nucleus_p, rank, dims);
        break;
      */
      FREE(jastrow_een_nucleus_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_een_nucleus(file, jastrow_een_nucleus, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_een_nucleus(file, jastrow_een_nucleus, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_een_nucleus(file, jastrow_een_nucleus, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_jastrow_en_scaling_64 (trexio_t* const file, const double* jastrow_en_scaling)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (jastrow_en_scaling == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_scaling(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* jastrow_en_scaling_p =
       CALLOC(dim_size, double);

    if (jastrow_en_scaling_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       jastrow_en_scaling_p[i] = jastrow_en_scaling[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_en_scaling(file,
                                          (const double*) jastrow_en_scaling_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_en_scaling(file,
                                          (const double*) jastrow_en_scaling_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_en_scaling(file, jastrow_en_scaling_p, rank, dims);
        break;
      */
      FREE(jastrow_en_scaling_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_jastrow_en_scaling(file, jastrow_en_scaling, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_jastrow_en_scaling(file, jastrow_en_scaling, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_jastrow_en_scaling(file, jastrow_en_scaling, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_qmc_point_64 (trexio_t* const file, const double* qmc_point)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (qmc_point == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t qmc_num = 0;
  int64_t electron_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_electron_num_64(file, &(electron_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;
  if (electron_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 3;
  uint64_t dims[3] = {qmc_num, electron_num, 3};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* qmc_point_p =
       CALLOC(dim_size, double);

    if (qmc_point_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       qmc_point_p[i] = qmc_point[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_qmc_point(file,
                                          (const double*) qmc_point_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_qmc_point(file,
                                          (const double*) qmc_point_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_qmc_point(file, qmc_point_p, rank, dims);
        break;
      */
      FREE(qmc_point_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_qmc_point(file, qmc_point, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_qmc_point(file, qmc_point, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_qmc_point(file, qmc_point, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_qmc_psi_64 (trexio_t* const file, const double* qmc_psi)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (qmc_psi == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_psi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t qmc_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {qmc_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* qmc_psi_p =
       CALLOC(dim_size, double);

    if (qmc_psi_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       qmc_psi_p[i] = qmc_psi[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_qmc_psi(file,
                                          (const double*) qmc_psi_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_qmc_psi(file,
                                          (const double*) qmc_psi_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_qmc_psi(file, qmc_psi_p, rank, dims);
        break;
      */
      FREE(qmc_psi_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_qmc_psi(file, qmc_psi, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_qmc_psi(file, qmc_psi, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_qmc_psi(file, qmc_psi, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_qmc_e_loc_64 (trexio_t* const file, const double* qmc_e_loc)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  assert(file->back_end < TREXIO_INVALID_BACK_END);

  if (qmc_e_loc == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_e_loc(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t qmc_num = 0;

  trexio_exit_code rc = TREXIO_FAILURE;
  /* Error handling for this call is added by the generator */
  rc = trexio_read_qmc_num_64(file, &(qmc_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (qmc_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {qmc_num};

  if ((false)) {
    /* Handle index type : is_index = (false) */
    uint64_t dim_size = 1;
    for (uint32_t i=0; i<rank; ++i){
      dim_size *= dims[i];
    }

    double* qmc_e_loc_p =
       CALLOC(dim_size, double);

    if (qmc_e_loc_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<dim_size; ++i){
       qmc_e_loc_p[i] = qmc_e_loc[i] - (double) 1;
    }

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_qmc_e_loc(file,
                                          (const double*) qmc_e_loc_p,
                                          rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_qmc_e_loc(file,
                                          (const double*) qmc_e_loc_p,
                                          rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_qmc_e_loc(file, qmc_e_loc_p, rank, dims);
        break;
      */
      FREE(qmc_e_loc_p);

    }

  } else {

    rc = TREXIO_FAILURE;
    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_qmc_e_loc(file, qmc_e_loc, rank, dims);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_qmc_e_loc(file, qmc_e_loc, rank, dims);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_qmc_e_loc(file, qmc_e_loc, rank, dims);
        break;
      */
    }
  }

  return rc;
}

trexio_exit_code
trexio_write_safe_nucleus_charge_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_charge(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_nucleus_charge_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_nucleus_coord_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_nucleus_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {nucleus_num, 3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_nucleus_coord_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_a_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_a(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_a_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_b_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_b(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_b_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_c_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_c(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_c_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_g_a_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_a(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_g_a_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_g_b_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_b(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_g_b_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_cell_g_c_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_cell_g_c(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_cell_g_c_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_pbc_k_point_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;


trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */


uint32_t rank = 1;
uint64_t dims[1] = {3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_pbc_k_point_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_pbc_k_point_weight_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_pbc_k_point_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t pbc_k_point_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_pbc_k_point_num_64(file, &(pbc_k_point_num));
if (rc != TREXIO_SUCCESS) return rc;

if (pbc_k_point_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {pbc_k_point_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_pbc_k_point_weight_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nucleus_index_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nucleus_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nucleus_index_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_shell_ang_mom_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_ang_mom(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_shell_ang_mom_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_shell_factor_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_factor(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_shell_factor_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_r_power_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_r_power(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_r_power_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_start_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_start(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_start_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_size_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_size(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_shell_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_shell_num_64(file, &(basis_shell_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_shell_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_shell_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_size_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_shell_index_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_shell_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_shell_index_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_exponent_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_exponent_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_exponent_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_exponent_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_exponent_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_coefficient_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_coefficient_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_coefficient_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_coefficient_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_coefficient_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_oscillation_arg_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_oscillation_arg(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_oscillation_arg_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_prim_factor_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_prim_factor(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_prim_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_prim_num_64(file, &(basis_prim_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_prim_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_prim_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_prim_factor_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_radius_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_radius(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_radius_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_phi_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_phi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_phi_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_grad_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_grad(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_grad_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_lap_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_nao_grid_lap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {basis_nao_grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_nao_grid_lap_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_interpolator_phi_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_phi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_interpolator_phi_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_interpolator_grad_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_grad(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_interpolator_grad_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_basis_interpolator_lap_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_basis_interpolator_lap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t basis_nao_grid_num = 0;
int64_t basis_interp_coeff_cnt = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_basis_nao_grid_num_64(file, &(basis_nao_grid_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_basis_interp_coeff_cnt_64(file, &(basis_interp_coeff_cnt));
if (rc != TREXIO_SUCCESS) return rc;

if (basis_nao_grid_num == 0L) return TREXIO_INVALID_NUM;
if (basis_interp_coeff_cnt == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {basis_nao_grid_num, basis_interp_coeff_cnt};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_basis_interpolator_lap_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_max_ang_mom_plus_1_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_max_ang_mom_plus_1(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_max_ang_mom_plus_1_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_z_core_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_z_core(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_z_core_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_ang_mom_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_ang_mom(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_ang_mom_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_nucleus_index_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_nucleus_index(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_nucleus_index_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_exponent_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_exponent(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_exponent_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_coefficient_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_coefficient_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ecp_power_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ecp_power(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ecp_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ecp_num_64(file, &(ecp_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ecp_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ecp_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ecp_power_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_coord_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_num_64(file, &(grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_coord_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_weight_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_num_64(file, &(grid_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_weight_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_ang_coord_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_ang_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_ang_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_ang_coord_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_ang_weight_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_ang_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_ang_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_ang_num_64(file, &(grid_ang_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_ang_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_ang_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_ang_weight_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_rad_coord_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_coord(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_rad_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_rad_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_rad_coord_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_grid_rad_weight_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_grid_rad_weight(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t grid_rad_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_grid_rad_num_64(file, &(grid_rad_num));
if (rc != TREXIO_SUCCESS) return rc;

if (grid_rad_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {grid_rad_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_grid_rad_weight_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_shell_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_shell(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_shell_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_normalization_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_normalization(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_normalization_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_overlap_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_overlap_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_kinetic_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_kinetic_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_potential_n_e_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_potential_n_e_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_ecp_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_ecp_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_core_hamiltonian_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_core_hamiltonian_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_overlap_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_overlap_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_overlap_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_kinetic_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_kinetic_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_kinetic_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_potential_n_e_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_potential_n_e_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_potential_n_e_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_ecp_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_ecp_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_ecp_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_core_hamiltonian_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_ao_1e_int_core_hamiltonian_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {ao_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_ao_1e_int_core_hamiltonian_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_coefficient_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;
int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;
if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_coefficient_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_coefficient_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_coefficient_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;
int64_t ao_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_ao_num_64(file, &(ao_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;
if (ao_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, ao_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_coefficient_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_occupation_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_occupation(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_occupation_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_energy_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_energy(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_energy_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_spin_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_spin(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_spin_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_k_point_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_k_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_k_point_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_overlap_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_overlap_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_kinetic_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_kinetic_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_potential_n_e_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_potential_n_e_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_ecp_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_ecp_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_core_hamiltonian_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_core_hamiltonian_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_overlap_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_overlap_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_overlap_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_kinetic_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_kinetic_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_kinetic_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_potential_n_e_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_potential_n_e_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_potential_n_e_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_ecp_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_ecp_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_ecp_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_core_hamiltonian_im_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_mo_1e_int_core_hamiltonian_im(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_mo_1e_int_core_hamiltonian_im_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_rdm_1e_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_up_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_up(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_rdm_1e_up_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_dn_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_dn(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 2;
uint64_t dims[2] = {mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_rdm_1e_dn_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_transition_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_rdm_1e_transition(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t state_num = 0;
int64_t mo_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_state_num_64(file, &(state_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_mo_num_64(file, &(mo_num));
if (rc != TREXIO_SUCCESS) return rc;

if (state_num == 0L) return TREXIO_INVALID_NUM;
if (mo_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 4;
uint64_t dims[4] = {state_num, state_num, mo_num, mo_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_rdm_1e_transition_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_en_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_en_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_en_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_en_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_ee_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_ee(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_ee_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_ee_num_64(file, &(jastrow_ee_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_ee_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_ee_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_ee_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_een_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_een_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_een_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_een_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_en_nucleus_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_nucleus(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_en_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_en_num_64(file, &(jastrow_en_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_en_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_en_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_en_nucleus_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_een_nucleus_64 (trexio_t* const file, const int64_t* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_een_nucleus(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t jastrow_een_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_jastrow_een_num_64(file, &(jastrow_een_num));
if (rc != TREXIO_SUCCESS) return rc;

if (jastrow_een_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {jastrow_een_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_een_nucleus_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_jastrow_en_scaling_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_jastrow_en_scaling(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t nucleus_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
if (rc != TREXIO_SUCCESS) return rc;

if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {nucleus_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_jastrow_en_scaling_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_qmc_point_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_point(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t qmc_num = 0;
int64_t electron_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;
rc = trexio_read_electron_num_64(file, &(electron_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;
if (electron_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 3;
uint64_t dims[3] = {qmc_num, electron_num, 3};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_qmc_point_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_qmc_psi_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_psi(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t qmc_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {qmc_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_qmc_psi_64(file, dset_in);
}

trexio_exit_code
trexio_write_safe_qmc_e_loc_64 (trexio_t* const file, const double* dset_in, const int64_t dim_in)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (trexio_has_qmc_e_loc(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

int64_t qmc_num = 0;

trexio_exit_code rc = TREXIO_FAILURE;
(void) rc; // Avoids unused parameter error for scalar variables

/* Error handling for this call is added by the generator */
rc = trexio_read_qmc_num_64(file, &(qmc_num));
if (rc != TREXIO_SUCCESS) return rc;

if (qmc_num == 0L) return TREXIO_INVALID_NUM;

uint32_t rank = 1;
uint64_t dims[1] = {qmc_num};

/* The block below is specific to safe API as it checks the boundaries */
uint64_t dim_size = 1;
for (uint32_t i=0; i<rank; ++i){
    dim_size *= dims[i];
}

  if (dim_in > (int64_t) dim_size) return TREXIO_UNSAFE_ARRAY_DIM;

  return trexio_write_qmc_e_loc_64(file, dset_in);
}

trexio_exit_code
trexio_write_nucleus_charge (trexio_t* const file, const double* nucleus_charge)
{
  return trexio_write_nucleus_charge_64(file, nucleus_charge);
}

trexio_exit_code
trexio_write_nucleus_coord (trexio_t* const file, const double* nucleus_coord)
{
  return trexio_write_nucleus_coord_64(file, nucleus_coord);
}

trexio_exit_code
trexio_write_cell_a (trexio_t* const file, const double* cell_a)
{
  return trexio_write_cell_a_64(file, cell_a);
}

trexio_exit_code
trexio_write_cell_b (trexio_t* const file, const double* cell_b)
{
  return trexio_write_cell_b_64(file, cell_b);
}

trexio_exit_code
trexio_write_cell_c (trexio_t* const file, const double* cell_c)
{
  return trexio_write_cell_c_64(file, cell_c);
}

trexio_exit_code
trexio_write_cell_g_a (trexio_t* const file, const double* cell_g_a)
{
  return trexio_write_cell_g_a_64(file, cell_g_a);
}

trexio_exit_code
trexio_write_cell_g_b (trexio_t* const file, const double* cell_g_b)
{
  return trexio_write_cell_g_b_64(file, cell_g_b);
}

trexio_exit_code
trexio_write_cell_g_c (trexio_t* const file, const double* cell_g_c)
{
  return trexio_write_cell_g_c_64(file, cell_g_c);
}

trexio_exit_code
trexio_write_pbc_k_point (trexio_t* const file, const double* pbc_k_point)
{
  return trexio_write_pbc_k_point_64(file, pbc_k_point);
}

trexio_exit_code
trexio_write_pbc_k_point_weight (trexio_t* const file, const double* pbc_k_point_weight)
{
  return trexio_write_pbc_k_point_weight_64(file, pbc_k_point_weight);
}

trexio_exit_code
trexio_write_basis_nucleus_index (trexio_t* const file, const int32_t* basis_nucleus_index)
{
  return trexio_write_basis_nucleus_index_32(file, basis_nucleus_index);
}

trexio_exit_code
trexio_write_basis_shell_ang_mom (trexio_t* const file, const int32_t* basis_shell_ang_mom)
{
  return trexio_write_basis_shell_ang_mom_32(file, basis_shell_ang_mom);
}

trexio_exit_code
trexio_write_basis_shell_factor (trexio_t* const file, const double* basis_shell_factor)
{
  return trexio_write_basis_shell_factor_64(file, basis_shell_factor);
}

trexio_exit_code
trexio_write_basis_r_power (trexio_t* const file, const int32_t* basis_r_power)
{
  return trexio_write_basis_r_power_32(file, basis_r_power);
}

trexio_exit_code
trexio_write_basis_nao_grid_start (trexio_t* const file, const int32_t* basis_nao_grid_start)
{
  return trexio_write_basis_nao_grid_start_32(file, basis_nao_grid_start);
}

trexio_exit_code
trexio_write_basis_nao_grid_size (trexio_t* const file, const int32_t* basis_nao_grid_size)
{
  return trexio_write_basis_nao_grid_size_32(file, basis_nao_grid_size);
}

trexio_exit_code
trexio_write_basis_shell_index (trexio_t* const file, const int32_t* basis_shell_index)
{
  return trexio_write_basis_shell_index_32(file, basis_shell_index);
}

trexio_exit_code
trexio_write_basis_exponent (trexio_t* const file, const double* basis_exponent)
{
  return trexio_write_basis_exponent_64(file, basis_exponent);
}

trexio_exit_code
trexio_write_basis_exponent_im (trexio_t* const file, const double* basis_exponent_im)
{
  return trexio_write_basis_exponent_im_64(file, basis_exponent_im);
}

trexio_exit_code
trexio_write_basis_coefficient (trexio_t* const file, const double* basis_coefficient)
{
  return trexio_write_basis_coefficient_64(file, basis_coefficient);
}

trexio_exit_code
trexio_write_basis_coefficient_im (trexio_t* const file, const double* basis_coefficient_im)
{
  return trexio_write_basis_coefficient_im_64(file, basis_coefficient_im);
}

trexio_exit_code
trexio_write_basis_oscillation_arg (trexio_t* const file, const double* basis_oscillation_arg)
{
  return trexio_write_basis_oscillation_arg_64(file, basis_oscillation_arg);
}

trexio_exit_code
trexio_write_basis_prim_factor (trexio_t* const file, const double* basis_prim_factor)
{
  return trexio_write_basis_prim_factor_64(file, basis_prim_factor);
}

trexio_exit_code
trexio_write_basis_nao_grid_radius (trexio_t* const file, const double* basis_nao_grid_radius)
{
  return trexio_write_basis_nao_grid_radius_64(file, basis_nao_grid_radius);
}

trexio_exit_code
trexio_write_basis_nao_grid_phi (trexio_t* const file, const double* basis_nao_grid_phi)
{
  return trexio_write_basis_nao_grid_phi_64(file, basis_nao_grid_phi);
}

trexio_exit_code
trexio_write_basis_nao_grid_grad (trexio_t* const file, const double* basis_nao_grid_grad)
{
  return trexio_write_basis_nao_grid_grad_64(file, basis_nao_grid_grad);
}

trexio_exit_code
trexio_write_basis_nao_grid_lap (trexio_t* const file, const double* basis_nao_grid_lap)
{
  return trexio_write_basis_nao_grid_lap_64(file, basis_nao_grid_lap);
}

trexio_exit_code
trexio_write_basis_interpolator_phi (trexio_t* const file, const double* basis_interpolator_phi)
{
  return trexio_write_basis_interpolator_phi_64(file, basis_interpolator_phi);
}

trexio_exit_code
trexio_write_basis_interpolator_grad (trexio_t* const file, const double* basis_interpolator_grad)
{
  return trexio_write_basis_interpolator_grad_64(file, basis_interpolator_grad);
}

trexio_exit_code
trexio_write_basis_interpolator_lap (trexio_t* const file, const double* basis_interpolator_lap)
{
  return trexio_write_basis_interpolator_lap_64(file, basis_interpolator_lap);
}

trexio_exit_code
trexio_write_ecp_max_ang_mom_plus_1 (trexio_t* const file, const int32_t* ecp_max_ang_mom_plus_1)
{
  return trexio_write_ecp_max_ang_mom_plus_1_32(file, ecp_max_ang_mom_plus_1);
}

trexio_exit_code
trexio_write_ecp_z_core (trexio_t* const file, const int32_t* ecp_z_core)
{
  return trexio_write_ecp_z_core_32(file, ecp_z_core);
}

trexio_exit_code
trexio_write_ecp_ang_mom (trexio_t* const file, const int32_t* ecp_ang_mom)
{
  return trexio_write_ecp_ang_mom_32(file, ecp_ang_mom);
}

trexio_exit_code
trexio_write_ecp_nucleus_index (trexio_t* const file, const int32_t* ecp_nucleus_index)
{
  return trexio_write_ecp_nucleus_index_32(file, ecp_nucleus_index);
}

trexio_exit_code
trexio_write_ecp_exponent (trexio_t* const file, const double* ecp_exponent)
{
  return trexio_write_ecp_exponent_64(file, ecp_exponent);
}

trexio_exit_code
trexio_write_ecp_coefficient (trexio_t* const file, const double* ecp_coefficient)
{
  return trexio_write_ecp_coefficient_64(file, ecp_coefficient);
}

trexio_exit_code
trexio_write_ecp_power (trexio_t* const file, const int32_t* ecp_power)
{
  return trexio_write_ecp_power_32(file, ecp_power);
}

trexio_exit_code
trexio_write_grid_coord (trexio_t* const file, const double* grid_coord)
{
  return trexio_write_grid_coord_64(file, grid_coord);
}

trexio_exit_code
trexio_write_grid_weight (trexio_t* const file, const double* grid_weight)
{
  return trexio_write_grid_weight_64(file, grid_weight);
}

trexio_exit_code
trexio_write_grid_ang_coord (trexio_t* const file, const double* grid_ang_coord)
{
  return trexio_write_grid_ang_coord_64(file, grid_ang_coord);
}

trexio_exit_code
trexio_write_grid_ang_weight (trexio_t* const file, const double* grid_ang_weight)
{
  return trexio_write_grid_ang_weight_64(file, grid_ang_weight);
}

trexio_exit_code
trexio_write_grid_rad_coord (trexio_t* const file, const double* grid_rad_coord)
{
  return trexio_write_grid_rad_coord_64(file, grid_rad_coord);
}

trexio_exit_code
trexio_write_grid_rad_weight (trexio_t* const file, const double* grid_rad_weight)
{
  return trexio_write_grid_rad_weight_64(file, grid_rad_weight);
}

trexio_exit_code
trexio_write_ao_shell (trexio_t* const file, const int32_t* ao_shell)
{
  return trexio_write_ao_shell_32(file, ao_shell);
}

trexio_exit_code
trexio_write_ao_normalization (trexio_t* const file, const double* ao_normalization)
{
  return trexio_write_ao_normalization_64(file, ao_normalization);
}

trexio_exit_code
trexio_write_ao_1e_int_overlap (trexio_t* const file, const double* ao_1e_int_overlap)
{
  return trexio_write_ao_1e_int_overlap_64(file, ao_1e_int_overlap);
}

trexio_exit_code
trexio_write_ao_1e_int_kinetic (trexio_t* const file, const double* ao_1e_int_kinetic)
{
  return trexio_write_ao_1e_int_kinetic_64(file, ao_1e_int_kinetic);
}

trexio_exit_code
trexio_write_ao_1e_int_potential_n_e (trexio_t* const file, const double* ao_1e_int_potential_n_e)
{
  return trexio_write_ao_1e_int_potential_n_e_64(file, ao_1e_int_potential_n_e);
}

trexio_exit_code
trexio_write_ao_1e_int_ecp (trexio_t* const file, const double* ao_1e_int_ecp)
{
  return trexio_write_ao_1e_int_ecp_64(file, ao_1e_int_ecp);
}

trexio_exit_code
trexio_write_ao_1e_int_core_hamiltonian (trexio_t* const file, const double* ao_1e_int_core_hamiltonian)
{
  return trexio_write_ao_1e_int_core_hamiltonian_64(file, ao_1e_int_core_hamiltonian);
}

trexio_exit_code
trexio_write_ao_1e_int_overlap_im (trexio_t* const file, const double* ao_1e_int_overlap_im)
{
  return trexio_write_ao_1e_int_overlap_im_64(file, ao_1e_int_overlap_im);
}

trexio_exit_code
trexio_write_ao_1e_int_kinetic_im (trexio_t* const file, const double* ao_1e_int_kinetic_im)
{
  return trexio_write_ao_1e_int_kinetic_im_64(file, ao_1e_int_kinetic_im);
}

trexio_exit_code
trexio_write_ao_1e_int_potential_n_e_im (trexio_t* const file, const double* ao_1e_int_potential_n_e_im)
{
  return trexio_write_ao_1e_int_potential_n_e_im_64(file, ao_1e_int_potential_n_e_im);
}

trexio_exit_code
trexio_write_ao_1e_int_ecp_im (trexio_t* const file, const double* ao_1e_int_ecp_im)
{
  return trexio_write_ao_1e_int_ecp_im_64(file, ao_1e_int_ecp_im);
}

trexio_exit_code
trexio_write_ao_1e_int_core_hamiltonian_im (trexio_t* const file, const double* ao_1e_int_core_hamiltonian_im)
{
  return trexio_write_ao_1e_int_core_hamiltonian_im_64(file, ao_1e_int_core_hamiltonian_im);
}

trexio_exit_code
trexio_write_mo_coefficient (trexio_t* const file, const double* mo_coefficient)
{
  return trexio_write_mo_coefficient_64(file, mo_coefficient);
}

trexio_exit_code
trexio_write_mo_coefficient_im (trexio_t* const file, const double* mo_coefficient_im)
{
  return trexio_write_mo_coefficient_im_64(file, mo_coefficient_im);
}

trexio_exit_code
trexio_write_mo_occupation (trexio_t* const file, const double* mo_occupation)
{
  return trexio_write_mo_occupation_64(file, mo_occupation);
}

trexio_exit_code
trexio_write_mo_energy (trexio_t* const file, const double* mo_energy)
{
  return trexio_write_mo_energy_64(file, mo_energy);
}

trexio_exit_code
trexio_write_mo_spin (trexio_t* const file, const int32_t* mo_spin)
{
  return trexio_write_mo_spin_32(file, mo_spin);
}

trexio_exit_code
trexio_write_mo_k_point (trexio_t* const file, const int32_t* mo_k_point)
{
  return trexio_write_mo_k_point_32(file, mo_k_point);
}

trexio_exit_code
trexio_write_mo_1e_int_overlap (trexio_t* const file, const double* mo_1e_int_overlap)
{
  return trexio_write_mo_1e_int_overlap_64(file, mo_1e_int_overlap);
}

trexio_exit_code
trexio_write_mo_1e_int_kinetic (trexio_t* const file, const double* mo_1e_int_kinetic)
{
  return trexio_write_mo_1e_int_kinetic_64(file, mo_1e_int_kinetic);
}

trexio_exit_code
trexio_write_mo_1e_int_potential_n_e (trexio_t* const file, const double* mo_1e_int_potential_n_e)
{
  return trexio_write_mo_1e_int_potential_n_e_64(file, mo_1e_int_potential_n_e);
}

trexio_exit_code
trexio_write_mo_1e_int_ecp (trexio_t* const file, const double* mo_1e_int_ecp)
{
  return trexio_write_mo_1e_int_ecp_64(file, mo_1e_int_ecp);
}

trexio_exit_code
trexio_write_mo_1e_int_core_hamiltonian (trexio_t* const file, const double* mo_1e_int_core_hamiltonian)
{
  return trexio_write_mo_1e_int_core_hamiltonian_64(file, mo_1e_int_core_hamiltonian);
}

trexio_exit_code
trexio_write_mo_1e_int_overlap_im (trexio_t* const file, const double* mo_1e_int_overlap_im)
{
  return trexio_write_mo_1e_int_overlap_im_64(file, mo_1e_int_overlap_im);
}

trexio_exit_code
trexio_write_mo_1e_int_kinetic_im (trexio_t* const file, const double* mo_1e_int_kinetic_im)
{
  return trexio_write_mo_1e_int_kinetic_im_64(file, mo_1e_int_kinetic_im);
}

trexio_exit_code
trexio_write_mo_1e_int_potential_n_e_im (trexio_t* const file, const double* mo_1e_int_potential_n_e_im)
{
  return trexio_write_mo_1e_int_potential_n_e_im_64(file, mo_1e_int_potential_n_e_im);
}

trexio_exit_code
trexio_write_mo_1e_int_ecp_im (trexio_t* const file, const double* mo_1e_int_ecp_im)
{
  return trexio_write_mo_1e_int_ecp_im_64(file, mo_1e_int_ecp_im);
}

trexio_exit_code
trexio_write_mo_1e_int_core_hamiltonian_im (trexio_t* const file, const double* mo_1e_int_core_hamiltonian_im)
{
  return trexio_write_mo_1e_int_core_hamiltonian_im_64(file, mo_1e_int_core_hamiltonian_im);
}

trexio_exit_code
trexio_write_rdm_1e (trexio_t* const file, const double* rdm_1e)
{
  return trexio_write_rdm_1e_64(file, rdm_1e);
}

trexio_exit_code
trexio_write_rdm_1e_up (trexio_t* const file, const double* rdm_1e_up)
{
  return trexio_write_rdm_1e_up_64(file, rdm_1e_up);
}

trexio_exit_code
trexio_write_rdm_1e_dn (trexio_t* const file, const double* rdm_1e_dn)
{
  return trexio_write_rdm_1e_dn_64(file, rdm_1e_dn);
}

trexio_exit_code
trexio_write_rdm_1e_transition (trexio_t* const file, const double* rdm_1e_transition)
{
  return trexio_write_rdm_1e_transition_64(file, rdm_1e_transition);
}

trexio_exit_code
trexio_write_jastrow_en (trexio_t* const file, const double* jastrow_en)
{
  return trexio_write_jastrow_en_64(file, jastrow_en);
}

trexio_exit_code
trexio_write_jastrow_ee (trexio_t* const file, const double* jastrow_ee)
{
  return trexio_write_jastrow_ee_64(file, jastrow_ee);
}

trexio_exit_code
trexio_write_jastrow_een (trexio_t* const file, const double* jastrow_een)
{
  return trexio_write_jastrow_een_64(file, jastrow_een);
}

trexio_exit_code
trexio_write_jastrow_en_nucleus (trexio_t* const file, const int32_t* jastrow_en_nucleus)
{
  return trexio_write_jastrow_en_nucleus_32(file, jastrow_en_nucleus);
}

trexio_exit_code
trexio_write_jastrow_een_nucleus (trexio_t* const file, const int32_t* jastrow_een_nucleus)
{
  return trexio_write_jastrow_een_nucleus_32(file, jastrow_een_nucleus);
}

trexio_exit_code
trexio_write_jastrow_en_scaling (trexio_t* const file, const double* jastrow_en_scaling)
{
  return trexio_write_jastrow_en_scaling_64(file, jastrow_en_scaling);
}

trexio_exit_code
trexio_write_qmc_point (trexio_t* const file, const double* qmc_point)
{
  return trexio_write_qmc_point_64(file, qmc_point);
}

trexio_exit_code
trexio_write_qmc_psi (trexio_t* const file, const double* qmc_psi)
{
  return trexio_write_qmc_psi_64(file, qmc_psi);
}

trexio_exit_code
trexio_write_qmc_e_loc (trexio_t* const file, const double* qmc_e_loc)
{
  return trexio_write_qmc_e_loc_64(file, qmc_e_loc);
}

trexio_exit_code
trexio_write_safe_nucleus_charge (trexio_t* const file, const double* nucleus_charge, const int64_t dim_in)
{
  return trexio_write_safe_nucleus_charge_64(file, nucleus_charge, dim_in);
}

trexio_exit_code
trexio_write_safe_nucleus_coord (trexio_t* const file, const double* nucleus_coord, const int64_t dim_in)
{
  return trexio_write_safe_nucleus_coord_64(file, nucleus_coord, dim_in);
}

trexio_exit_code
trexio_write_safe_cell_a (trexio_t* const file, const double* cell_a, const int64_t dim_in)
{
  return trexio_write_safe_cell_a_64(file, cell_a, dim_in);
}

trexio_exit_code
trexio_write_safe_cell_b (trexio_t* const file, const double* cell_b, const int64_t dim_in)
{
  return trexio_write_safe_cell_b_64(file, cell_b, dim_in);
}

trexio_exit_code
trexio_write_safe_cell_c (trexio_t* const file, const double* cell_c, const int64_t dim_in)
{
  return trexio_write_safe_cell_c_64(file, cell_c, dim_in);
}

trexio_exit_code
trexio_write_safe_cell_g_a (trexio_t* const file, const double* cell_g_a, const int64_t dim_in)
{
  return trexio_write_safe_cell_g_a_64(file, cell_g_a, dim_in);
}

trexio_exit_code
trexio_write_safe_cell_g_b (trexio_t* const file, const double* cell_g_b, const int64_t dim_in)
{
  return trexio_write_safe_cell_g_b_64(file, cell_g_b, dim_in);
}

trexio_exit_code
trexio_write_safe_cell_g_c (trexio_t* const file, const double* cell_g_c, const int64_t dim_in)
{
  return trexio_write_safe_cell_g_c_64(file, cell_g_c, dim_in);
}

trexio_exit_code
trexio_write_safe_pbc_k_point (trexio_t* const file, const double* pbc_k_point, const int64_t dim_in)
{
  return trexio_write_safe_pbc_k_point_64(file, pbc_k_point, dim_in);
}

trexio_exit_code
trexio_write_safe_pbc_k_point_weight (trexio_t* const file, const double* pbc_k_point_weight, const int64_t dim_in)
{
  return trexio_write_safe_pbc_k_point_weight_64(file, pbc_k_point_weight, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_nucleus_index (trexio_t* const file, const int32_t* basis_nucleus_index, const int64_t dim_in)
{
  return trexio_write_safe_basis_nucleus_index_32(file, basis_nucleus_index, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_shell_ang_mom (trexio_t* const file, const int32_t* basis_shell_ang_mom, const int64_t dim_in)
{
  return trexio_write_safe_basis_shell_ang_mom_32(file, basis_shell_ang_mom, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_shell_factor (trexio_t* const file, const double* basis_shell_factor, const int64_t dim_in)
{
  return trexio_write_safe_basis_shell_factor_64(file, basis_shell_factor, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_r_power (trexio_t* const file, const int32_t* basis_r_power, const int64_t dim_in)
{
  return trexio_write_safe_basis_r_power_32(file, basis_r_power, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_start (trexio_t* const file, const int32_t* basis_nao_grid_start, const int64_t dim_in)
{
  return trexio_write_safe_basis_nao_grid_start_32(file, basis_nao_grid_start, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_size (trexio_t* const file, const int32_t* basis_nao_grid_size, const int64_t dim_in)
{
  return trexio_write_safe_basis_nao_grid_size_32(file, basis_nao_grid_size, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_shell_index (trexio_t* const file, const int32_t* basis_shell_index, const int64_t dim_in)
{
  return trexio_write_safe_basis_shell_index_32(file, basis_shell_index, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_exponent (trexio_t* const file, const double* basis_exponent, const int64_t dim_in)
{
  return trexio_write_safe_basis_exponent_64(file, basis_exponent, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_exponent_im (trexio_t* const file, const double* basis_exponent_im, const int64_t dim_in)
{
  return trexio_write_safe_basis_exponent_im_64(file, basis_exponent_im, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_coefficient (trexio_t* const file, const double* basis_coefficient, const int64_t dim_in)
{
  return trexio_write_safe_basis_coefficient_64(file, basis_coefficient, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_coefficient_im (trexio_t* const file, const double* basis_coefficient_im, const int64_t dim_in)
{
  return trexio_write_safe_basis_coefficient_im_64(file, basis_coefficient_im, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_oscillation_arg (trexio_t* const file, const double* basis_oscillation_arg, const int64_t dim_in)
{
  return trexio_write_safe_basis_oscillation_arg_64(file, basis_oscillation_arg, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_prim_factor (trexio_t* const file, const double* basis_prim_factor, const int64_t dim_in)
{
  return trexio_write_safe_basis_prim_factor_64(file, basis_prim_factor, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_radius (trexio_t* const file, const double* basis_nao_grid_radius, const int64_t dim_in)
{
  return trexio_write_safe_basis_nao_grid_radius_64(file, basis_nao_grid_radius, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_phi (trexio_t* const file, const double* basis_nao_grid_phi, const int64_t dim_in)
{
  return trexio_write_safe_basis_nao_grid_phi_64(file, basis_nao_grid_phi, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_grad (trexio_t* const file, const double* basis_nao_grid_grad, const int64_t dim_in)
{
  return trexio_write_safe_basis_nao_grid_grad_64(file, basis_nao_grid_grad, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_nao_grid_lap (trexio_t* const file, const double* basis_nao_grid_lap, const int64_t dim_in)
{
  return trexio_write_safe_basis_nao_grid_lap_64(file, basis_nao_grid_lap, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_interpolator_phi (trexio_t* const file, const double* basis_interpolator_phi, const int64_t dim_in)
{
  return trexio_write_safe_basis_interpolator_phi_64(file, basis_interpolator_phi, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_interpolator_grad (trexio_t* const file, const double* basis_interpolator_grad, const int64_t dim_in)
{
  return trexio_write_safe_basis_interpolator_grad_64(file, basis_interpolator_grad, dim_in);
}

trexio_exit_code
trexio_write_safe_basis_interpolator_lap (trexio_t* const file, const double* basis_interpolator_lap, const int64_t dim_in)
{
  return trexio_write_safe_basis_interpolator_lap_64(file, basis_interpolator_lap, dim_in);
}

trexio_exit_code
trexio_write_safe_ecp_max_ang_mom_plus_1 (trexio_t* const file, const int32_t* ecp_max_ang_mom_plus_1, const int64_t dim_in)
{
  return trexio_write_safe_ecp_max_ang_mom_plus_1_32(file, ecp_max_ang_mom_plus_1, dim_in);
}

trexio_exit_code
trexio_write_safe_ecp_z_core (trexio_t* const file, const int32_t* ecp_z_core, const int64_t dim_in)
{
  return trexio_write_safe_ecp_z_core_32(file, ecp_z_core, dim_in);
}

trexio_exit_code
trexio_write_safe_ecp_ang_mom (trexio_t* const file, const int32_t* ecp_ang_mom, const int64_t dim_in)
{
  return trexio_write_safe_ecp_ang_mom_32(file, ecp_ang_mom, dim_in);
}

trexio_exit_code
trexio_write_safe_ecp_nucleus_index (trexio_t* const file, const int32_t* ecp_nucleus_index, const int64_t dim_in)
{
  return trexio_write_safe_ecp_nucleus_index_32(file, ecp_nucleus_index, dim_in);
}

trexio_exit_code
trexio_write_safe_ecp_exponent (trexio_t* const file, const double* ecp_exponent, const int64_t dim_in)
{
  return trexio_write_safe_ecp_exponent_64(file, ecp_exponent, dim_in);
}

trexio_exit_code
trexio_write_safe_ecp_coefficient (trexio_t* const file, const double* ecp_coefficient, const int64_t dim_in)
{
  return trexio_write_safe_ecp_coefficient_64(file, ecp_coefficient, dim_in);
}

trexio_exit_code
trexio_write_safe_ecp_power (trexio_t* const file, const int32_t* ecp_power, const int64_t dim_in)
{
  return trexio_write_safe_ecp_power_32(file, ecp_power, dim_in);
}

trexio_exit_code
trexio_write_safe_grid_coord (trexio_t* const file, const double* grid_coord, const int64_t dim_in)
{
  return trexio_write_safe_grid_coord_64(file, grid_coord, dim_in);
}

trexio_exit_code
trexio_write_safe_grid_weight (trexio_t* const file, const double* grid_weight, const int64_t dim_in)
{
  return trexio_write_safe_grid_weight_64(file, grid_weight, dim_in);
}

trexio_exit_code
trexio_write_safe_grid_ang_coord (trexio_t* const file, const double* grid_ang_coord, const int64_t dim_in)
{
  return trexio_write_safe_grid_ang_coord_64(file, grid_ang_coord, dim_in);
}

trexio_exit_code
trexio_write_safe_grid_ang_weight (trexio_t* const file, const double* grid_ang_weight, const int64_t dim_in)
{
  return trexio_write_safe_grid_ang_weight_64(file, grid_ang_weight, dim_in);
}

trexio_exit_code
trexio_write_safe_grid_rad_coord (trexio_t* const file, const double* grid_rad_coord, const int64_t dim_in)
{
  return trexio_write_safe_grid_rad_coord_64(file, grid_rad_coord, dim_in);
}

trexio_exit_code
trexio_write_safe_grid_rad_weight (trexio_t* const file, const double* grid_rad_weight, const int64_t dim_in)
{
  return trexio_write_safe_grid_rad_weight_64(file, grid_rad_weight, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_shell (trexio_t* const file, const int32_t* ao_shell, const int64_t dim_in)
{
  return trexio_write_safe_ao_shell_32(file, ao_shell, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_normalization (trexio_t* const file, const double* ao_normalization, const int64_t dim_in)
{
  return trexio_write_safe_ao_normalization_64(file, ao_normalization, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_overlap (trexio_t* const file, const double* ao_1e_int_overlap, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_overlap_64(file, ao_1e_int_overlap, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_kinetic (trexio_t* const file, const double* ao_1e_int_kinetic, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_kinetic_64(file, ao_1e_int_kinetic, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_potential_n_e (trexio_t* const file, const double* ao_1e_int_potential_n_e, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_potential_n_e_64(file, ao_1e_int_potential_n_e, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_ecp (trexio_t* const file, const double* ao_1e_int_ecp, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_ecp_64(file, ao_1e_int_ecp, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_core_hamiltonian (trexio_t* const file, const double* ao_1e_int_core_hamiltonian, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_core_hamiltonian_64(file, ao_1e_int_core_hamiltonian, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_overlap_im (trexio_t* const file, const double* ao_1e_int_overlap_im, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_overlap_im_64(file, ao_1e_int_overlap_im, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_kinetic_im (trexio_t* const file, const double* ao_1e_int_kinetic_im, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_kinetic_im_64(file, ao_1e_int_kinetic_im, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_potential_n_e_im (trexio_t* const file, const double* ao_1e_int_potential_n_e_im, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_potential_n_e_im_64(file, ao_1e_int_potential_n_e_im, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_ecp_im (trexio_t* const file, const double* ao_1e_int_ecp_im, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_ecp_im_64(file, ao_1e_int_ecp_im, dim_in);
}

trexio_exit_code
trexio_write_safe_ao_1e_int_core_hamiltonian_im (trexio_t* const file, const double* ao_1e_int_core_hamiltonian_im, const int64_t dim_in)
{
  return trexio_write_safe_ao_1e_int_core_hamiltonian_im_64(file, ao_1e_int_core_hamiltonian_im, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_coefficient (trexio_t* const file, const double* mo_coefficient, const int64_t dim_in)
{
  return trexio_write_safe_mo_coefficient_64(file, mo_coefficient, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_coefficient_im (trexio_t* const file, const double* mo_coefficient_im, const int64_t dim_in)
{
  return trexio_write_safe_mo_coefficient_im_64(file, mo_coefficient_im, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_occupation (trexio_t* const file, const double* mo_occupation, const int64_t dim_in)
{
  return trexio_write_safe_mo_occupation_64(file, mo_occupation, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_energy (trexio_t* const file, const double* mo_energy, const int64_t dim_in)
{
  return trexio_write_safe_mo_energy_64(file, mo_energy, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_spin (trexio_t* const file, const int32_t* mo_spin, const int64_t dim_in)
{
  return trexio_write_safe_mo_spin_32(file, mo_spin, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_k_point (trexio_t* const file, const int32_t* mo_k_point, const int64_t dim_in)
{
  return trexio_write_safe_mo_k_point_32(file, mo_k_point, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_overlap (trexio_t* const file, const double* mo_1e_int_overlap, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_overlap_64(file, mo_1e_int_overlap, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_kinetic (trexio_t* const file, const double* mo_1e_int_kinetic, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_kinetic_64(file, mo_1e_int_kinetic, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_potential_n_e (trexio_t* const file, const double* mo_1e_int_potential_n_e, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_potential_n_e_64(file, mo_1e_int_potential_n_e, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_ecp (trexio_t* const file, const double* mo_1e_int_ecp, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_ecp_64(file, mo_1e_int_ecp, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_core_hamiltonian (trexio_t* const file, const double* mo_1e_int_core_hamiltonian, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_core_hamiltonian_64(file, mo_1e_int_core_hamiltonian, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_overlap_im (trexio_t* const file, const double* mo_1e_int_overlap_im, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_overlap_im_64(file, mo_1e_int_overlap_im, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_kinetic_im (trexio_t* const file, const double* mo_1e_int_kinetic_im, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_kinetic_im_64(file, mo_1e_int_kinetic_im, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_potential_n_e_im (trexio_t* const file, const double* mo_1e_int_potential_n_e_im, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_potential_n_e_im_64(file, mo_1e_int_potential_n_e_im, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_ecp_im (trexio_t* const file, const double* mo_1e_int_ecp_im, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_ecp_im_64(file, mo_1e_int_ecp_im, dim_in);
}

trexio_exit_code
trexio_write_safe_mo_1e_int_core_hamiltonian_im (trexio_t* const file, const double* mo_1e_int_core_hamiltonian_im, const int64_t dim_in)
{
  return trexio_write_safe_mo_1e_int_core_hamiltonian_im_64(file, mo_1e_int_core_hamiltonian_im, dim_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e (trexio_t* const file, const double* rdm_1e, const int64_t dim_in)
{
  return trexio_write_safe_rdm_1e_64(file, rdm_1e, dim_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_up (trexio_t* const file, const double* rdm_1e_up, const int64_t dim_in)
{
  return trexio_write_safe_rdm_1e_up_64(file, rdm_1e_up, dim_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_dn (trexio_t* const file, const double* rdm_1e_dn, const int64_t dim_in)
{
  return trexio_write_safe_rdm_1e_dn_64(file, rdm_1e_dn, dim_in);
}

trexio_exit_code
trexio_write_safe_rdm_1e_transition (trexio_t* const file, const double* rdm_1e_transition, const int64_t dim_in)
{
  return trexio_write_safe_rdm_1e_transition_64(file, rdm_1e_transition, dim_in);
}

trexio_exit_code
trexio_write_safe_jastrow_en (trexio_t* const file, const double* jastrow_en, const int64_t dim_in)
{
  return trexio_write_safe_jastrow_en_64(file, jastrow_en, dim_in);
}

trexio_exit_code
trexio_write_safe_jastrow_ee (trexio_t* const file, const double* jastrow_ee, const int64_t dim_in)
{
  return trexio_write_safe_jastrow_ee_64(file, jastrow_ee, dim_in);
}

trexio_exit_code
trexio_write_safe_jastrow_een (trexio_t* const file, const double* jastrow_een, const int64_t dim_in)
{
  return trexio_write_safe_jastrow_een_64(file, jastrow_een, dim_in);
}

trexio_exit_code
trexio_write_safe_jastrow_en_nucleus (trexio_t* const file, const int32_t* jastrow_en_nucleus, const int64_t dim_in)
{
  return trexio_write_safe_jastrow_en_nucleus_32(file, jastrow_en_nucleus, dim_in);
}

trexio_exit_code
trexio_write_safe_jastrow_een_nucleus (trexio_t* const file, const int32_t* jastrow_een_nucleus, const int64_t dim_in)
{
  return trexio_write_safe_jastrow_een_nucleus_32(file, jastrow_een_nucleus, dim_in);
}

trexio_exit_code
trexio_write_safe_jastrow_en_scaling (trexio_t* const file, const double* jastrow_en_scaling, const int64_t dim_in)
{
  return trexio_write_safe_jastrow_en_scaling_64(file, jastrow_en_scaling, dim_in);
}

trexio_exit_code
trexio_write_safe_qmc_point (trexio_t* const file, const double* qmc_point, const int64_t dim_in)
{
  return trexio_write_safe_qmc_point_64(file, qmc_point, dim_in);
}

trexio_exit_code
trexio_write_safe_qmc_psi (trexio_t* const file, const double* qmc_psi, const int64_t dim_in)
{
  return trexio_write_safe_qmc_psi_64(file, qmc_psi, dim_in);
}

trexio_exit_code
trexio_write_safe_qmc_e_loc (trexio_t* const file, const double* qmc_e_loc, const int64_t dim_in)
{
  return trexio_write_safe_qmc_e_loc_64(file, qmc_e_loc, dim_in);
}

trexio_exit_code trexio_write_safe_ao_2e_int_eri(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_ao_2e_int_eri(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_ao_2e_int_eri(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_ao_2e_int_eri_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_ao_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_2e_int_eri(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_2e_int_eri(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_2e_int_eri(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_2e_int_eri(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_2e_int_eri(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_2e_int_eri(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_ao_2e_int_eri_lr(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_ao_2e_int_eri_lr(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_ao_2e_int_eri_lr(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_ao_2e_int_eri_lr_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_ao_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_2e_int_eri_lr(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_2e_int_eri_lr(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_2e_int_eri_lr(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_2e_int_eri_lr(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_2e_int_eri_lr(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_2e_int_eri_lr(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_ao_2e_int_eri_cholesky(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_ao_2e_int_eri_cholesky(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_ao_2e_int_eri_cholesky(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_ao_2e_int_eri_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_ao_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_2e_int_eri_cholesky_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_2e_int_eri_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_2e_int_eri_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_2e_int_eri_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_2e_int_eri_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_2e_int_eri_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_2e_int_eri_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_ao_2e_int_eri_lr_cholesky(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_ao_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_ao_2e_int_eri_lr_cholesky(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_ao_2e_int_eri_lr_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_ao_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_ao_2e_int_eri_lr_cholesky_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_2e_int_eri_lr_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_ao_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_ao_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_ao_2e_int_eri_lr_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_mo_2e_int_eri(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_mo_2e_int_eri(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_mo_2e_int_eri(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_mo_2e_int_eri_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_2e_int_eri(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_2e_int_eri(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_2e_int_eri(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_2e_int_eri(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_2e_int_eri(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_2e_int_eri(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_mo_2e_int_eri_lr(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_mo_2e_int_eri_lr(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_mo_2e_int_eri_lr(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_mo_2e_int_eri_lr_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_2e_int_eri_lr(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_2e_int_eri_lr(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_2e_int_eri_lr(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_2e_int_eri_lr(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_2e_int_eri_lr(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_2e_int_eri_lr(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_mo_2e_int_eri_cholesky(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_mo_2e_int_eri_cholesky(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_mo_2e_int_eri_cholesky(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_mo_2e_int_eri_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_2e_int_eri_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_2e_int_eri_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_2e_int_eri_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_2e_int_eri_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_2e_int_eri_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_2e_int_eri_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_2e_int_eri_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_mo_2e_int_eri_lr_cholesky(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_mo_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_mo_2e_int_eri_lr_cholesky(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_mo_2e_int_eri_lr_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_2e_int_eri_lr_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_2e_int_eri_lr_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_mo_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_mo_2e_int_eri_lr_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_mo_2e_int_eri_lr_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_csf_det_coefficient(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 2;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_csf_det_coefficient(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_csf_det_coefficient(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 2;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_csf_det_coefficient_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_determinant_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_csf_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_csf_det_coefficient(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_csf_det_coefficient(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_csf_det_coefficient(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_csf_det_coefficient(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_csf_det_coefficient(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_csf_det_coefficient(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_amplitude_single(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 2;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_amplitude_single(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_amplitude_single(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 2;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_single_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_single(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_single(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_single(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_single(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_single(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_single(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_amplitude_single_exp(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 2;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_amplitude_single_exp(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_amplitude_single_exp(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 2;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_single_exp_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_single_exp(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_single_exp(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_single_exp(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_single_exp(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_single_exp(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_single_exp(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_amplitude_double(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_amplitude_double(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_amplitude_double(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_double_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_double(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_double(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_double(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_double(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_double(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_double(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_amplitude_double_exp(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_amplitude_double_exp(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_amplitude_double_exp(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_double_exp_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_double_exp(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_double_exp(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_double_exp(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_double_exp(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_double_exp(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_double_exp(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_amplitude_triple(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 6;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_amplitude_triple(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_amplitude_triple(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 6;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_triple_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_triple(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_triple(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_triple(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_triple(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_triple(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_triple(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_amplitude_triple_exp(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 6;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_amplitude_triple_exp(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_amplitude_triple_exp(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 6;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_triple_exp_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_triple_exp(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_triple_exp(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_triple_exp(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_triple_exp(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_triple_exp(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_triple_exp(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_amplitude_quadruple(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 8;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_amplitude_quadruple(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_amplitude_quadruple(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 8;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_quadruple_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_quadruple(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_quadruple(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_quadruple(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_quadruple(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_quadruple(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_quadruple(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_amplitude_quadruple_exp(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 8;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_amplitude_quadruple_exp(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_amplitude_quadruple_exp(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 8;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_amplitude_quadruple_exp_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_quadruple_exp(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_quadruple_exp(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_quadruple_exp(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_amplitude_quadruple_exp(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_amplitude_quadruple_exp(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_amplitude_quadruple_exp(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_rdm_2e(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_rdm_2e(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_rdm_2e(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_rdm_2e_upup(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_rdm_2e_upup(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_rdm_2e_upup(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_upup_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_upup(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_upup(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_upup(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_upup(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_upup(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_upup(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_rdm_2e_dndn(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_rdm_2e_dndn(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_rdm_2e_dndn(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_dndn_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_dndn(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_dndn(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_dndn(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_dndn(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_dndn(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_dndn(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_rdm_2e_updn(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_rdm_2e_updn(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_rdm_2e_updn(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 4;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_updn_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 1
  int64_t unique_dims[1];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_mo_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_updn(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_updn(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_updn(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_updn(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_updn(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_updn(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_rdm_2e_transition(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 6;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_rdm_2e_transition(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_rdm_2e_transition(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 6;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_transition_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_state_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_transition(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_transition(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_transition(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_transition(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_transition(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_transition(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_rdm_2e_cholesky(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_rdm_2e_cholesky(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_rdm_2e_cholesky(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_rdm_2e_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_rdm_2e_upup_cholesky(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_rdm_2e_upup_cholesky(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_rdm_2e_upup_cholesky(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_upup_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_rdm_2e_upup_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_upup_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_upup_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_upup_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_upup_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_upup_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_upup_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_rdm_2e_dndn_cholesky(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_rdm_2e_dndn_cholesky(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_rdm_2e_dndn_cholesky(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_dndn_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_rdm_2e_dndn_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_dndn_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_dndn_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_dndn_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_dndn_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_dndn_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_dndn_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code trexio_write_safe_rdm_2e_updn_cholesky(trexio_t* const file,
                                                const int64_t offset_file,
                                                const int64_t buffer_size,
                                                const int32_t* index_sparse_write,
                                                const int64_t size_index_write,
                                                const double* value_sparse_write,
                                                const int64_t size_value_write
                                                )
{
  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  if (size_index_write < rank * buffer_size) return TREXIO_INVALID_ARG_5;
  if (size_value_write <        buffer_size) return TREXIO_INVALID_ARG_7;

  return trexio_write_rdm_2e_updn_cholesky(file, offset_file, buffer_size, index_sparse_write, value_sparse_write);
}

trexio_exit_code
trexio_write_rdm_2e_updn_cholesky(trexio_t* const file,
                          const int64_t offset_file,
                          const int64_t buffer_size,
                          const int32_t* index_sparse,
                          const double* value_sparse
                          )
{
  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0L) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0L) return TREXIO_INVALID_ARG_3;
  if (index_sparse == NULL) return TREXIO_INVALID_ARG_4;
  if (value_sparse == NULL) return TREXIO_INVALID_ARG_5;

  /* To be set by generator : number of indices */
  const uint32_t rank = 3;

  int64_t size_max = 0L; // Max number of integrals (already in the file)

  /* Read the max number of integrals stored in the file */
  trexio_exit_code rc = trexio_read_rdm_2e_updn_cholesky_size(file, &size_max);
  if (rc != TREXIO_SUCCESS && rc != TREXIO_DSET_MISSING) return rc;
  if (rc == TREXIO_DSET_MISSING) size_max = 0L;

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < size_max) return TREXIO_CORRUPTION_ATTEMPT;

  /* To be set by generator : number of unique dimensions
     (e.g. 1 for ERI in AO basis because only ao_num is present in the list of dimensions) */
#define unique_rank 2
  int64_t unique_dims[2];

  // Below part is populated by the generator when unique_rank > 1
  rc = trexio_read_rdm_2e_updn_cholesky_num_64(file, &unique_dims[0]); if (rc != TREXIO_SUCCESS) return rc;
  rc = trexio_read_mo_num_64(file, &unique_dims[1]); if (rc != TREXIO_SUCCESS) return rc;

  /* Find the maximal value along all dimensions to define the compression technique in the back end */
  int64_t max_dim = unique_dims[0];
#if (unique_rank != 1)
  for (uint32_t i = 1; i < unique_rank; i++) {
    if (unique_dims[i] > max_dim) max_dim = unique_dims[i];
  }
#endif
#undef unique_rank

  // shift indices to be zero-based if Fortran API is used
  if (file->one_based) {

    uint64_t index_size = rank * buffer_size;

    int32_t* index_sparse_p = CALLOC(index_size, int32_t);
    if (index_sparse_p == NULL) return TREXIO_ALLOCATION_FAILED;

    for (uint64_t i=0; i<index_size; ++i){
      index_sparse_p[i] = index_sparse[i] - 1;
    }

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_updn_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse_p, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_updn_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse_p, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_updn_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

    FREE(index_sparse_p);

  }
  else {

    switch (file->back_end) {

    case TREXIO_TEXT:
      rc = trexio_text_write_rdm_2e_updn_cholesky(file, offset_file, buffer_size, max_dim,
                                          size_max, index_sparse, value_sparse);
      break;

    case TREXIO_HDF5:
#ifdef HAVE_HDF5
      rc = trexio_hdf5_write_rdm_2e_updn_cholesky(file, offset_file, buffer_size, max_dim,
                                          index_sparse, value_sparse);
      break;
#else
      rc = TREXIO_BACK_END_MISSING;
      break;
#endif
      /*
        case TREXIO_JSON:
        rc = trexio_json_write_rdm_2e_updn_cholesky(...);
        break;
      */
    default:
      rc = TREXIO_FAILURE;  /* Impossible case */
      break;
    }

  }

  return rc;
}

trexio_exit_code
trexio_write_metadata_code_low (trexio_t* const file, char* dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_code(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t metadata_code_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_metadata_code_num_64(file, &(metadata_code_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (metadata_code_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {metadata_code_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  char*  tmp_str  = CALLOC(dims[0]*(max_str_len+1), char);
  if (tmp_str == NULL) return TREXIO_ALLOCATION_FAILED;
  char** dset_str = CALLOC(dims[0], char*);
  if (dset_str == NULL) {
    FREE(tmp_str);
    return TREXIO_ALLOCATION_FAILED;
  }

  /* parse the string using strtok */
  for(uint64_t i=0; i<dims[0]; i++) {

    char* pch;
    pch = i == 0 ? strtok(dset_in, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;

    if (pch == NULL) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_FAILURE;
    }

    size_t pch_len = strlen(pch) + 1;

    if (pch_len > (size_t) max_str_len) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_INVALID_STR_LEN;
    }

    dset_str[i] = tmp_str;
    strncpy(tmp_str, pch, pch_len);
    tmp_str += pch_len + 1;
  }

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_metadata_code(file, (const char**) dset_str, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_metadata_code(file, (const char**) dset_str, rank, dims);
    break;
#else
    rc =TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_metadata_code(file, dset, rank, dims);
    break;
*/
  }

  FREE(dset_str[0]);
  FREE(dset_str);

  return rc;

}

trexio_exit_code
trexio_write_metadata_code (trexio_t* const file, const char** dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_code(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_metadata_code_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*max_str_len + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  strcpy(str_compiled, "");
  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {
    strcat(str_compiled, dset_in[i]);
    strcat(str_compiled, TREXIO_DELIM);
  }

  rc = trexio_write_metadata_code_low(file, str_compiled, max_str_len);

  FREE(str_compiled);

  return rc;
}

trexio_exit_code
trexio_write_metadata_author_low (trexio_t* const file, char* dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_author(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t metadata_author_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_metadata_author_num_64(file, &(metadata_author_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (metadata_author_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {metadata_author_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  char*  tmp_str  = CALLOC(dims[0]*(max_str_len+1), char);
  if (tmp_str == NULL) return TREXIO_ALLOCATION_FAILED;
  char** dset_str = CALLOC(dims[0], char*);
  if (dset_str == NULL) {
    FREE(tmp_str);
    return TREXIO_ALLOCATION_FAILED;
  }

  /* parse the string using strtok */
  for(uint64_t i=0; i<dims[0]; i++) {

    char* pch;
    pch = i == 0 ? strtok(dset_in, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;

    if (pch == NULL) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_FAILURE;
    }

    size_t pch_len = strlen(pch) + 1;

    if (pch_len > (size_t) max_str_len) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_INVALID_STR_LEN;
    }

    dset_str[i] = tmp_str;
    strncpy(tmp_str, pch, pch_len);
    tmp_str += pch_len + 1;
  }

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_metadata_author(file, (const char**) dset_str, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_metadata_author(file, (const char**) dset_str, rank, dims);
    break;
#else
    rc =TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_metadata_author(file, dset, rank, dims);
    break;
*/
  }

  FREE(dset_str[0]);
  FREE(dset_str);

  return rc;

}

trexio_exit_code
trexio_write_metadata_author (trexio_t* const file, const char** dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_metadata_author(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_metadata_author_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*max_str_len + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  strcpy(str_compiled, "");
  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {
    strcat(str_compiled, dset_in[i]);
    strcat(str_compiled, TREXIO_DELIM);
  }

  rc = trexio_write_metadata_author_low(file, str_compiled, max_str_len);

  FREE(str_compiled);

  return rc;
}

trexio_exit_code
trexio_write_nucleus_label_low (trexio_t* const file, char* dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_nucleus_label(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t nucleus_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_nucleus_num_64(file, &(nucleus_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (nucleus_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {nucleus_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  char*  tmp_str  = CALLOC(dims[0]*(max_str_len+1), char);
  if (tmp_str == NULL) return TREXIO_ALLOCATION_FAILED;
  char** dset_str = CALLOC(dims[0], char*);
  if (dset_str == NULL) {
    FREE(tmp_str);
    return TREXIO_ALLOCATION_FAILED;
  }

  /* parse the string using strtok */
  for(uint64_t i=0; i<dims[0]; i++) {

    char* pch;
    pch = i == 0 ? strtok(dset_in, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;

    if (pch == NULL) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_FAILURE;
    }

    size_t pch_len = strlen(pch) + 1;

    if (pch_len > (size_t) max_str_len) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_INVALID_STR_LEN;
    }

    dset_str[i] = tmp_str;
    strncpy(tmp_str, pch, pch_len);
    tmp_str += pch_len + 1;
  }

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_nucleus_label(file, (const char**) dset_str, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_nucleus_label(file, (const char**) dset_str, rank, dims);
    break;
#else
    rc =TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_nucleus_label(file, dset, rank, dims);
    break;
*/
  }

  FREE(dset_str[0]);
  FREE(dset_str);

  return rc;

}

trexio_exit_code
trexio_write_nucleus_label (trexio_t* const file, const char** dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_nucleus_label(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_nucleus_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*max_str_len + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  strcpy(str_compiled, "");
  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {
    strcat(str_compiled, dset_in[i]);
    strcat(str_compiled, TREXIO_DELIM);
  }

  rc = trexio_write_nucleus_label_low(file, str_compiled, max_str_len);

  FREE(str_compiled);

  return rc;
}

trexio_exit_code
trexio_write_state_label_low (trexio_t* const file, char* dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_label(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t state_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_state_num_64(file, &(state_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (state_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {state_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  char*  tmp_str  = CALLOC(dims[0]*(max_str_len+1), char);
  if (tmp_str == NULL) return TREXIO_ALLOCATION_FAILED;
  char** dset_str = CALLOC(dims[0], char*);
  if (dset_str == NULL) {
    FREE(tmp_str);
    return TREXIO_ALLOCATION_FAILED;
  }

  /* parse the string using strtok */
  for(uint64_t i=0; i<dims[0]; i++) {

    char* pch;
    pch = i == 0 ? strtok(dset_in, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;

    if (pch == NULL) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_FAILURE;
    }

    size_t pch_len = strlen(pch) + 1;

    if (pch_len > (size_t) max_str_len) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_INVALID_STR_LEN;
    }

    dset_str[i] = tmp_str;
    strncpy(tmp_str, pch, pch_len);
    tmp_str += pch_len + 1;
  }

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_state_label(file, (const char**) dset_str, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_state_label(file, (const char**) dset_str, rank, dims);
    break;
#else
    rc =TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_state_label(file, dset, rank, dims);
    break;
*/
  }

  FREE(dset_str[0]);
  FREE(dset_str);

  return rc;

}

trexio_exit_code
trexio_write_state_label (trexio_t* const file, const char** dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_label(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_state_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*max_str_len + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  strcpy(str_compiled, "");
  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {
    strcat(str_compiled, dset_in[i]);
    strcat(str_compiled, TREXIO_DELIM);
  }

  rc = trexio_write_state_label_low(file, str_compiled, max_str_len);

  FREE(str_compiled);

  return rc;
}

trexio_exit_code
trexio_write_state_file_name_low (trexio_t* const file, char* dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_file_name(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t state_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_state_num_64(file, &(state_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (state_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {state_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  char*  tmp_str  = CALLOC(dims[0]*(max_str_len+1), char);
  if (tmp_str == NULL) return TREXIO_ALLOCATION_FAILED;
  char** dset_str = CALLOC(dims[0], char*);
  if (dset_str == NULL) {
    FREE(tmp_str);
    return TREXIO_ALLOCATION_FAILED;
  }

  /* parse the string using strtok */
  for(uint64_t i=0; i<dims[0]; i++) {

    char* pch;
    pch = i == 0 ? strtok(dset_in, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;

    if (pch == NULL) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_FAILURE;
    }

    size_t pch_len = strlen(pch) + 1;

    if (pch_len > (size_t) max_str_len) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_INVALID_STR_LEN;
    }

    dset_str[i] = tmp_str;
    strncpy(tmp_str, pch, pch_len);
    tmp_str += pch_len + 1;
  }

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_state_file_name(file, (const char**) dset_str, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_state_file_name(file, (const char**) dset_str, rank, dims);
    break;
#else
    rc =TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_state_file_name(file, dset, rank, dims);
    break;
*/
  }

  FREE(dset_str[0]);
  FREE(dset_str);

  return rc;

}

trexio_exit_code
trexio_write_state_file_name (trexio_t* const file, const char** dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_state_file_name(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_state_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*max_str_len + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  strcpy(str_compiled, "");
  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {
    strcat(str_compiled, dset_in[i]);
    strcat(str_compiled, TREXIO_DELIM);
  }

  rc = trexio_write_state_file_name_low(file, str_compiled, max_str_len);

  FREE(str_compiled);

  return rc;
}

trexio_exit_code
trexio_write_mo_class_low (trexio_t* const file, char* dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_class(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  char*  tmp_str  = CALLOC(dims[0]*(max_str_len+1), char);
  if (tmp_str == NULL) return TREXIO_ALLOCATION_FAILED;
  char** dset_str = CALLOC(dims[0], char*);
  if (dset_str == NULL) {
    FREE(tmp_str);
    return TREXIO_ALLOCATION_FAILED;
  }

  /* parse the string using strtok */
  for(uint64_t i=0; i<dims[0]; i++) {

    char* pch;
    pch = i == 0 ? strtok(dset_in, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;

    if (pch == NULL) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_FAILURE;
    }

    size_t pch_len = strlen(pch) + 1;

    if (pch_len > (size_t) max_str_len) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_INVALID_STR_LEN;
    }

    dset_str[i] = tmp_str;
    strncpy(tmp_str, pch, pch_len);
    tmp_str += pch_len + 1;
  }

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_class(file, (const char**) dset_str, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_class(file, (const char**) dset_str, rank, dims);
    break;
#else
    rc =TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_class(file, dset, rank, dims);
    break;
*/
  }

  FREE(dset_str[0]);
  FREE(dset_str);

  return rc;

}

trexio_exit_code
trexio_write_mo_class (trexio_t* const file, const char** dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_class(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_mo_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*max_str_len + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  strcpy(str_compiled, "");
  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {
    strcat(str_compiled, dset_in[i]);
    strcat(str_compiled, TREXIO_DELIM);
  }

  rc = trexio_write_mo_class_low(file, str_compiled, max_str_len);

  FREE(str_compiled);

  return rc;
}

trexio_exit_code
trexio_write_mo_symmetry_low (trexio_t* const file, char* dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_symmetry(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  int64_t mo_num = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_mo_num_64(file, &(mo_num));
  if (rc != TREXIO_SUCCESS) return rc;

  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  uint32_t rank = 1;
  uint64_t dims[1] = {mo_num};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  char*  tmp_str  = CALLOC(dims[0]*(max_str_len+1), char);
  if (tmp_str == NULL) return TREXIO_ALLOCATION_FAILED;
  char** dset_str = CALLOC(dims[0], char*);
  if (dset_str == NULL) {
    FREE(tmp_str);
    return TREXIO_ALLOCATION_FAILED;
  }

  /* parse the string using strtok */
  for(uint64_t i=0; i<dims[0]; i++) {

    char* pch;
    pch = i == 0 ? strtok(dset_in, TREXIO_DELIM) : strtok(NULL, TREXIO_DELIM) ;

    if (pch == NULL) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_FAILURE;
    }

    size_t pch_len = strlen(pch) + 1;

    if (pch_len > (size_t) max_str_len) {
      FREE(dset_str[0]);
      FREE(dset_str);
      return TREXIO_INVALID_STR_LEN;
    }

    dset_str[i] = tmp_str;
    strncpy(tmp_str, pch, pch_len);
    tmp_str += pch_len + 1;
  }

  rc = TREXIO_FAILURE;
  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_mo_symmetry(file, (const char**) dset_str, rank, dims);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_mo_symmetry(file, (const char**) dset_str, rank, dims);
    break;
#else
    rc =TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_write_mo_symmetry(file, dset, rank, dims);
    break;
*/
  }

  FREE(dset_str[0]);
  FREE(dset_str);

  return rc;

}

trexio_exit_code
trexio_write_mo_symmetry (trexio_t* const file, const char** dset_in, const int32_t max_str_len)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (dset_in == NULL) return TREXIO_INVALID_ARG_2;
  if (max_str_len <= 0) return TREXIO_INVALID_ARG_3;
  if (trexio_has_mo_symmetry(file) == TREXIO_SUCCESS && file->mode != 'u') return TREXIO_DSET_ALREADY_EXISTS;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  int64_t dset_dim = 0;

  /* Error handling for this call is added by the generator */
  trexio_exit_code rc = trexio_read_mo_num_64(file, &(dset_dim));
  if (rc != TREXIO_SUCCESS) return rc;

  if (dset_dim == 0L) return TREXIO_INVALID_NUM;

  char* str_compiled = CALLOC(dset_dim*max_str_len + 1, char);
  if (str_compiled == NULL) return TREXIO_ALLOCATION_FAILED;

  strcpy(str_compiled, "");
  for (uint64_t i=0; i < (uint64_t) dset_dim; i++) {
    strcat(str_compiled, dset_in[i]);
    strcat(str_compiled, TREXIO_DELIM);
  }

  rc = trexio_write_mo_symmetry_low(file, str_compiled, max_str_len);

  FREE(str_compiled);

  return rc;
}

trexio_exit_code
trexio_has_determinant_list (trexio_t* const file)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  switch (file->back_end) {

  case TREXIO_TEXT:
    return trexio_text_has_determinant_list(file);

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    return trexio_hdf5_has_determinant_list(file);
#else
    return TREXIO_BACK_END_MISSING;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_has_
    break;
*/
  }

  return TREXIO_FAILURE;
}
trexio_exit_code
trexio_get_int64_num(trexio_t* const file, int32_t* const num)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (num   == NULL) return TREXIO_INVALID_ARG_2;

  /* Read the number of mos */
  int64_t mo_num = 0L;
  trexio_exit_code rc = trexio_read_mo_num_64(file, &mo_num);
  if (rc != TREXIO_SUCCESS) return rc;
  if (mo_num == 0L) return TREXIO_INVALID_NUM;

  /* Compute how many integer numbers is needed to represent a determinant */
  int32_t int_num = 0;
  int_num = (int32_t) (mo_num - 1L)/64 + 1;

  *num = int_num;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_read_determinant_list (trexio_t* const file, const int64_t offset_file, int64_t* const buffer_size_read, int64_t* const dset)
{

  if (file  == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0) return TREXIO_INVALID_ARG_2;
  if (buffer_size_read == NULL) return TREXIO_INVALID_ARG_3;
  if (*buffer_size_read < 0) return TREXIO_INVALID_ARG_3;
  if (dset  == NULL) return TREXIO_INVALID_ARG_4;
  if (trexio_has_determinant_list(file) != TREXIO_SUCCESS) return TREXIO_DSET_MISSING;

  /* Get the number of int bit fields per determinant */
  int32_t int_num = 0;
  trexio_exit_code rc = trexio_get_int64_num(file, &int_num);
  if (rc != TREXIO_SUCCESS) return rc;

  uint32_t rank = 2;
  uint64_t det_size = (uint64_t) (*buffer_size_read);
  uint64_t dims[2] = {det_size, int_num*2UL};

  // introduce a new variable which will be modified with the number of integrals being read if EOF is encountered
  int64_t eof_read_size = 0L;

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_read_determinant_list(file, offset_file, rank, dims, &eof_read_size, dset);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_read_determinant_list(file, offset_file, rank, dims, &eof_read_size, dset);
    break;
#else
    rc = TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    return trexio_json_read_$group_dset$(...);
    break;
*/
  default:
    rc = TREXIO_FAILURE;  /* Impossible case */
    break;
  }

  if (rc != TREXIO_SUCCESS && rc != TREXIO_END) return rc;

  if (rc == TREXIO_END) *buffer_size_read = eof_read_size;

  return rc;
}

trexio_exit_code
trexio_read_safe_determinant_list (trexio_t* const file, const int64_t offset_file, int64_t* const buffer_size_read, int64_t* const dset_out, const int64_t dim_out)
{
  /* Get the number of int bit fields per determinant */
  int32_t int_num = 0;
  trexio_exit_code rc = trexio_get_int64_num(file, &int_num);
  if (rc != TREXIO_SUCCESS) return rc;

  /* Check that dset_out is large enough */
  if (dim_out < (*buffer_size_read) * int_num * 2) return TREXIO_INVALID_ARG_5;

  return trexio_read_determinant_list(file, offset_file, buffer_size_read, dset_out);
}
trexio_exit_code
trexio_write_determinant_list (trexio_t* const file, const int64_t offset_file, const int64_t buffer_size, const int64_t* dset)
{

  if (file == NULL) return TREXIO_INVALID_ARG_1;
  if (offset_file < 0) return TREXIO_INVALID_ARG_2;
  if (buffer_size <= 0) return TREXIO_INVALID_ARG_3;
  if (dset == NULL) return TREXIO_INVALID_ARG_4;

  // Update the determinant_num value with the number of determinants written
  int64_t det_num_current = 0L;
  // Read the determinant_num if it exists already
  if (trexio_has_determinant_num(file) == TREXIO_SUCCESS) {
     trexio_exit_code rc = trexio_read_determinant_num_64(file, &det_num_current);
     if (rc != TREXIO_SUCCESS) return rc;
  }

  /* Dummy check to avoid overwriting existing data */
  if (offset_file < det_num_current) return TREXIO_CORRUPTION_ATTEMPT;

  /* Get the number of int bit fields per determinant */
  int32_t int_num = 0;
  trexio_exit_code rc = trexio_get_int64_num(file, &int_num);
  if (rc != TREXIO_SUCCESS) return rc;

  uint32_t rank = 2;
  uint64_t dims[2] = {buffer_size, int_num*2UL};

  assert(file->back_end < TREXIO_INVALID_BACK_END);

  /* Read the number of mos */
  int64_t mo_num = 0L;
  rc = trexio_read_mo_num_64(file, &mo_num);
  if (rc != TREXIO_SUCCESS) return rc;

  // Read up/dn num
  int32_t nup = 0;
  rc = trexio_read_electron_up_num(file, &nup);
  if (rc != TREXIO_SUCCESS) return rc;

  int32_t ndn = 0;
  rc = trexio_read_electron_dn_num(file, &ndn);
  if (rc != TREXIO_SUCCESS) return rc;

  /* Check all determinants */
  int32_t occ_num_up = 0;
  int32_t occ_num_dn = 0;

  /*   list_up contains first the up-spin orbitals, then the down-spin */
  int32_t* list_up = (int32_t*) calloc(nup+ndn,sizeof(int32_t));

  if (list_up == NULL) {
    return TREXIO_ALLOCATION_FAILED;
  }

  int32_t* list_dn = &(list_up[nup]);

  for (int64_t i=0 ; i<buffer_size ; i+= 2*int_num) {
    rc = trexio_to_orbital_list_up_dn(int_num, &dset[i],
                                      list_up, list_dn,
                                      &occ_num_up, &occ_num_dn);
    if (rc != TREXIO_SUCCESS) {
        free(list_up);
        return rc;
    }
    if (occ_num_up != nup || occ_num_dn != ndn) {
        free(list_up);
        return TREXIO_INVALID_ELECTRON_NUM;
    }
    for (int32_t j=0 ; j<nup+ndn ; ++j) {
      if (list_up[j] < 0 || list_up[j] >= mo_num) {
        free(list_up);
        return TREXIO_INVALID_MO_INDEX;
      }
    }

  }
  free(list_up);

  /* Up to this point, all the determinants have been checked to
     have the correct sizes (number of electrons), and MOs in the
     correct range */

  switch (file->back_end) {

  case TREXIO_TEXT:
    rc = trexio_text_write_determinant_list(file, offset_file, rank, dims, dset);
    break;

  case TREXIO_HDF5:
#ifdef HAVE_HDF5
    rc = trexio_hdf5_write_determinant_list(file, offset_file, rank, dims, dset);
    break;
#else
    return TREXIO_BACK_END_MISSING;
    break;
#endif
/*
  case TREXIO_JSON:
    rc = trexio_json_read_
    break;
*/
  }

  if (rc != TREXIO_SUCCESS) return rc;

  // Update the determinant_num value with the number of determinants written
  int64_t det_num = 0L;
  // Read the determinant_num if it exists already
  if (trexio_has_determinant_num(file) == TREXIO_SUCCESS) {
     rc = trexio_read_determinant_num_64(file, &det_num);
     if (rc != TREXIO_SUCCESS) return rc;
  }
  // Check for the INT64 overflow before writing an updated value
  if (INT64_MAX - det_num > buffer_size) {
    det_num += buffer_size;
  } else {
    return TREXIO_INT_SIZE_OVERFLOW;
  }
  // Overwrite previous value. Here we have to temporarily set the file->mode to 'u' to trick the API
  //   in order to overwrite existing determinant_num. Otherwise the API returns TREXIO_NUM_ALREADY_EXISTS.
  char mode_tmp = file->mode;
  file->mode = 'u';
  rc = trexio_write_determinant_num_64(file, det_num);
  file->mode = mode_tmp;
  if (rc != TREXIO_SUCCESS) return rc;

  return TREXIO_SUCCESS;
}

trexio_exit_code
trexio_write_safe_determinant_list (trexio_t* const file, const int64_t offset_file, const int64_t buffer_size, const int64_t* dset_in, const int64_t dim_in)
{
  /* Get the number of int bit fields per determinant */
  int32_t int_num = 0;
  trexio_exit_code rc = trexio_get_int64_num(file, &int_num);
  if (rc != TREXIO_SUCCESS) return rc;

  /* Check that dim_in is large enough */
  if (dim_in < buffer_size * int_num * 2) return TREXIO_INVALID_ARG_5;

  return trexio_write_determinant_list(file, offset_file, buffer_size, dset_in);
}
